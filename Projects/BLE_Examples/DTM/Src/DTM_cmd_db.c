/**
  ******************************************************************************
  * @file    DTM_cmd_db.c
  * @author  AMS - RF Application team
  * @date    18 March 2022
  * @brief   Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>
  ******************************************************************************
  */
#include "compiler.h"
#include "bluenrg_lp_api.h"
#include "bluenrg_lp_events.h"
#include "osal.h"
#include "system_util.h"
#include "aci_gatt_nwk.h"
#include "aci_adv_nwk.h"
#include "aci_l2cap_nwk.h"
#include "DTM_cmd_db.h"

#define HCI_MAX_PAYLOAD_SIZE 256
#include <stdint.h>

/** Documentation for C struct Advertising_Set_Parameters_t */
typedef PACKED(struct) packed_Advertising_Set_Parameters_t_s {
  /** It is used to identify an advertising set.
   *  Values:
   *  - 0x00 ... 0xEF
   */
  uint8_t Advertising_Handle;
  /** The Duration[i] parameter indicates the duration for which that advertising set
   *  is enabled. The duration begins at the start of the first advertising
   *  event of this advertising set. The Controller should not start an extended
   *  advertising event that it cannot complete within the duration. Time = N *
   *  10 ms 0x00 means no advertising duration: advertising will continue until
   *  the Host disables it.
   *  Values:
   *  - 0x0000 (0 ms) : No advertising duration
   *  - 0x0001 (10 ms)  ... 0xFFFF (655350 ms) 
   */
  uint16_t Duration;
  /** The Max_Extended_Advertising_Events[i] parameter, if non-zero, indicates the
   *  maximum number of extended advertising events that shall be sent prior to
   *  disabling the extended advertising set even if the Duration[i] parameter
   *  has not expired.
   *  Values:
   *  - 0x00: No maximum number of advertising events.
   *  - 0x01 ... 0xFF: Maximum number of extended advertising events.
   */
  uint8_t Max_Extended_Advertising_Events;
} packed_Advertising_Set_Parameters_t;
/** Documentation for C struct Extended_Scan_Parameters_t */
typedef PACKED(struct) packed_Extended_Scan_Parameters_t_s {
  /** The Scan_Type parameter specifies the type of scan to perform. 0: Passive
   *  Scanning. No scan request PDUs shall be sent. 1: Active Scanning. Scan
   *  request PDUs may be sent.
   *  Values:
   *  - 0x00: Passive Scanning
   *  - 0x01: Active Scanning
   */
  uint8_t Scan_Type;
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel.  Time = N * 0.625 ms
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Window;
} packed_Extended_Scan_Parameters_t;
/** Documentation for C struct Extended_Create_Connection_Parameters_t */
typedef PACKED(struct) packed_Extended_Create_Connection_Parameters_t_s {
  /** Time interval from when the Controller started its last scan until it begins the
   *  subsequent scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Interval;
  /** Duration of the scan on the primary advertising channel. Time = N * 0.625 ms;
   *  Time Range: 2.5 ms to 40.959375 s.
   *  Values:
   *  - 0x0004 (2.500 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Scan_Window;
  /** Mimimun value for the connection interval. This shall be less than or equal to
   *  Conn_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   */
  uint16_t Conn_Interval_Min;
  /** Maximum value for the connection interval. This shall be less than or equal to
   *  Conn_Interval_Max[i]. Time = N * 1.25 ms; Time Range: 7.5 ms to 4 s.
   *  Values:
   *  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
   */
  uint16_t Conn_Interval_Max;
  /** Slave latency for the connection in number of connection events
   *  Values:
   *  - 0x0000 ... 0x01F3
   */
  uint16_t Conn_Latency;
  /** Supervision timeout for the LE Link. (See [Vol 6] Part B, Section 4.5.2) Time =
   *  N * 10 ms; Time Range: 100 ms to 32 s.
   *  Values:
   *  - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
   */
  uint16_t Supervision_Timeout;
  /** Informative parameter recommending the minimum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Minimum_CE_Length;
  /** Informative parameter recommending the maximum length of connection event needed
   *  for this LE connection. Time = N * 0.625 ms.
   *  Values:
   *  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms) 
   */
  uint16_t Maximum_CE_Length;
} packed_Extended_Create_Connection_Parameters_t;
/** Documentation for C struct Bonded_Device_Entry_t */
typedef PACKED(struct) packed_Bonded_Device_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Address_Type;
  /** Identity Address (Public or Random) of the device.
   */
  uint8_t Address[6];
} packed_Bonded_Device_Entry_t;
/** Documentation for C struct List_Entry_t */
typedef PACKED(struct) packed_List_Entry_t_s {
  /** Address type.
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   */
  uint8_t Peer_Address_Type;
  /** Public Device Address or Random Device Address of the device to be added to the
   *  list.
   */
  uint8_t Peer_Address[6];
} packed_List_Entry_t;
/** Documentation for C union Service_UUID_t */
typedef PACKED(union) packed_Service_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t Service_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Service_UUID_128[16];
} packed_Service_UUID_t;
/** Documentation for C union Char_UUID_t */
typedef PACKED(union) packed_Char_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t Char_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Char_UUID_128[16];
} packed_Char_UUID_t;
/** Documentation for C union Char_Desc_Uuid_t */
typedef PACKED(union) packed_Char_Desc_Uuid_t_s {
  /** 16-bit UUID
   */
  uint16_t Char_UUID_16;
  /** 128-bit UUID
   */
  uint8_t Char_UUID_128[16];
} packed_Char_Desc_Uuid_t;
/** Documentation for C union UUID_t */
typedef PACKED(union) packed_UUID_t_s {
  /** 16-bit UUID
   */
  uint16_t UUID_16;
  /** 128-bit UUID
   */
  uint8_t UUID_128[16];
} packed_UUID_t;
/** Documentation for C struct Handle_Entry_t */
typedef PACKED(struct) packed_Handle_Entry_t_s {
  /** The handles for which the attribute value has to be read
   *  Values:
   *  - 0x0001 ... 0xFFFF
   */
  uint16_t Handle;
} packed_Handle_Entry_t;
/** Documentation for C struct Handle_Packets_Pair_Entry_t */
typedef PACKED(struct) packed_Handle_Packets_Pair_Entry_t_s {
  /** Connection handle
   */
  uint16_t Connection_Handle;
  /** The number of HCI Data Packets that have been completed (transmitted or flushed)
   *  for the associated Connection_Handle since the previous time the event was
   *  returned.
   */
  uint16_t HC_Num_Of_Completed_Packets;
} packed_Handle_Packets_Pair_Entry_t;
/** Documentation for C struct Attribute_Group_Handle_Pair_t */
typedef PACKED(struct) packed_Attribute_Group_Handle_Pair_t_s {
  /** Found Attribute handle
   */
  uint16_t Found_Attribute_Handle;
  /** Group End handle
   */
  uint16_t Group_End_Handle;
} packed_Attribute_Group_Handle_Pair_t;
/** Documentation for C struct Advertising_Report_t */
typedef PACKED(struct) packed_Advertising_Report_t_s {
  /** Type of advertising report event: ADV_IND: Connectable undirected advertising',
   *  ADV_DIRECT_IND: Connectable directed advertising, ADV_SCAN_IND: Scannable
   *  undirected advertising, ADV_NONCONN_IND: Non connectable undirected
   *  advertising, SCAN_RSP: Scan response.
   *  Values:
   *  - 0x00: ADV_IND
   *  - 0x01: ADV_DIRECT_IND
   *  - 0x02: ADV_SCAN_IND
   *  - 0x03: ADV_NONCONN_IND
   *  - 0x04: SCAN_RSP
   */
  uint8_t Event_Type;
  /** 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
   *  Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
   *  Identity Address (Corresponds to Resolved Private Address)
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address
   *  - 0x03: Random (Static) Identity Address
   */
  uint8_t Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the advertising device.
   */
  uint8_t Address[6];
  /** Length of the Data[i] field for each device which responded.
   *  Values:
   *  - 0 ... 31
   */
  uint8_t Data_Length;
  /** Data_Length octets of advertising or scan response data formatted as defined in
   *  [Vol 3] Part C, Section 8.
   */
  uint8_t Data[1];
  /** N Size: 1 Octet (signed integer) Units: dBm
   *  Values:
   *  - -127 ... 20
   *  - 127: RSSI not available
   */
  int8_t RSSI;
} packed_Advertising_Report_t;
/** Documentation for C struct Direct_Advertising_Report_t */
typedef PACKED(struct) packed_Direct_Advertising_Report_t_s {
  /** Advertising type
   *  Values:
   *  - 0x01: Connectable directed advertising (ADV_DIRECT_IND)
   */
  uint8_t Event_Type;
  /** 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
   *  Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
   *  Identity Address (Corresponds to Resolved Private Address)
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address
   *  - 0x03: Random (Static) Identity Address
   */
  uint8_t Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the advertising device.
   */
  uint8_t Address[6];
  /** 0x01 Random Device Address
   *  Values:
   *  - 0x01: Random Device Address
   */
  uint8_t Direct_Address_Type;
  /** Random Device Address
   */
  uint8_t Direct_Address[6];
  /** N Size: 1 Octet (signed integer) Units: dBm
   *  Values:
   *  - -127 ... 20
   *  - 127: RSSI not available
   */
  int8_t RSSI;
} packed_Direct_Advertising_Report_t;
/** Documentation for C struct Extended_Advertising_Report_t */
typedef PACKED(struct) packed_Extended_Advertising_Report_t_s {
  /** Event Type parameter. Bits from 0 to 4: 0 Connectable advertising 1 Scannable
   *  advertising 2 Directed advertising 3 Scan response 4 Legacy advertising
   *  PDUs used Bits 5-6 Data status: 00b = Complete 01b = Incomplete, more data
   *  to come 10b = Incomplete, data truncated, no more to come 11b = Reserved
   *  for future use
   *  Flags:
   *  - 0x0001: Connectable advertising
   *  - 0x0002: Scannable advertising
   *  - 0x0004: Directed advertising
   *  - 0x0008: Scan response
   *  - 0x0010: Legacy advertising PDUs used
   */
  uint16_t Event_Type;
  /** Address Type
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address (corresponds to Resolved Private Address)
   *  - 0x03: Random (static) Identity Address (corresponds to Resolved Private
Address)
   *  - 0xFF: No address provided (anonymous advertisement)
   */
  uint8_t Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the advertising device.
   */
  uint8_t Address[6];
  /** PHY used to send the advertising PDU on the primary advertising physical
   *  channel.
   *  Values:
   *  - 0x01: LE_1M_PHY
   *  - 0x03: LE_CODED_PHY
   */
  uint8_t Primary_PHY;
  /** This parameter indicates the PHY used to send the advertising PDU(s), if any, on
   *  the secondary advertising physical channel.
   *  Values:
   *  - 0x00: No packets
   *  - 0x01: LE_1M_PHY
   *  - 0x02: LE_2M_PHY
   *  - 0x03: LE_CODED_PHY
   */
  uint8_t Secondary_PHY;
  /** Advertising SID subfield in the ADI field of the PDU
   *  Values:
   *  - 0x00 ... 0x0F: Value of the Advertising SID subfield in the ADI field of the PDU
   *  - 0xFF: No ADI field in the PDU
   */
  uint8_t Advertising_SID;
  /** Tx Power. Units: dBm.
   *  Values:
   *  - -127 ... 126
   *  - 127: NA
   */
  int8_t TX_Power;
  /** RSSI value; Units: dBm; All other values Reserved for future use.
   *  Values:
   *  - -127 ... 20
   *  - 127: NA
   */
  int8_t RSSI;
  /** Interval of the periodic advertising. Time = N * 1.25 ms; Time Range: 7.5 ms to
   *  81,918.75 s.
   *  Values:
   *  - 0x0000 (NaN) : No periodic advertising
   *  - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) : Interval of the periodic advertising
   */
  uint16_t Periodic_Advertising_Interval;
  /** Direct address type
   *  Values:
   *  - 0x00: Public Device Address
   *  - 0x01: Random Device Address
   *  - 0x02: Public Identity Address (Corresponds to Resolved Private
Address)
   *  - 0x03: Random (static) Identity Address (Corresponds to Resolved Private
Address)
   *  - 0x04 ... 0xFD: Reserved for future use
   *  - 0xFE: Random Device Address (Controller unable to resolve)
   *  - 0xFF: Reserved for future use
   */
  uint8_t Direct_Address_Type;
  /** Public Device Address, Random Device Address, Public Identity Address or Random
   *  (static) Identity Address of the target device
   */
  uint8_t Direct_Address[6];
  /** Length of the Data[i] field for each device which responded
   *  Values:
   *  - 0 ... 229: Length of the Data[i] field for each device which responded
   *  - 229 ... 255: Reserved for future use
   */
  uint8_t Data_Length;
  /** Data_Length[i] octets of advertising or scan response data formatted as defined
   *  in [Vol 3] Part C, Section 11. Note: Each element of this array has a
   *  variable length.
   */
  uint8_t Data[1];
} packed_Extended_Advertising_Report_t;
/** Documentation for C struct Samples_t */
typedef PACKED(struct) packed_Samples_t_s {
  /** The list of I samples for the reported packet. Each sample is a signed integer.
   *  The list is in the order of the sampling points within the packet.
   */
  int8_t I_Sample;
  /** The list of Q samples for the reported packet. Each sample is a signed integer.
   *  The list is in the order of the sampling points within the packet.
   */
  int8_t Q_Sample;
} packed_Samples_t;
typedef PACKED(struct) hci_disconnect_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Reason;
} hci_disconnect_cp0;

typedef PACKED(struct) hci_disconnect_rp0_s {
  uint8_t Status;
} hci_disconnect_rp0;

typedef PACKED(struct) hci_read_remote_version_information_cp0_s {
  uint16_t Connection_Handle;
} hci_read_remote_version_information_cp0;

typedef PACKED(struct) hci_read_remote_version_information_rp0_s {
  uint8_t Status;
} hci_read_remote_version_information_rp0;

typedef PACKED(struct) hci_set_event_mask_cp0_s {
  uint8_t Event_Mask[8];
} hci_set_event_mask_cp0;

typedef PACKED(struct) hci_set_event_mask_rp0_s {
  uint8_t Status;
} hci_set_event_mask_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_read_transmit_power_level_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Type;
} hci_read_transmit_power_level_cp0;

typedef PACKED(struct) hci_read_transmit_power_level_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  int8_t Transmit_Power_Level;
} hci_read_transmit_power_level_rp0;
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_set_event_mask_page_2_cp0_s {
  uint8_t Event_Mask_Page_2[8];
} hci_set_event_mask_page_2_cp0;

typedef PACKED(struct) hci_set_event_mask_page_2_rp0_s {
  uint8_t Status;
} hci_set_event_mask_page_2_rp0;

typedef PACKED(struct) hci_read_authenticated_payload_timeout_cp0_s {
  uint16_t Connection_Handle;
} hci_read_authenticated_payload_timeout_cp0;

typedef PACKED(struct) hci_read_authenticated_payload_timeout_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint16_t Authenticated_Payload_Timeout;
} hci_read_authenticated_payload_timeout_rp0;

typedef PACKED(struct) hci_write_authenticated_payload_timeout_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Authenticated_Payload_Timeout;
} hci_write_authenticated_payload_timeout_cp0;

typedef PACKED(struct) hci_write_authenticated_payload_timeout_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_write_authenticated_payload_timeout_rp0;

typedef PACKED(struct) hci_read_local_version_information_rp0_s {
  uint8_t Status;
  uint8_t HCI_Version;
  uint16_t HCI_Revision;
  uint8_t LMP_PAL_Version;
  uint16_t Manufacturer_Name;
  uint16_t LMP_PAL_Subversion;
} hci_read_local_version_information_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_read_local_supported_commands_rp0_s {
  uint8_t Status;
  uint8_t Supported_Commands[64];
} hci_read_local_supported_commands_rp0;

typedef PACKED(struct) hci_read_local_supported_features_rp0_s {
  uint8_t Status;
  uint8_t LMP_Features[8];
} hci_read_local_supported_features_rp0;

typedef PACKED(struct) hci_read_bd_addr_rp0_s {
  uint8_t Status;
  uint8_t BD_ADDR[6];
} hci_read_bd_addr_rp0;

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_read_rssi_cp0_s {
  uint16_t Connection_Handle;
} hci_read_rssi_cp0;

typedef PACKED(struct) hci_read_rssi_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  int8_t RSSI;
} hci_read_rssi_rp0;

typedef PACKED(struct) hci_le_set_event_mask_cp0_s {
  uint8_t LE_Event_Mask[8];
} hci_le_set_event_mask_cp0;

typedef PACKED(struct) hci_le_set_event_mask_rp0_s {
  uint8_t Status;
} hci_le_set_event_mask_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_read_buffer_size_rp0_s {
  uint8_t Status;
  uint16_t HC_LE_ACL_Data_Packet_Length;
  uint8_t HC_Total_Num_LE_ACL_Data_Packets;
} hci_le_read_buffer_size_rp0;
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_read_local_supported_features_rp0_s {
  uint8_t Status;
  uint8_t LE_Features[8];
} hci_le_read_local_supported_features_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_set_random_address_cp0_s {
  uint8_t Random_Address[6];
} hci_le_set_random_address_cp0;

typedef PACKED(struct) hci_le_set_random_address_rp0_s {
  uint8_t Status;
} hci_le_set_random_address_rp0;

typedef PACKED(struct) hci_le_set_advertising_parameters_cp0_s {
  uint16_t Advertising_Interval_Min;
  uint16_t Advertising_Interval_Max;
  uint8_t Advertising_Type;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Channel_Map;
  uint8_t Advertising_Filter_Policy;
} hci_le_set_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_advertising_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_read_advertising_channel_tx_power_rp0_s {
  uint8_t Status;
  int8_t Transmit_Power_Level;
} hci_le_read_advertising_channel_tx_power_rp0;

typedef PACKED(struct) hci_le_set_advertising_data_cp0_s {
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[31];
} hci_le_set_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_advertising_data_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_scan_response_data_cp0_s {
  uint8_t Scan_Response_Data_Length;
  uint8_t Scan_Response_Data[31];
} hci_le_set_scan_response_data_cp0;

typedef PACKED(struct) hci_le_set_scan_response_data_rp0_s {
  uint8_t Status;
} hci_le_set_scan_response_data_rp0;

typedef PACKED(struct) hci_le_set_advertising_enable_cp0_s {
  uint8_t Advertising_Enable;
} hci_le_set_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_advertising_enable_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_enable_rp0;

typedef PACKED(struct) hci_le_set_scan_parameters_cp0_s {
  uint8_t LE_Scan_Type;
  uint16_t LE_Scan_Interval;
  uint16_t LE_Scan_Window;
  uint8_t Own_Address_Type;
  uint8_t Scanning_Filter_Policy;
} hci_le_set_scan_parameters_cp0;

typedef PACKED(struct) hci_le_set_scan_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_scan_parameters_rp0;

typedef PACKED(struct) hci_le_set_scan_enable_cp0_s {
  uint8_t LE_Scan_Enable;
  uint8_t Filter_Duplicates;
} hci_le_set_scan_enable_cp0;

typedef PACKED(struct) hci_le_set_scan_enable_rp0_s {
  uint8_t Status;
} hci_le_set_scan_enable_rp0;

typedef PACKED(struct) hci_le_create_connection_cp0_s {
  uint16_t LE_Scan_Interval;
  uint16_t LE_Scan_Window;
  uint8_t Initiator_Filter_Policy;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Own_Address_Type;
  uint16_t Conn_Interval_Min;
  uint16_t Conn_Interval_Max;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Minimum_CE_Length;
  uint16_t Maximum_CE_Length;
} hci_le_create_connection_cp0;

typedef PACKED(struct) hci_le_create_connection_rp0_s {
  uint8_t Status;
} hci_le_create_connection_rp0;

typedef PACKED(struct) hci_le_create_connection_cancel_rp0_s {
  uint8_t Status;
} hci_le_create_connection_cancel_rp0;

typedef PACKED(struct) hci_le_read_white_list_size_rp0_s {
  uint8_t Status;
  uint8_t White_List_Size;
} hci_le_read_white_list_size_rp0;

typedef PACKED(struct) hci_le_clear_white_list_rp0_s {
  uint8_t Status;
} hci_le_clear_white_list_rp0;

typedef PACKED(struct) hci_le_add_device_to_white_list_cp0_s {
  uint8_t Address_Type;
  uint8_t Address[6];
} hci_le_add_device_to_white_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_white_list_rp0_s {
  uint8_t Status;
} hci_le_add_device_to_white_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_white_list_cp0_s {
  uint8_t Address_Type;
  uint8_t Address[6];
} hci_le_remove_device_from_white_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_white_list_rp0_s {
  uint8_t Status;
} hci_le_remove_device_from_white_list_rp0;

typedef PACKED(struct) hci_le_connection_update_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Conn_Interval_Min;
  uint16_t Conn_Interval_Max;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Minimum_CE_Length;
  uint16_t Maximum_CE_Length;
} hci_le_connection_update_cp0;

typedef PACKED(struct) hci_le_connection_update_rp0_s {
  uint8_t Status;
} hci_le_connection_update_rp0;

#endif

typedef PACKED(struct) hci_le_set_host_channel_classification_cp0_s {
  uint8_t LE_Channel_Map[5];
} hci_le_set_host_channel_classification_cp0;

typedef PACKED(struct) hci_le_set_host_channel_classification_rp0_s {
  uint8_t Status;
} hci_le_set_host_channel_classification_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_read_channel_map_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_channel_map_cp0;

typedef PACKED(struct) hci_le_read_channel_map_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t LE_Channel_Map[5];
} hci_le_read_channel_map_rp0;

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_read_remote_used_features_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_remote_used_features_cp0;

typedef PACKED(struct) hci_le_read_remote_used_features_rp0_s {
  uint8_t Status;
} hci_le_read_remote_used_features_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_encrypt_cp0_s {
  uint8_t Key[16];
  uint8_t Plaintext_Data[16];
} hci_le_encrypt_cp0;

typedef PACKED(struct) hci_le_encrypt_rp0_s {
  uint8_t Status;
  uint8_t Encrypted_Data[16];
} hci_le_encrypt_rp0;
#endif
#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_rand_rp0_s {
  uint8_t Status;
  uint8_t Random_Number[8];
} hci_le_rand_rp0;

typedef PACKED(struct) hci_le_start_encryption_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Random_Number[8];
  uint16_t Encrypted_Diversifier;
  uint8_t Long_Term_Key[16];
} hci_le_start_encryption_cp0;

typedef PACKED(struct) hci_le_start_encryption_rp0_s {
  uint8_t Status;
} hci_le_start_encryption_rp0;

typedef PACKED(struct) hci_le_long_term_key_request_reply_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Long_Term_Key[16];
} hci_le_long_term_key_request_reply_cp0;

typedef PACKED(struct) hci_le_long_term_key_request_reply_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_long_term_key_request_reply_rp0;

typedef PACKED(struct) hci_le_long_term_key_requested_negative_reply_cp0_s {
  uint16_t Connection_Handle;
} hci_le_long_term_key_requested_negative_reply_cp0;

typedef PACKED(struct) hci_le_long_term_key_requested_negative_reply_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_long_term_key_requested_negative_reply_rp0;

typedef PACKED(struct) hci_le_read_supported_states_rp0_s {
  uint8_t Status;
  uint8_t LE_States[8];
} hci_le_read_supported_states_rp0;

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_receiver_test_cp0_s {
  uint8_t RX_Frequency;
} hci_le_receiver_test_cp0;

typedef PACKED(struct) hci_le_receiver_test_rp0_s {
  uint8_t Status;
} hci_le_receiver_test_rp0;

typedef PACKED(struct) hci_le_transmitter_test_cp0_s {
  uint8_t TX_Frequency;
  uint8_t Length_Of_Test_Data;
  uint8_t Packet_Payload;
} hci_le_transmitter_test_cp0;

typedef PACKED(struct) hci_le_transmitter_test_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_rp0;

typedef PACKED(struct) hci_le_test_end_rp0_s {
  uint8_t Status;
  uint16_t Number_Of_Packets;
} hci_le_test_end_rp0;

typedef PACKED(struct) hci_le_set_data_length_cp0_s {
  uint16_t Connection_Handle;
  uint16_t TxOctets;
  uint16_t TxTime;
} hci_le_set_data_length_cp0;

typedef PACKED(struct) hci_le_set_data_length_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_data_length_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_read_suggested_default_data_length_rp0_s {
  uint8_t Status;
  uint16_t SuggestedMaxTxOctets;
  uint16_t SuggestedMaxTxTime;
} hci_le_read_suggested_default_data_length_rp0;
#endif 

typedef PACKED(struct) hci_le_write_suggested_default_data_length_cp0_s {
  uint16_t SuggestedMaxTxOctets;
  uint16_t SuggestedMaxTxTime;
} hci_le_write_suggested_default_data_length_cp0;

typedef PACKED(struct) hci_le_write_suggested_default_data_length_rp0_s {
  uint8_t Status;
} hci_le_write_suggested_default_data_length_rp0;

typedef PACKED(struct) hci_le_read_local_p256_public_key_rp0_s {
  uint8_t Status;
} hci_le_read_local_p256_public_key_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_generate_dhkey_cp0_s {
  uint8_t Remote_P256_Public_Key[64];
} hci_le_generate_dhkey_cp0;

typedef PACKED(struct) hci_le_generate_dhkey_rp0_s {
  uint8_t Status;
} hci_le_generate_dhkey_rp0;

typedef PACKED(struct) hci_le_add_device_to_resolving_list_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
  uint8_t Peer_IRK[16];
  uint8_t Local_IRK[16];
} hci_le_add_device_to_resolving_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_resolving_list_rp0_s {
  uint8_t Status;
} hci_le_add_device_to_resolving_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_resolving_list_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} hci_le_remove_device_from_resolving_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_resolving_list_rp0_s {
  uint8_t Status;
} hci_le_remove_device_from_resolving_list_rp0;

typedef PACKED(struct) hci_le_clear_resolving_list_rp0_s {
  uint8_t Status;
} hci_le_clear_resolving_list_rp0;

typedef PACKED(struct) hci_le_read_resolving_list_size_rp0_s {
  uint8_t Status;
  uint8_t Resolving_List_Size;
} hci_le_read_resolving_list_size_rp0;

typedef PACKED(struct) hci_le_read_peer_resolvable_address_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} hci_le_read_peer_resolvable_address_cp0;

typedef PACKED(struct) hci_le_read_peer_resolvable_address_rp0_s {
  uint8_t Status;
  uint8_t Peer_Resolvable_Address[6];
} hci_le_read_peer_resolvable_address_rp0;

typedef PACKED(struct) hci_le_read_local_resolvable_address_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} hci_le_read_local_resolvable_address_cp0;

typedef PACKED(struct) hci_le_read_local_resolvable_address_rp0_s {
  uint8_t Status;
  uint8_t Local_Resolvable_Address[6];
} hci_le_read_local_resolvable_address_rp0;

typedef PACKED(struct) hci_le_set_address_resolution_enable_cp0_s {
  uint8_t Address_Resolution_Enable;
} hci_le_set_address_resolution_enable_cp0;

typedef PACKED(struct) hci_le_set_address_resolution_enable_rp0_s {
  uint8_t Status;
} hci_le_set_address_resolution_enable_rp0;

typedef PACKED(struct) hci_le_set_resolvable_private_address_timeout_cp0_s {
  uint16_t RPA_Timeout;
} hci_le_set_resolvable_private_address_timeout_cp0;

typedef PACKED(struct) hci_le_set_resolvable_private_address_timeout_rp0_s {
  uint8_t Status;
} hci_le_set_resolvable_private_address_timeout_rp0;

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_read_maximum_data_length_rp0_s {
  uint8_t Status;
  uint16_t supportedMaxTxOctets;
  uint16_t supportedMaxTxTime;
  uint16_t supportedMaxRxOctets;
  uint16_t supportedMaxRxTime;
} hci_le_read_maximum_data_length_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_read_phy_cp0_s {
  uint16_t Connection_Handle;
} hci_le_read_phy_cp0;

typedef PACKED(struct) hci_le_read_phy_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t TX_PHY;
  uint8_t RX_PHY;
} hci_le_read_phy_rp0;
#endif

typedef PACKED(struct) hci_le_set_default_phy_cp0_s {
  uint8_t ALL_PHYS;
  uint8_t TX_PHYS;
  uint8_t RX_PHYS;
} hci_le_set_default_phy_cp0;

typedef PACKED(struct) hci_le_set_default_phy_rp0_s {
  uint8_t Status;
} hci_le_set_default_phy_rp0;

typedef PACKED(struct) hci_le_set_phy_cp0_s {
  uint16_t Connection_Handle;
  uint8_t ALL_PHYS;
  uint8_t TX_PHYS;
  uint8_t RX_PHYS;
  uint16_t PHY_options;
} hci_le_set_phy_cp0;

typedef PACKED(struct) hci_le_set_phy_rp0_s {
  uint8_t Status;
} hci_le_set_phy_rp0;

typedef PACKED(struct) hci_le_enhanced_receiver_test_cp0_s {
  uint8_t RX_Channel;
  uint8_t PHY;
  uint8_t Modulation_index;
} hci_le_enhanced_receiver_test_cp0;

typedef PACKED(struct) hci_le_enhanced_receiver_test_rp0_s {
  uint8_t Status;
} hci_le_enhanced_receiver_test_rp0;

typedef PACKED(struct) hci_le_enhanced_transmitter_test_cp0_s {
  uint8_t TX_Channel;
  uint8_t Length_Of_Test_Data;
  uint8_t Packet_Payload;
  uint8_t PHY;
} hci_le_enhanced_transmitter_test_cp0;

typedef PACKED(struct) hci_le_enhanced_transmitter_test_rp0_s {
  uint8_t Status;
} hci_le_enhanced_transmitter_test_rp0;

typedef PACKED(struct) hci_le_set_advertising_set_random_address_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Advertising_Random_Address[6];
} hci_le_set_advertising_set_random_address_cp0;

typedef PACKED(struct) hci_le_set_advertising_set_random_address_rp0_s {
  uint8_t Status;
} hci_le_set_advertising_set_random_address_rp0;


#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Advertising_Event_Properties;
  uint8_t Primary_Advertising_Interval_Min[3];
  uint8_t Primary_Advertising_Interval_Max[3];
  uint8_t Primary_Advertising_Channel_Map;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Filter_Policy;
  int8_t Advertising_Tx_Power;
  uint8_t Primary_Advertising_PHY;
  uint8_t Secondary_Advertising_Max_Skip;
  uint8_t Secondary_Advertising_PHY;
  uint8_t Advertising_SID;
  uint8_t Scan_Request_Notification_Enable;
} hci_le_set_extended_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_parameters_rp0_s {
  uint8_t Status;
  int8_t Selected_Tx_Power;
} hci_le_set_extended_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Fragment_Preference;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_extended_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_data_rp0_s {
  uint8_t Status;
} hci_le_set_extended_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_response_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Fragment_Preference;
  uint8_t Scan_Response_Data_Length;
  uint8_t Scan_Response_Data[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_extended_scan_response_data_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_response_data_rp0_s {
  uint8_t Status;
} hci_le_set_extended_scan_response_data_rp0;

typedef PACKED(struct) hci_le_set_extended_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Number_of_Sets;
  packed_Advertising_Set_Parameters_t Advertising_Set_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Advertising_Set_Parameters_t)];
} hci_le_set_extended_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_extended_advertising_enable_rp0_s {
  uint8_t Status;
} hci_le_set_extended_advertising_enable_rp0;

typedef PACKED(struct) hci_le_read_maximum_advertising_data_length_rp0_s {
  uint8_t Status;
  uint16_t Maximum_Advertising_Data_Length;
} hci_le_read_maximum_advertising_data_length_rp0;

typedef PACKED(struct) hci_le_read_number_of_supported_advertising_sets_rp0_s {
  uint8_t Status;
  uint8_t Num_Supported_Advertising_Sets;
} hci_le_read_number_of_supported_advertising_sets_rp0;

typedef PACKED(struct) hci_le_remove_advertising_set_cp0_s {
  uint8_t Advertising_Handle;
} hci_le_remove_advertising_set_cp0;

typedef PACKED(struct) hci_le_remove_advertising_set_rp0_s {
  uint8_t Status;
} hci_le_remove_advertising_set_rp0;

typedef PACKED(struct) hci_le_clear_advertising_sets_rp0_s {
  uint8_t Status;
} hci_le_clear_advertising_sets_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Periodic_Advertising_Interval_Min;
  uint16_t Periodic_Advertising_Interval_Max;
  uint16_t Periodic_Advertising_Properties;
} hci_le_set_periodic_advertising_parameters_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_parameters_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_data_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} hci_le_set_periodic_advertising_data_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_data_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_data_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Advertising_Handle;
} hci_le_set_periodic_advertising_enable_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_enable_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_enable_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_parameters_cp0_s {
  uint8_t Own_Address_Type;
  uint8_t Scanning_Filter_Policy;
  uint8_t Scanning_PHYs;
  packed_Extended_Scan_Parameters_t Extended_Scan_Parameters[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_Extended_Scan_Parameters_t)];
} hci_le_set_extended_scan_parameters_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_extended_scan_parameters_rp0;

typedef PACKED(struct) hci_le_set_extended_scan_enable_cp0_s {
  uint8_t Enable;
  uint8_t Filter_Duplicates;
  uint16_t Duration;
  uint16_t Period;
} hci_le_set_extended_scan_enable_cp0;

typedef PACKED(struct) hci_le_set_extended_scan_enable_rp0_s {
  uint8_t Status;
} hci_le_set_extended_scan_enable_rp0;

typedef PACKED(struct) hci_le_extended_create_connection_cp0_s {
  uint8_t Initiating_Filter_Policy;
  uint8_t Own_Address_Type;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Initiating_PHYs;
  packed_Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(packed_Extended_Create_Connection_Parameters_t)];
} hci_le_extended_create_connection_cp0;

typedef PACKED(struct) hci_le_extended_create_connection_rp0_s {
  uint8_t Status;
} hci_le_extended_create_connection_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_cp0_s {
  uint8_t Options;
  uint8_t Advertising_SID;
  uint8_t Advertising_Address_Type;
  uint8_t Advertiser_Address[6];
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t Sync_CTE_Type;
} hci_le_periodic_advertising_create_sync_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_rp0_s {
  uint8_t Status;
} hci_le_periodic_advertising_create_sync_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_create_sync_cancel_rp0_s {
  uint8_t Status;
} hci_le_periodic_advertising_create_sync_cancel_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_terminate_sync_cp0_s {
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_terminate_sync_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_terminate_sync_rp0_s {
  uint8_t Status;
} hci_le_periodic_advertising_terminate_sync_rp0;

typedef PACKED(struct) hci_le_add_device_to_periodic_advertiser_list_cp0_s {
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertising_SID;
} hci_le_add_device_to_periodic_advertiser_list_cp0;

typedef PACKED(struct) hci_le_add_device_to_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} hci_le_add_device_to_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_remove_device_from_periodic_advertising_list_cp0_s {
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertising_SID;
} hci_le_remove_device_from_periodic_advertising_list_cp0;

typedef PACKED(struct) hci_le_remove_device_from_periodic_advertising_list_rp0_s {
  uint8_t Status;
} hci_le_remove_device_from_periodic_advertising_list_rp0;

typedef PACKED(struct) hci_le_clear_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} hci_le_clear_periodic_advertiser_list_rp0;

typedef PACKED(struct) hci_le_read_periodic_advertiser_list_size_rp0_s {
  uint8_t Status;
  uint8_t Periodic_Advertiser_List_Size;
} hci_le_read_periodic_advertiser_list_size_rp0;

typedef PACKED(struct) hci_le_read_transmit_power_rp0_s {
  uint8_t Status;
  int8_t Min_Tx_Power;
  int8_t Max_Tx_Power;
} hci_le_read_transmit_power_rp0;

typedef PACKED(struct) hci_le_read_rf_path_compensation_rp0_s {
  uint8_t Status;
  int16_t RF_TX_Path_Compensation_Value;
  int16_t RF_RX_Path_Compensation_Value;
} hci_le_read_rf_path_compensation_rp0;
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_write_rf_path_compensation_cp0_s {
  int16_t RF_TX_Path_Compensation_Value;
  int16_t RF_RX_Path_Compensation_Value;
} hci_le_write_rf_path_compensation_cp0;

typedef PACKED(struct) hci_le_write_rf_path_compensation_rp0_s {
  uint8_t Status;
} hci_le_write_rf_path_compensation_rp0;

typedef PACKED(struct) hci_le_set_privacy_mode_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
  uint8_t Privacy_Mode;
} hci_le_set_privacy_mode_cp0;

typedef PACKED(struct) hci_le_set_privacy_mode_rp0_s {
  uint8_t Status;
} hci_le_set_privacy_mode_rp0;

typedef PACKED(struct) hci_le_receiver_test_v3_cp0_s {
  uint8_t RX_Channel;
  uint8_t PHY;
  uint8_t Modulation_Index;
  uint8_t Expected_CTE_Length;
  uint8_t Expected_CTE_Type;
  uint8_t Slot_Durations;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_receiver_test_v3_cp0;

typedef PACKED(struct) hci_le_receiver_test_v3_rp0_s {
  uint8_t Status;
} hci_le_receiver_test_v3_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v3_cp0_s {
  uint8_t TX_Channel;
  uint8_t Test_Data_Length;
  uint8_t Packet_Payload;
  uint8_t PHY;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_transmitter_test_v3_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v3_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_v3_rp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_parameters_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t CTE_Count;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_connectionless_cte_transmit_parameters_cp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_connectionless_cte_transmit_parameters_rp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_enable_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t CTE_Enable;
} hci_le_set_connectionless_cte_transmit_enable_cp0;

typedef PACKED(struct) hci_le_set_connectionless_cte_transmit_enable_rp0_s {
  uint8_t Status;
} hci_le_set_connectionless_cte_transmit_enable_rp0;

typedef PACKED(struct) hci_le_set_connectionless_iq_sampling_enable_cp0_s {
  uint16_t Sync_Handle;
  uint8_t Sampling_Enable;
  uint8_t Slot_Durations;
  uint8_t Max_Sampled_CTEs;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} hci_le_set_connectionless_iq_sampling_enable_cp0;

typedef PACKED(struct) hci_le_set_connectionless_iq_sampling_enable_rp0_s {
  uint8_t Status;
  uint16_t Sync_Handle;
} hci_le_set_connectionless_iq_sampling_enable_rp0;

typedef PACKED(struct) hci_le_set_connection_cte_receive_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Sampling_Enable;
  uint8_t Slot_Durations;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} hci_le_set_connection_cte_receive_parameters_cp0;

typedef PACKED(struct) hci_le_set_connection_cte_receive_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_connection_cte_receive_parameters_rp0;

typedef PACKED(struct) hci_le_set_connection_cte_transmit_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} hci_le_set_connection_cte_transmit_parameters_cp0;

typedef PACKED(struct) hci_le_set_connection_cte_transmit_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_connection_cte_transmit_parameters_rp0;

typedef PACKED(struct) hci_le_connection_cte_request_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
  uint16_t CTE_Request_Interval;
  uint8_t Requested_CTE_Length;
  uint8_t Requested_CTE_Type;
} hci_le_connection_cte_request_enable_cp0;

typedef PACKED(struct) hci_le_connection_cte_request_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_connection_cte_request_enable_rp0;

typedef PACKED(struct) hci_le_connection_cte_response_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
} hci_le_connection_cte_response_enable_cp0;

typedef PACKED(struct) hci_le_connection_cte_response_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_connection_cte_response_enable_rp0;

typedef PACKED(struct) hci_le_read_antenna_information_rp0_s {
  uint8_t Status;
  uint8_t Supported_Switching_Sampling_Rates;
  uint8_t Num_Antennae;
  uint8_t Max_Switching_Pattern_Length;
  uint8_t Max_CTE_Length;
} hci_le_read_antenna_information_rp0;

#ifndef CONFIG_NO_HCI_COMMANDS

typedef PACKED(struct) hci_le_set_periodic_advertising_receive_enable_cp0_s {
  uint16_t Sync_Handle;
  uint8_t Enable;
} hci_le_set_periodic_advertising_receive_enable_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_receive_enable_rp0_s {
  uint8_t Status;
} hci_le_set_periodic_advertising_receive_enable_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Data;
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_sync_transfer_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_periodic_advertising_sync_transfer_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_set_info_transfer_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Data;
  uint8_t Advertising_Handle;
} hci_le_periodic_advertising_set_info_transfer_cp0;

typedef PACKED(struct) hci_le_periodic_advertising_set_info_transfer_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_periodic_advertising_set_info_transfer_rp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_sync_transfer_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Mode;
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t CTE_Type;
} hci_le_set_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) hci_le_set_periodic_advertising_sync_transfer_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0_s {
  uint8_t Mode;
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t CTE_Type;
} hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) hci_le_set_default_periodic_advertising_sync_transfer_parameters_rp0_s {
  uint8_t Status;
} hci_le_set_default_periodic_advertising_sync_transfer_parameters_rp0;

#endif //#ifndef CONFIG_NO_HCI_COMMANDS
typedef PACKED(struct) hci_le_enhanced_read_transmit_power_level_cp0_s {
  uint16_t Connection_Handle;
  uint8_t PHY;
} hci_le_enhanced_read_transmit_power_level_cp0;

typedef PACKED(struct) hci_le_enhanced_read_transmit_power_level_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t PHY;
  int8_t Current_Transmit_Power_Level;
  int8_t Max_Transmit_Power_Level;
} hci_le_enhanced_read_transmit_power_level_rp0;

typedef PACKED(struct) hci_le_read_remote_transmit_power_level_cp0_s {
  uint16_t Connection_Handle;
  uint8_t PHY;
} hci_le_read_remote_transmit_power_level_cp0;

typedef PACKED(struct) hci_le_read_remote_transmit_power_level_rp0_s {
  uint8_t Status;
} hci_le_read_remote_transmit_power_level_rp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t High_Threshold;
  uint8_t High_Hysteresis;
  uint8_t Low_Threshold;
  uint8_t Low_Hysteresis;
  uint16_t Min_Time_Spent;
} hci_le_set_path_loss_reporting_parameters_cp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_path_loss_reporting_parameters_rp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Enable;
} hci_le_set_path_loss_reporting_enable_cp0;

typedef PACKED(struct) hci_le_set_path_loss_reporting_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_path_loss_reporting_enable_rp0;

typedef PACKED(struct) hci_le_set_transmit_power_reporting_enable_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Local_Enable;
  uint8_t Remote_Enable;
} hci_le_set_transmit_power_reporting_enable_cp0;

typedef PACKED(struct) hci_le_set_transmit_power_reporting_enable_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_set_transmit_power_reporting_enable_rp0;

typedef PACKED(struct) hci_le_transmitter_test_v4_cp0_s {
  uint8_t TX_Channel;
  uint8_t Test_Data_Length;
  uint8_t Packet_Payload;
  uint8_t PHY;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_transmitter_test_v4_cp0;

typedef PACKED(struct) hci_le_transmitter_test_v4_cp1_s {
  int8_t Transmit_Power_Level;
} hci_le_transmitter_test_v4_cp1;

typedef PACKED(struct) hci_le_transmitter_test_v4_rp0_s {
  uint8_t Status;
} hci_le_transmitter_test_v4_rp0;

typedef PACKED(struct) aci_hal_get_fw_build_number_rp0_s {
  uint8_t Status;
  uint16_t Build_Number;
} aci_hal_get_fw_build_number_rp0;

typedef PACKED(struct) aci_hal_get_firmware_details_rp0_s {
  uint8_t Status;
  uint8_t DTM_version_major;
  uint8_t DTM_version_minor;
  uint8_t DTM_version_patch;
  uint8_t DTM_variant;
  uint16_t DTM_Build_Number;
  uint8_t BTLE_Stack_version_major;
  uint8_t BTLE_Stack_version_minor;
  uint8_t BTLE_Stack_version_patch;
  uint8_t BTLE_Stack_development;
  uint16_t BTLE_Stack_variant;
  uint16_t BTLE_Stack_Build_Number;
} aci_hal_get_firmware_details_rp0;

typedef PACKED(struct) aci_hal_write_config_data_cp0_s {
  uint8_t Offset;
  uint8_t Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_write_config_data_cp0;

typedef PACKED(struct) aci_hal_write_config_data_rp0_s {
  uint8_t Status;
} aci_hal_write_config_data_rp0;

typedef PACKED(struct) aci_hal_read_config_data_cp0_s {
  uint8_t Offset;
} aci_hal_read_config_data_cp0;

typedef PACKED(struct) aci_hal_read_config_data_rp0_s {
  uint8_t Status;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_read_config_data_rp0;

typedef PACKED(struct) aci_hal_set_tx_power_level_cp0_s {
  uint8_t En_High_Power;
  uint8_t PA_Level;
} aci_hal_set_tx_power_level_cp0;

typedef PACKED(struct) aci_hal_set_tx_power_level_rp0_s {
  uint8_t Status;
} aci_hal_set_tx_power_level_rp0;

typedef PACKED(struct) aci_hal_le_tx_test_packet_number_rp0_s {
  uint8_t Status;
  uint32_t Number_Of_Packets;
} aci_hal_le_tx_test_packet_number_rp0;

typedef PACKED(struct) aci_hal_tone_start_cp0_s {
  uint8_t RF_Channel;
  uint8_t Offset;
} aci_hal_tone_start_cp0;

typedef PACKED(struct) aci_hal_tone_start_rp0_s {
  uint8_t Status;
} aci_hal_tone_start_rp0;

typedef PACKED(struct) aci_hal_tone_stop_rp0_s {
  uint8_t Status;
} aci_hal_tone_stop_rp0;

typedef PACKED(struct) aci_hal_get_link_status_cp0_s {
  uint8_t Bank_index;
} aci_hal_get_link_status_cp0;

typedef PACKED(struct) aci_hal_get_link_status_rp0_s {
  uint8_t Status;
  uint8_t Link_Status[8];
  uint16_t Link_Connection_Handle[16 / 2];
} aci_hal_get_link_status_rp0;

typedef PACKED(struct) aci_hal_set_radio_activity_mask_cp0_s {
  uint16_t Radio_Activity_Mask;
} aci_hal_set_radio_activity_mask_cp0;

typedef PACKED(struct) aci_hal_set_radio_activity_mask_rp0_s {
  uint8_t Status;
} aci_hal_set_radio_activity_mask_rp0;

typedef PACKED(struct) aci_hal_set_event_mask_cp0_s {
  uint32_t Event_Mask;
} aci_hal_set_event_mask_cp0;

typedef PACKED(struct) aci_hal_set_event_mask_rp0_s {
  uint8_t Status;
} aci_hal_set_event_mask_rp0;

typedef PACKED(struct) aci_hal_set_le_power_control_cp0_s {
  uint8_t Enable;
  uint8_t PHY;
  int8_t RSSI_Target;
  uint8_t RSSI_Hysteresis;
  int8_t Initial_TX_Power;
  uint8_t RSSI_Filtering_Coefficient;
} aci_hal_set_le_power_control_cp0;

typedef PACKED(struct) aci_hal_set_le_power_control_rp0_s {
  uint8_t Status;
} aci_hal_set_le_power_control_rp0;

typedef PACKED(struct) aci_hal_updater_start_rp0_s {
  uint8_t Status;
} aci_hal_updater_start_rp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_cp0_s {
  uint8_t TX_Frequency;
  uint8_t Length_Of_Test_Data;
  uint8_t Packet_Payload;
  uint16_t Number_Of_Packets;
  uint8_t PHY;
} aci_hal_transmitter_test_packets_cp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_rp0_s {
  uint8_t Status;
} aci_hal_transmitter_test_packets_rp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_v2_cp0_s {
  uint8_t TX_Channel;
  uint8_t Test_Data_Length;
  uint8_t Packet_Payload;
  uint16_t Number_Of_Packets;
  uint8_t PHY;
  uint8_t CTE_Length;
  uint8_t CTE_Type;
  uint8_t Switching_Pattern_Length;
  uint8_t Antenna_IDs[(HCI_MAX_PAYLOAD_SIZE - 9)/sizeof(uint8_t)];
} aci_hal_transmitter_test_packets_v2_cp0;

typedef PACKED(struct) aci_hal_transmitter_test_packets_v2_rp0_s {
  uint8_t Status;
} aci_hal_transmitter_test_packets_v2_rp0;

typedef PACKED(struct) aci_hal_write_radio_reg_cp0_s {
  uint32_t Start_Address;
  uint8_t Num_Bytes;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_hal_write_radio_reg_cp0;

typedef PACKED(struct) aci_hal_write_radio_reg_rp0_s {
  uint8_t Status;
} aci_hal_write_radio_reg_rp0;

typedef PACKED(struct) aci_hal_read_radio_reg_cp0_s {
  uint32_t Start_Address;
  uint8_t Num_Bytes;
} aci_hal_read_radio_reg_cp0;

typedef PACKED(struct) aci_hal_read_radio_reg_rp0_s {
  uint8_t Status;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_read_radio_reg_rp0;

typedef PACKED(struct) aci_hal_set_antenna_switch_parameters_cp0_s {
  uint8_t Antenna_IDs;
  uint8_t Antenna_ID_Shift;
  uint8_t Default_Antenna_ID;
  uint8_t RF_Activity_Enable;
} aci_hal_set_antenna_switch_parameters_cp0;

typedef PACKED(struct) aci_hal_set_antenna_switch_parameters_rp0_s {
  uint8_t Status;
} aci_hal_set_antenna_switch_parameters_rp0;

typedef PACKED(struct) aci_hal_get_evt_fifo_max_level_rp0_s {
  uint8_t Status;
  uint16_t ISR0_FIFO_Max_Level;
  uint16_t ISR1_FIFO_Max_Level;
  uint16_t User_FIFO_Max_Level;
} aci_hal_get_evt_fifo_max_level_rp0;

typedef PACKED(struct) aci_gap_set_io_capability_cp0_s {
  uint8_t IO_Capability;
} aci_gap_set_io_capability_cp0;

typedef PACKED(struct) aci_gap_set_io_capability_rp0_s {
  uint8_t Status;
} aci_gap_set_io_capability_rp0;

typedef PACKED(struct) aci_gap_set_authentication_requirement_cp0_s {
  uint8_t Bonding_Mode;
  uint8_t MITM_Mode;
  uint8_t SC_Support;
  uint8_t KeyPress_Notification_Support;
  uint8_t Min_Encryption_Key_Size;
  uint8_t Max_Encryption_Key_Size;
  uint8_t Use_Fixed_Pin;
  uint32_t Fixed_Pin;
} aci_gap_set_authentication_requirement_cp0;

typedef PACKED(struct) aci_gap_set_authentication_requirement_rp0_s {
  uint8_t Status;
} aci_gap_set_authentication_requirement_rp0;

typedef PACKED(struct) aci_gap_pass_key_resp_cp0_s {
  uint16_t Connection_Handle;
  uint32_t Pass_Key;
} aci_gap_pass_key_resp_cp0;

typedef PACKED(struct) aci_gap_pass_key_resp_rp0_s {
  uint8_t Status;
} aci_gap_pass_key_resp_rp0;

typedef PACKED(struct) aci_gap_init_cp0_s {
  uint8_t Role;
  uint8_t Privacy_Type;
  uint8_t Device_Name_Char_Len;
  uint8_t Identity_Address_Type;
} aci_gap_init_cp0;

typedef PACKED(struct) aci_gap_init_rp0_s {
  uint8_t Status;
  uint16_t Service_Handle;
  uint16_t Dev_Name_Char_Handle;
  uint16_t Appearance_Char_Handle;
} aci_gap_init_rp0;

typedef PACKED(struct) aci_gap_slave_security_req_cp0_s {
  uint16_t Connection_Handle;
} aci_gap_slave_security_req_cp0;

typedef PACKED(struct) aci_gap_slave_security_req_rp0_s {
  uint8_t Status;
} aci_gap_slave_security_req_rp0;

typedef PACKED(struct) aci_gap_get_security_level_cp0_s {
  uint16_t Connection_Handle;
} aci_gap_get_security_level_cp0;

typedef PACKED(struct) aci_gap_get_security_level_rp0_s {
  uint8_t Status;
  uint8_t Security_Mode;
  uint8_t Security_Level;
} aci_gap_get_security_level_rp0;

typedef PACKED(struct) aci_gap_set_event_mask_cp0_s {
  uint16_t GAP_Evt_Mask;
} aci_gap_set_event_mask_cp0;

typedef PACKED(struct) aci_gap_set_event_mask_rp0_s {
  uint8_t Status;
} aci_gap_set_event_mask_rp0;

typedef PACKED(struct) aci_gap_terminate_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Reason;
} aci_gap_terminate_cp0;

typedef PACKED(struct) aci_gap_terminate_rp0_s {
  uint8_t Status;
} aci_gap_terminate_rp0;

typedef PACKED(struct) aci_gap_clear_security_db_rp0_s {
  uint8_t Status;
} aci_gap_clear_security_db_rp0;

typedef PACKED(struct) aci_gap_allow_rebond_cp0_s {
  uint16_t Connection_Handle;
} aci_gap_allow_rebond_cp0;

typedef PACKED(struct) aci_gap_allow_rebond_rp0_s {
  uint8_t Status;
} aci_gap_allow_rebond_rp0;

typedef PACKED(struct) aci_gap_create_connection_cp0_s {
  uint8_t Initiating_PHY;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_gap_create_connection_cp0;

typedef PACKED(struct) aci_gap_create_connection_rp0_s {
  uint8_t Status;
} aci_gap_create_connection_rp0;

typedef PACKED(struct) aci_gap_terminate_proc_cp0_s {
  uint8_t Procedure_Code;
} aci_gap_terminate_proc_cp0;

typedef PACKED(struct) aci_gap_terminate_proc_rp0_s {
  uint8_t Status;
} aci_gap_terminate_proc_rp0;

typedef PACKED(struct) aci_gap_start_connection_update_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Conn_Interval_Min;
  uint16_t Conn_Interval_Max;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Minimum_CE_Length;
  uint16_t Maximum_CE_Length;
} aci_gap_start_connection_update_cp0;

typedef PACKED(struct) aci_gap_start_connection_update_rp0_s {
  uint8_t Status;
} aci_gap_start_connection_update_rp0;

typedef PACKED(struct) aci_gap_send_pairing_req_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Force_Rebond;
} aci_gap_send_pairing_req_cp0;

typedef PACKED(struct) aci_gap_send_pairing_req_rp0_s {
  uint8_t Status;
} aci_gap_send_pairing_req_rp0;

typedef PACKED(struct) aci_gap_resolve_private_addr_cp0_s {
  uint8_t Address[6];
} aci_gap_resolve_private_addr_cp0;

typedef PACKED(struct) aci_gap_resolve_private_addr_rp0_s {
  uint8_t Status;
  uint8_t Actual_Address[6];
} aci_gap_resolve_private_addr_rp0;

typedef PACKED(struct) aci_gap_get_bonded_devices_cp0_s {
  uint8_t Offset;
  uint8_t Max_Num_Of_Addresses;
} aci_gap_get_bonded_devices_cp0;

typedef PACKED(struct) aci_gap_get_bonded_devices_rp0_s {
  uint8_t Status;
  uint8_t Num_of_Addresses;
  packed_Bonded_Device_Entry_t Bonded_Device_Entry[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Bonded_Device_Entry_t)];
} aci_gap_get_bonded_devices_rp0;

typedef PACKED(struct) aci_gap_is_device_bonded_cp0_s {
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_gap_is_device_bonded_cp0;

typedef PACKED(struct) aci_gap_is_device_bonded_rp0_s {
  uint8_t Status;
} aci_gap_is_device_bonded_rp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_confirm_yesno_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Confirm_Yes_No;
} aci_gap_numeric_comparison_value_confirm_yesno_cp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_confirm_yesno_rp0_s {
  uint8_t Status;
} aci_gap_numeric_comparison_value_confirm_yesno_rp0;

typedef PACKED(struct) aci_gap_passkey_input_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Input_Type;
} aci_gap_passkey_input_cp0;

typedef PACKED(struct) aci_gap_passkey_input_rp0_s {
  uint8_t Status;
} aci_gap_passkey_input_rp0;

typedef PACKED(struct) aci_gap_get_oob_data_cp0_s {
  uint8_t OOB_Data_Type;
} aci_gap_get_oob_data_cp0;

typedef PACKED(struct) aci_gap_get_oob_data_rp0_s {
  uint8_t Status;
  uint8_t Address_Type;
  uint8_t Address[6];
  uint8_t OOB_Data_Type;
  uint8_t OOB_Data_Len;
  uint8_t OOB_Data[16];
} aci_gap_get_oob_data_rp0;

typedef PACKED(struct) aci_gap_set_oob_data_cp0_s {
  uint8_t Device_Type;
  uint8_t Address_Type;
  uint8_t Address[6];
  uint8_t OOB_Data_Type;
  uint8_t OOB_Data_Len;
  uint8_t OOB_Data[16];
} aci_gap_set_oob_data_cp0;

typedef PACKED(struct) aci_gap_set_oob_data_rp0_s {
  uint8_t Status;
} aci_gap_set_oob_data_rp0;

typedef PACKED(struct) aci_gap_remove_bonded_device_cp0_s {
  uint8_t Peer_Identity_Address_Type;
  uint8_t Peer_Identity_Address[6];
} aci_gap_remove_bonded_device_cp0;

typedef PACKED(struct) aci_gap_remove_bonded_device_rp0_s {
  uint8_t Status;
} aci_gap_remove_bonded_device_rp0;

typedef PACKED(struct) aci_gap_set_advertising_configuration_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Discoverable_Mode;
  uint16_t Advertising_Event_Properties;
  uint32_t Primary_Advertising_Interval_Min;
  uint32_t Primary_Advertising_Interval_Max;
  uint8_t Primary_Advertising_Channel_Map;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Advertising_Filter_Policy;
  int8_t Advertising_Tx_Power;
  uint8_t Primary_Advertising_PHY;
  uint8_t Secondary_Advertising_Max_Skip;
  uint8_t Secondary_Advertising_PHY;
  uint8_t Advertising_SID;
  uint8_t Scan_Request_Notification_Enable;
} aci_gap_set_advertising_configuration_cp0;

typedef PACKED(struct) aci_gap_set_advertising_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_advertising_configuration_rp0;

typedef PACKED(struct) aci_gap_set_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Number_of_Sets;
  packed_Advertising_Set_Parameters_t Advertising_Set_Parameters[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(packed_Advertising_Set_Parameters_t)];
} aci_gap_set_advertising_enable_cp0;

typedef PACKED(struct) aci_gap_set_advertising_enable_rp0_s {
  uint8_t Status;
} aci_gap_set_advertising_enable_rp0;

typedef PACKED(struct) aci_gap_set_advertising_data_nwk_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_advertising_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_advertising_data_nwk_rp0_s {
  uint8_t Status;
} aci_gap_set_advertising_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_scan_response_data_nwk_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Scan_Response_Data_Length;
  uint8_t Scan_Response_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_scan_response_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_scan_response_data_nwk_rp0_s {
  uint8_t Status;
} aci_gap_set_scan_response_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_scan_configuration_cp0_s {
  uint8_t Filter_Duplicates;
  uint8_t Scanning_Filter_Policy;
  uint8_t Scanning_PHY;
  uint8_t Scan_Type;
  uint16_t Scan_Interval;
  uint16_t Scan_Window;
} aci_gap_set_scan_configuration_cp0;

typedef PACKED(struct) aci_gap_set_scan_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_scan_configuration_rp0;

typedef PACKED(struct) aci_gap_set_connection_configuration_cp0_s {
  uint8_t Initiating_PHY;
  uint16_t Conn_Interval_Min;
  uint16_t Conn_Interval_Max;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
  uint16_t Minimum_CE_Length;
  uint16_t Maximum_CE_Length;
} aci_gap_set_connection_configuration_cp0;

typedef PACKED(struct) aci_gap_set_connection_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_connection_configuration_rp0;

typedef PACKED(struct) aci_gap_start_procedure_cp0_s {
  uint8_t Procedure_Code;
  uint8_t PHYs;
  uint16_t Duration;
  uint16_t Period;
} aci_gap_start_procedure_cp0;

typedef PACKED(struct) aci_gap_start_procedure_rp0_s {
  uint8_t Status;
} aci_gap_start_procedure_rp0;

typedef PACKED(struct) aci_gap_discover_name_cp0_s {
  uint8_t PHYs;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_gap_discover_name_cp0;

typedef PACKED(struct) aci_gap_discover_name_rp0_s {
  uint8_t Status;
} aci_gap_discover_name_rp0;

typedef PACKED(struct) aci_gap_add_devices_to_white_and_resolving_list_cp0_s {
  uint8_t Lists;
  uint8_t Clear_Lists;
  uint8_t Num_of_List_Entries;
  packed_List_Entry_t List_Entry[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_List_Entry_t)];
} aci_gap_add_devices_to_white_and_resolving_list_cp0;

typedef PACKED(struct) aci_gap_add_devices_to_white_and_resolving_list_rp0_s {
  uint8_t Status;
} aci_gap_add_devices_to_white_and_resolving_list_rp0;

typedef PACKED(struct) aci_gap_configure_white_and_resolving_list_cp0_s {
  uint8_t Lists;
} aci_gap_configure_white_and_resolving_list_cp0;

typedef PACKED(struct) aci_gap_configure_white_and_resolving_list_rp0_s {
  uint8_t Status;
} aci_gap_configure_white_and_resolving_list_rp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_configuration_cp0_s {
  uint8_t Advertising_Handle;
  uint16_t Periodic_Advertising_Interval_Min;
  uint16_t Periodic_Advertising_Interval_Max;
  uint16_t Periodic_Advertising_Properties;
} aci_gap_set_periodic_advertising_configuration_cp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_configuration_rp0_s {
  uint8_t Status;
} aci_gap_set_periodic_advertising_configuration_rp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_data_nwk_cp0_s {
  uint8_t Advertising_Handle;
  uint8_t Operation;
  uint8_t Advertising_Data_Length;
  uint8_t Advertising_Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_set_periodic_advertising_data_nwk_cp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_data_nwk_rp0_s {
  uint8_t Status;
} aci_gap_set_periodic_advertising_data_nwk_rp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_enable_cp0_s {
  uint8_t Enable;
  uint8_t Advertising_Handle;
} aci_gap_set_periodic_advertising_enable_cp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_enable_rp0_s {
  uint8_t Status;
} aci_gap_set_periodic_advertising_enable_rp0;

typedef PACKED(struct) aci_gap_periodic_advertising_create_sync_cp0_s {
  uint8_t Options;
  uint8_t Advertising_SID;
  uint8_t Advertising_Address_Type;
  uint8_t Advertiser_Address[6];
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t Sync_CTE_Type;
} aci_gap_periodic_advertising_create_sync_cp0;

typedef PACKED(struct) aci_gap_periodic_advertising_create_sync_rp0_s {
  uint8_t Status;
} aci_gap_periodic_advertising_create_sync_rp0;

typedef PACKED(struct) aci_gap_periodic_advertising_create_sync_cancel_rp0_s {
  uint8_t Status;
} aci_gap_periodic_advertising_create_sync_cancel_rp0;

typedef PACKED(struct) aci_gap_remove_advertising_set_cp0_s {
  uint8_t Advertising_Handle;
} aci_gap_remove_advertising_set_cp0;

typedef PACKED(struct) aci_gap_remove_advertising_set_rp0_s {
  uint8_t Status;
} aci_gap_remove_advertising_set_rp0;

typedef PACKED(struct) aci_gap_clear_advertising_sets_rp0_s {
  uint8_t Status;
} aci_gap_clear_advertising_sets_rp0;

typedef PACKED(struct) aci_gap_periodic_advertising_terminate_sync_cp0_s {
  uint16_t Sync_Handle;
} aci_gap_periodic_advertising_terminate_sync_cp0;

typedef PACKED(struct) aci_gap_periodic_advertising_terminate_sync_rp0_s {
  uint8_t Status;
} aci_gap_periodic_advertising_terminate_sync_rp0;

typedef PACKED(struct) aci_gap_add_device_to_periodic_advertiser_list_cp0_s {
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertising_SID;
} aci_gap_add_device_to_periodic_advertiser_list_cp0;

typedef PACKED(struct) aci_gap_add_device_to_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} aci_gap_add_device_to_periodic_advertiser_list_rp0;

typedef PACKED(struct) aci_gap_remove_device_from_periodic_advertising_list_cp0_s {
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertising_SID;
} aci_gap_remove_device_from_periodic_advertising_list_cp0;

typedef PACKED(struct) aci_gap_remove_device_from_periodic_advertising_list_rp0_s {
  uint8_t Status;
} aci_gap_remove_device_from_periodic_advertising_list_rp0;

typedef PACKED(struct) aci_gap_clear_periodic_advertiser_list_rp0_s {
  uint8_t Status;
} aci_gap_clear_periodic_advertiser_list_rp0;

typedef PACKED(struct) aci_gap_read_periodic_advertiser_list_size_rp0_s {
  uint8_t Status;
  uint8_t Periodic_Advertiser_List_Size;
} aci_gap_read_periodic_advertiser_list_size_rp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_receive_enable_cp0_s {
  uint16_t Sync_Handle;
  uint8_t Enable;
} aci_gap_set_periodic_advertising_receive_enable_cp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_receive_enable_rp0_s {
  uint8_t Status;
} aci_gap_set_periodic_advertising_receive_enable_rp0;

typedef PACKED(struct) aci_gap_periodic_advertising_sync_transfer_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Data;
  uint16_t Sync_Handle;
} aci_gap_periodic_advertising_sync_transfer_cp0;

typedef PACKED(struct) aci_gap_periodic_advertising_sync_transfer_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} aci_gap_periodic_advertising_sync_transfer_rp0;

typedef PACKED(struct) aci_gap_periodic_advertising_set_info_transfer_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Data;
  uint8_t Advertising_Handle;
} aci_gap_periodic_advertising_set_info_transfer_cp0;

typedef PACKED(struct) aci_gap_periodic_advertising_set_info_transfer_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} aci_gap_periodic_advertising_set_info_transfer_rp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_sync_transfer_parameters_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Mode;
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t CTE_Type;
} aci_gap_set_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) aci_gap_set_periodic_advertising_sync_transfer_parameters_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} aci_gap_set_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) aci_gap_set_default_periodic_advertising_sync_transfer_parameters_cp0_s {
  uint8_t Mode;
  uint16_t Skip;
  uint16_t Sync_Timeout;
  uint8_t CTE_Type;
} aci_gap_set_default_periodic_advertising_sync_transfer_parameters_cp0;

typedef PACKED(struct) aci_gap_set_default_periodic_advertising_sync_transfer_parameters_rp0_s {
  uint8_t Status;
} aci_gap_set_default_periodic_advertising_sync_transfer_parameters_rp0;

typedef PACKED(struct) aci_gatt_srv_init_rp0_s {
  uint8_t Status;
} aci_gatt_srv_init_rp0;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_cp0_s {
  uint8_t Service_UUID_Type;
  packed_Service_UUID_t Service_UUID;
} aci_gatt_srv_add_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_cp1_s {
  uint8_t Service_Type;
  uint8_t Max_Attribute_Records;
} aci_gatt_srv_add_service_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_service_nwk_rp0_s {
  uint8_t Status;
  uint16_t Service_Handle;
} aci_gatt_srv_add_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_include_service_nwk_cp0_s {
  uint16_t Service_Handle;
  uint16_t Included_Service_Handle;
} aci_gatt_srv_include_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_include_service_nwk_rp0_s {
  uint8_t Status;
  uint16_t Include_Handle;
} aci_gatt_srv_include_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_cp0_s {
  uint16_t Service_Handle;
  uint8_t Char_UUID_Type;
  packed_Char_UUID_t Char_UUID;
} aci_gatt_srv_add_char_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_cp1_s {
  uint16_t Char_Value_Length;
  uint8_t Char_Properties;
  uint8_t Security_Permissions;
  uint8_t GATT_Evt_Mask;
  uint8_t Enc_Key_Size;
  uint8_t Is_Variable;
} aci_gatt_srv_add_char_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_char_nwk_rp0_s {
  uint8_t Status;
  uint16_t Char_Handle;
} aci_gatt_srv_add_char_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp0_s {
  uint16_t Char_Handle;
  uint8_t Char_Desc_Uuid_Type;
  packed_Char_Desc_Uuid_t Char_Desc_Uuid;
} aci_gatt_srv_add_char_desc_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp1_s {
  uint16_t Char_Desc_Value_Max_Len;
  uint16_t Char_Desc_Value_Length;
  uint8_t Char_Desc_Value[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} aci_gatt_srv_add_char_desc_nwk_cp1;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_cp2_s {
  uint8_t Security_Permissions;
  uint8_t Access_Permissions;
  uint8_t GATT_Evt_Mask;
  uint8_t Enc_Key_Size;
  uint8_t Is_Variable;
} aci_gatt_srv_add_char_desc_nwk_cp2;

typedef PACKED(struct) aci_gatt_srv_add_char_desc_nwk_rp0_s {
  uint8_t Status;
  uint16_t Char_Desc_Handle;
} aci_gatt_srv_add_char_desc_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_write_handle_value_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_write_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_write_handle_value_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_write_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_char_nwk_cp0_s {
  uint16_t Char_Handle;
} aci_gatt_srv_rm_char_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_char_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_rm_char_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_service_nwk_cp0_s {
  uint16_t Serv_Handle;
} aci_gatt_srv_rm_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_service_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_rm_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_rm_include_service_nwk_cp0_s {
  uint16_t Include_Handle;
} aci_gatt_srv_rm_include_service_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_rm_include_service_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_rm_include_service_nwk_rp0;

typedef PACKED(struct) aci_gatt_set_event_mask_cp0_s {
  uint32_t GATT_Evt_Mask;
} aci_gatt_set_event_mask_cp0;

typedef PACKED(struct) aci_gatt_set_event_mask_rp0_s {
  uint8_t Status;
} aci_gatt_set_event_mask_rp0;

typedef PACKED(struct) aci_gatt_clt_exchange_config_cp0_s {
  uint16_t Connection_Handle;
} aci_gatt_clt_exchange_config_cp0;

typedef PACKED(struct) aci_gatt_clt_exchange_config_rp0_s {
  uint8_t Status;
} aci_gatt_clt_exchange_config_rp0;

typedef PACKED(struct) aci_gatt_clt_prepare_write_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_prepare_write_req_cp0;

typedef PACKED(struct) aci_gatt_clt_prepare_write_req_rp0_s {
  uint8_t Status;
} aci_gatt_clt_prepare_write_req_rp0;

typedef PACKED(struct) aci_gatt_clt_execute_write_req_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Execute;
} aci_gatt_clt_execute_write_req_cp0;

typedef PACKED(struct) aci_gatt_clt_execute_write_req_rp0_s {
  uint8_t Status;
} aci_gatt_clt_execute_write_req_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_primary_services_cp0_s {
  uint16_t Connection_Handle;
} aci_gatt_clt_disc_all_primary_services_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_primary_services_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_all_primary_services_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_primary_service_by_uuid_cp0_s {
  uint16_t Connection_Handle;
  uint8_t UUID_Type;
  packed_UUID_t UUID;
} aci_gatt_clt_disc_primary_service_by_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_primary_service_by_uuid_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_primary_service_by_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_find_included_services_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Start_Handle;
  uint16_t End_Handle;
} aci_gatt_clt_find_included_services_cp0;

typedef PACKED(struct) aci_gatt_clt_find_included_services_rp0_s {
  uint8_t Status;
} aci_gatt_clt_find_included_services_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_of_service_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Start_Handle;
  uint16_t End_Handle;
} aci_gatt_clt_disc_all_char_of_service_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_of_service_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_all_char_of_service_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_char_by_uuid_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Start_Handle;
  uint16_t End_Handle;
  uint8_t UUID_Type;
  packed_UUID_t UUID;
} aci_gatt_clt_disc_char_by_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_char_by_uuid_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_char_by_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_desc_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Char_Handle;
  uint16_t End_Handle;
} aci_gatt_clt_disc_all_char_desc_cp0;

typedef PACKED(struct) aci_gatt_clt_disc_all_char_desc_rp0_s {
  uint8_t Status;
} aci_gatt_clt_disc_all_char_desc_rp0;

typedef PACKED(struct) aci_gatt_clt_read_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
} aci_gatt_clt_read_cp0;

typedef PACKED(struct) aci_gatt_clt_read_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_rp0;

typedef PACKED(struct) aci_gatt_clt_read_using_char_uuid_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Start_Handle;
  uint16_t End_Handle;
  uint8_t UUID_Type;
  packed_UUID_t UUID;
} aci_gatt_clt_read_using_char_uuid_cp0;

typedef PACKED(struct) aci_gatt_clt_read_using_char_uuid_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_using_char_uuid_rp0;

typedef PACKED(struct) aci_gatt_clt_read_long_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
} aci_gatt_clt_read_long_cp0;

typedef PACKED(struct) aci_gatt_clt_read_long_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_long_rp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_char_value_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Number_of_Handles;
  packed_Handle_Entry_t Handle_Entry[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_Handle_Entry_t)];
} aci_gatt_clt_read_multiple_char_value_cp0;

typedef PACKED(struct) aci_gatt_clt_read_multiple_char_value_rp0_s {
  uint8_t Status;
} aci_gatt_clt_read_multiple_char_value_rp0;

typedef PACKED(struct) aci_gatt_clt_write_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_write_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_long_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_write_long_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_long_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_long_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_char_reliable_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Val_Offset;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_write_char_reliable_nwk_cp0;

typedef PACKED(struct) aci_gatt_clt_write_char_reliable_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_char_reliable_nwk_rp0;

typedef PACKED(struct) aci_gatt_clt_write_without_resp_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_write_without_resp_cp0;

typedef PACKED(struct) aci_gatt_clt_write_without_resp_rp0_s {
  uint8_t Status;
} aci_gatt_clt_write_without_resp_rp0;

typedef PACKED(struct) aci_gatt_clt_signed_write_without_resp_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Attribute_Val_Length;
  uint8_t Attribute_Val[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_signed_write_without_resp_cp0;

typedef PACKED(struct) aci_gatt_clt_signed_write_without_resp_rp0_s {
  uint8_t Status;
} aci_gatt_clt_signed_write_without_resp_rp0;

typedef PACKED(struct) aci_gatt_clt_confirm_indication_cp0_s {
  uint16_t Connection_Handle;
} aci_gatt_clt_confirm_indication_cp0;

typedef PACKED(struct) aci_gatt_clt_confirm_indication_rp0_s {
  uint8_t Status;
} aci_gatt_clt_confirm_indication_rp0;

typedef PACKED(struct) aci_gatt_srv_set_security_permission_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint8_t Security_Permissions;
} aci_gatt_srv_set_security_permission_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_set_security_permission_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_set_security_permission_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_read_handle_value_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint16_t Offset;
  uint16_t Value_Length_Requested;
} aci_gatt_srv_read_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_handle_value_nwk_rp0_s {
  uint8_t Status;
  uint16_t Length;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_gatt_srv_read_handle_value_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_set_access_permission_nwk_cp0_s {
  uint16_t Attr_Handle;
  uint8_t Access_Permissions;
} aci_gatt_srv_set_access_permission_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_set_access_permission_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_set_access_permission_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_notify_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint8_t Flags;
  uint16_t Val_Length;
  uint8_t Val[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_gatt_srv_notify_cp0;

typedef PACKED(struct) aci_gatt_srv_notify_rp0_s {
  uint8_t Status;
} aci_gatt_srv_notify_rp0;

typedef PACKED(struct) aci_gatt_srv_exec_write_resp_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint8_t Exec;
} aci_gatt_srv_exec_write_resp_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_exec_write_resp_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_exec_write_resp_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_authorize_resp_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint16_t Attr_Handle;
  uint8_t Operation_Type;
  uint8_t Error_Code;
  uint16_t Attr_Val_Offset;
  uint16_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_gatt_srv_authorize_resp_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_authorize_resp_nwk_rp0_s {
  uint8_t Status;
} aci_gatt_srv_authorize_resp_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_read_prepare_queue_nwk_cp0_s {
  uint16_t Conn_Handle;
  uint8_t Item_Index;
} aci_gatt_srv_read_prepare_queue_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_prepare_queue_nwk_rp0_s {
  uint8_t Status;
  uint16_t Attr_Handle;
  uint16_t Value_Offset;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_gatt_srv_read_prepare_queue_nwk_rp0;

typedef PACKED(struct) aci_gatt_srv_write_multiple_instance_handle_value_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_write_multiple_instance_handle_value_cp0;

typedef PACKED(struct) aci_gatt_srv_write_multiple_instance_handle_value_rp0_s {
  uint8_t Status;
} aci_gatt_srv_write_multiple_instance_handle_value_rp0;

typedef PACKED(struct) aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
} aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0;

typedef PACKED(struct) aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0_s {
  uint8_t Status;
  uint16_t Value_Length;
  uint8_t Value[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_req_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Conn_Interval_Min;
  uint16_t Conn_Interval_Max;
  uint16_t Slave_latency;
  uint16_t Timeout_Multiplier;
} aci_l2cap_connection_parameter_update_req_cp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_req_rp0_s {
  uint8_t Status;
} aci_l2cap_connection_parameter_update_req_rp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_resp_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Conn_Interval_Min;
  uint16_t Conn_Interval_Max;
  uint16_t Slave_latency;
  uint16_t Timeout_Multiplier;
  uint16_t Minimum_CE_Length;
  uint16_t Maximum_CE_Length;
  uint8_t Identifier;
  uint8_t Accept;
} aci_l2cap_connection_parameter_update_resp_cp0;

typedef PACKED(struct) aci_l2cap_connection_parameter_update_resp_rp0_s {
  uint8_t Status;
} aci_l2cap_connection_parameter_update_resp_rp0;

typedef PACKED(struct) aci_l2cap_cfc_connection_req_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t SPSM;
  uint16_t CID;
  uint16_t MTU;
  uint16_t MPS;
  uint8_t CFC_Policy;
} aci_l2cap_cfc_connection_req_nwk_cp0;

typedef PACKED(struct) aci_l2cap_cfc_connection_req_nwk_rp0_s {
  uint8_t Status;
} aci_l2cap_cfc_connection_req_nwk_rp0;

typedef PACKED(struct) aci_l2cap_cfc_connection_resp_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint8_t Identifier;
  uint16_t CID;
  uint16_t MTU;
  uint16_t MPS;
  uint16_t Result;
  uint8_t CFC_Policy;
} aci_l2cap_cfc_connection_resp_nwk_cp0;

typedef PACKED(struct) aci_l2cap_cfc_connection_resp_nwk_rp0_s {
  uint8_t Status;
} aci_l2cap_cfc_connection_resp_nwk_rp0;

typedef PACKED(struct) aci_l2cap_send_flow_control_credits_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t RX_Credits;
  uint8_t CFC_Policy;
} aci_l2cap_send_flow_control_credits_cp0;

typedef PACKED(struct) aci_l2cap_send_flow_control_credits_rp0_s {
  uint8_t Status;
  uint16_t RX_Credit_Balance;
} aci_l2cap_send_flow_control_credits_rp0;

typedef PACKED(struct) aci_l2cap_disconnect_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
} aci_l2cap_disconnect_cp0;

typedef PACKED(struct) aci_l2cap_disconnect_rp0_s {
  uint8_t Status;
} aci_l2cap_disconnect_rp0;

typedef PACKED(struct) aci_l2cap_transmit_sdu_data_nwk_cp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t SDU_Length;
  uint8_t SDU_Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_l2cap_transmit_sdu_data_nwk_cp0;

typedef PACKED(struct) aci_l2cap_transmit_sdu_data_nwk_rp0_s {
  uint8_t Status;
} aci_l2cap_transmit_sdu_data_nwk_rp0;

typedef PACKED(struct) aci_test_tx_notification_start_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Service_Handle;
  uint16_t Char_Handle;
  uint16_t Value_Length;
} aci_test_tx_notification_start_cp0;

typedef PACKED(struct) aci_test_tx_notification_start_rp0_s {
  uint8_t Status;
} aci_test_tx_notification_start_rp0;

typedef PACKED(struct) aci_test_tx_write_command_start_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Value_Length;
} aci_test_tx_write_command_start_cp0;

typedef PACKED(struct) aci_test_tx_write_command_start_rp0_s {
  uint8_t Status;
} aci_test_tx_write_command_start_rp0;

typedef PACKED(struct) aci_test_rx_start_cp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint8_t Notifications_WriteCmds;
} aci_test_rx_start_cp0;

typedef PACKED(struct) aci_test_rx_start_rp0_s {
  uint8_t Status;
} aci_test_rx_start_rp0;

typedef PACKED(struct) aci_test_stop_cp0_s {
  uint8_t TX_RX;
} aci_test_stop_cp0;

typedef PACKED(struct) aci_test_stop_rp0_s {
  uint8_t Status;
} aci_test_stop_rp0;

typedef PACKED(struct) aci_test_report_rp0_s {
  uint8_t Status;
  uint32_t TX_Packets;
  uint32_t RX_Packets;
  uint16_t RX_Data_Length;
  uint32_t RX_Sequence_Errors;
} aci_test_report_rp0;

typedef PACKED(struct) hci_disconnection_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t Reason;
} hci_disconnection_complete_event_rp0;

typedef PACKED(struct) hci_encryption_change_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t Encryption_Enabled;
} hci_encryption_change_event_rp0;

typedef PACKED(struct) hci_read_remote_version_information_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t Version;
  uint16_t Manufacturer_Name;
  uint16_t Subversion;
} hci_read_remote_version_information_complete_event_rp0;

typedef PACKED(struct) hci_hardware_error_event_rp0_s {
  uint8_t Hardware_Code;
} hci_hardware_error_event_rp0;

typedef PACKED(struct) hci_number_of_completed_packets_event_rp0_s {
  uint8_t Number_of_Handles;
  packed_Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Handle_Packets_Pair_Entry_t)];
} hci_number_of_completed_packets_event_rp0;

typedef PACKED(struct) hci_data_buffer_overflow_event_rp0_s {
  uint8_t Link_Type;
} hci_data_buffer_overflow_event_rp0;

typedef PACKED(struct) hci_encryption_key_refresh_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_encryption_key_refresh_complete_event_rp0;

typedef PACKED(struct) hci_authenticated_payload_timeout_expired_event_rp0_s {
  uint16_t Connection_Handle;
} hci_authenticated_payload_timeout_expired_event_rp0;

typedef PACKED(struct) aci_blue_initialized_event_rp0_s {
  uint8_t Reason_Code;
} aci_blue_initialized_event_rp0;

typedef PACKED(struct) aci_blue_events_lost_event_rp0_s {
  uint8_t Lost_Events[8];
} aci_blue_events_lost_event_rp0;

typedef PACKED(struct) aci_blue_crash_info_event_rp0_s {
  uint8_t Crash_Type;
  uint32_t SP;
  uint32_t R0;
  uint32_t R1;
  uint32_t R2;
  uint32_t R3;
  uint32_t R12;
  uint32_t LR;
  uint32_t PC;
  uint32_t xPSR;
  uint8_t Debug_Data_Length;
  uint8_t Debug_Data[(HCI_MAX_PAYLOAD_SIZE - 38)/sizeof(uint8_t)];
} aci_blue_crash_info_event_rp0;

typedef PACKED(struct) aci_hal_end_of_radio_activity_event_rp0_s {
  uint8_t Last_State;
  uint8_t Next_State;
  uint32_t Next_State_SysTime;
} aci_hal_end_of_radio_activity_event_rp0;

typedef PACKED(struct) aci_hal_scan_req_report_event_rp0_s {
  int8_t RSSI;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
} aci_hal_scan_req_report_event_rp0;

typedef PACKED(struct) aci_hal_fw_error_event_rp0_s {
  uint8_t FW_Error_Type;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_fw_error_event_rp0;

typedef PACKED(struct) aci_hal_le_test_end_event_rp0_s {
  uint16_t Number_Of_Packets;
} aci_hal_le_test_end_event_rp0;

typedef PACKED(struct) aci_gap_pairing_complete_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Status;
  uint8_t Reason;
} aci_gap_pairing_complete_event_rp0;

typedef PACKED(struct) aci_gap_pass_key_req_event_rp0_s {
  uint16_t Connection_Handle;
} aci_gap_pass_key_req_event_rp0;

typedef PACKED(struct) aci_gap_proc_complete_event_rp0_s {
  uint8_t Procedure_Code;
  uint8_t Status;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_proc_complete_event_rp0;

typedef PACKED(struct) aci_gap_addr_not_resolved_event_rp0_s {
  uint16_t Connection_Handle;
} aci_gap_addr_not_resolved_event_rp0;

typedef PACKED(struct) aci_gap_numeric_comparison_value_event_rp0_s {
  uint16_t Connection_Handle;
  uint32_t Numeric_Value;
} aci_gap_numeric_comparison_value_event_rp0;

typedef PACKED(struct) aci_gap_keypress_notification_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Notification_Type;
} aci_gap_keypress_notification_event_rp0;

typedef PACKED(struct) aci_l2cap_connection_update_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Result;
} aci_l2cap_connection_update_resp_event_rp0;

typedef PACKED(struct) aci_l2cap_proc_timeout_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_l2cap_proc_timeout_event_rp0;

typedef PACKED(struct) aci_l2cap_connection_update_req_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Identifier;
  uint16_t L2CAP_Length;
  uint16_t Interval_Min;
  uint16_t Interval_Max;
  uint16_t Slave_Latency;
  uint16_t Timeout_Multiplier;
} aci_l2cap_connection_update_req_event_rp0;

typedef PACKED(struct) aci_l2cap_cfc_connection_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Event_Type;
  uint16_t Result;
  uint8_t Identifier;
  uint16_t SPSM;
  uint16_t CID;
  uint16_t Remote_CID;
  uint16_t Peer_MTU;
  uint16_t Peer_MPS;
  uint16_t Initial_Credits;
} aci_l2cap_cfc_connection_event_rp0;

typedef PACKED(struct) aci_l2cap_disconnection_complete_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
} aci_l2cap_disconnection_complete_event_rp0;

typedef PACKED(struct) aci_l2cap_flow_control_credit_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t TX_Credits;
  uint16_t TX_Credit_Balance;
} aci_l2cap_flow_control_credit_event_rp0;

typedef PACKED(struct) aci_l2cap_sdu_data_tx_nwk_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t SDU_Length;
  uint16_t TX_Credit_Balance;
} aci_l2cap_sdu_data_tx_nwk_event_rp0;

typedef PACKED(struct) aci_l2cap_sdu_data_rx_nwk_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t CID;
  uint16_t RX_Credit_Balance;
  uint16_t SDU_Length;
  uint8_t SDU_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_l2cap_sdu_data_rx_nwk_event_rp0;

typedef PACKED(struct) aci_l2cap_command_reject_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Identifier;
  uint16_t Reason;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_l2cap_command_reject_event_rp0;

typedef PACKED(struct) aci_gatt_srv_attribute_modified_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Attr_Handle;
  uint16_t Attr_Data_Length;
  uint8_t Attr_Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_srv_attribute_modified_event_rp0;

typedef PACKED(struct) aci_gatt_proc_timeout_event_rp0_s {
  uint16_t Connection_Handle;
} aci_gatt_proc_timeout_event_rp0;

typedef PACKED(struct) aci_att_exchange_mtu_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Server_RX_MTU;
} aci_att_exchange_mtu_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_find_info_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Format;
  uint16_t Event_Data_Length;
  uint8_t Handle_UUID_Pair[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_att_clt_find_info_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_find_by_type_value_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Num_of_Handle_Pair;
  packed_Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(packed_Attribute_Group_Handle_Pair_t)];
} aci_att_clt_find_by_type_value_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_read_by_type_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Handle_Value_Pair_Length;
  uint16_t Data_Length;
  uint8_t Handle_Value_Pair_Data[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_att_clt_read_by_type_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_read_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Event_Data_Length;
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} aci_att_clt_read_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_read_blob_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Event_Data_Length;
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} aci_att_clt_read_blob_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_read_multiple_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Event_Data_Length;
  uint8_t Set_Of_Values[(HCI_MAX_PAYLOAD_SIZE - 4)/sizeof(uint8_t)];
} aci_att_clt_read_multiple_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_read_by_group_type_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Attribute_Data_Length;
  uint16_t Data_Length;
  uint8_t Attribute_Data_List[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_att_clt_read_by_group_type_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_prepare_write_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Attribute_Handle;
  uint16_t Offset;
  uint16_t Part_Attribute_Value_Length;
  uint8_t Part_Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_att_clt_prepare_write_resp_event_rp0;

typedef PACKED(struct) aci_att_clt_exec_write_resp_event_rp0_s {
  uint16_t Connection_Handle;
} aci_att_clt_exec_write_resp_event_rp0;

typedef PACKED(struct) aci_gatt_clt_indication_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Attribute_Handle;
  uint16_t Attribute_Value_Length;
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_indication_event_rp0;

typedef PACKED(struct) aci_gatt_clt_notification_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Attribute_Handle;
  uint16_t Attribute_Value_Length;
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_gatt_clt_notification_event_rp0;

typedef PACKED(struct) aci_gatt_clt_proc_complete_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Error_Code;
} aci_gatt_clt_proc_complete_event_rp0;

typedef PACKED(struct) aci_gatt_clt_error_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Req_Opcode;
  uint16_t Attribute_Handle;
  uint8_t Error_Code;
} aci_gatt_clt_error_resp_event_rp0;

typedef PACKED(struct) aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Attribute_Handle;
  uint8_t Attribute_Value_Length;
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(uint8_t)];
} aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0;

typedef PACKED(struct) aci_gatt_tx_pool_available_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t Available_Buffers;
} aci_gatt_tx_pool_available_event_rp0;

typedef PACKED(struct) aci_gatt_srv_confirmation_event_rp0_s {
  uint16_t Connection_Handle;
} aci_gatt_srv_confirmation_event_rp0;

typedef PACKED(struct) aci_att_srv_exec_write_req_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Flags;
} aci_att_srv_exec_write_req_event_rp0;

typedef PACKED(struct) aci_gatt_srv_authorize_nwk_event_rp0_s {
  uint16_t Conn_Handle;
  uint16_t Attr_Handle;
  uint8_t Operation_Type;
  uint16_t Attr_Val_Offset;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_srv_authorize_nwk_event_rp0;

typedef PACKED(struct) hci_le_connection_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t Role;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint16_t Conn_Interval;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
  uint8_t Master_Clock_Accuracy;
} hci_le_connection_complete_event_rp0;

typedef PACKED(struct) hci_le_advertising_report_event_rp0_s {
  uint8_t Num_Reports;
  packed_Advertising_Report_t Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Advertising_Report_t)];
} hci_le_advertising_report_event_rp0;

typedef PACKED(struct) hci_le_connection_update_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint16_t Conn_Interval;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
} hci_le_connection_update_complete_event_rp0;

typedef PACKED(struct) hci_le_read_remote_used_features_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t LE_Features[8];
} hci_le_read_remote_used_features_complete_event_rp0;

typedef PACKED(struct) hci_le_long_term_key_request_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Random_Number[8];
  uint16_t Encrypted_Diversifier;
} hci_le_long_term_key_request_event_rp0;

typedef PACKED(struct) hci_le_data_length_change_event_rp0_s {
  uint16_t Connection_Handle;
  uint16_t MaxTxOctets;
  uint16_t MaxTxTime;
  uint16_t MaxRxOctets;
  uint16_t MaxRxTime;
} hci_le_data_length_change_event_rp0;

typedef PACKED(struct) hci_le_read_local_p256_public_key_complete_event_rp0_s {
  uint8_t Status;
  uint8_t Local_P256_Public_Key[64];
} hci_le_read_local_p256_public_key_complete_event_rp0;

typedef PACKED(struct) hci_le_generate_dhkey_complete_event_rp0_s {
  uint8_t Status;
  uint8_t DHKey[32];
} hci_le_generate_dhkey_complete_event_rp0;

typedef PACKED(struct) hci_le_enhanced_connection_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t Role;
  uint8_t Peer_Address_Type;
  uint8_t Peer_Address[6];
  uint8_t Local_Resolvable_Private_Address[6];
  uint8_t Peer_Resolvable_Private_Address[6];
  uint16_t Conn_Interval;
  uint16_t Conn_Latency;
  uint16_t Supervision_Timeout;
  uint8_t Master_Clock_Accuracy;
} hci_le_enhanced_connection_complete_event_rp0;

typedef PACKED(struct) hci_le_direct_advertising_report_event_rp0_s {
  uint8_t Num_Reports;
  packed_Direct_Advertising_Report_t Direct_Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Direct_Advertising_Report_t)];
} hci_le_direct_advertising_report_event_rp0;

typedef PACKED(struct) hci_le_phy_update_complete_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t TX_PHY;
  uint8_t RX_PHY;
} hci_le_phy_update_complete_event_rp0;

typedef PACKED(struct) hci_le_extended_advertising_report_event_rp0_s {
  uint8_t Num_Reports;
  packed_Extended_Advertising_Report_t Extended_Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Extended_Advertising_Report_t)];
} hci_le_extended_advertising_report_event_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_established_event_rp0_s {
  uint8_t Status;
  uint16_t Sync_Handle;
  uint8_t Advertising_SID;
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertiser_PHY;
  uint16_t Periodic_Advertising_Interval;
  uint8_t Advertiser_Clock_Accuracy;
} hci_le_periodic_advertising_sync_established_event_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_report_event_rp0_s {
  uint16_t Sync_Handle;
  int8_t TX_Power;
  int8_t RSSI;
  uint8_t CTE_Type;
  uint8_t Data_Status;
  uint8_t Data_Length;
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_periodic_advertising_report_event_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_lost_event_rp0_s {
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_sync_lost_event_rp0;

typedef PACKED(struct) hci_le_advertising_set_terminated_event_rp0_s {
  uint8_t Status;
  uint8_t Advertising_Handle;
  uint16_t Connection_Handle;
  uint8_t Num_Completed_Extended_Advertising_Events;
} hci_le_advertising_set_terminated_event_rp0;

typedef PACKED(struct) hci_le_scan_request_received_event_rp0_s {
  uint8_t Advertising_Handle;
  uint8_t Scanner_Address_Type;
  uint8_t Scanner_Address[6];
} hci_le_scan_request_received_event_rp0;

typedef PACKED(struct) hci_le_channel_selection_algorithm_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Channel_Selection_Algorithm;
} hci_le_channel_selection_algorithm_event_rp0;

typedef PACKED(struct) hci_le_connectionless_iq_report_event_rp0_s {
  uint16_t Sync_Handle;
  uint8_t Channel_Index;
  int16_t RSSI;
  uint8_t RSSI_Antenna_ID;
  uint8_t CTE_Type;
  uint8_t Slot_Durations;
  uint8_t Packet_Status;
  uint16_t Periodic_Event_Counter;
  uint8_t Sample_Count;
  packed_Samples_t Samples[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(packed_Samples_t)];
} hci_le_connectionless_iq_report_event_rp0;

typedef PACKED(struct) hci_le_connection_iq_report_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t RX_PHY;
  uint8_t Data_Channel_Index;
  int16_t RSSI;
  uint8_t RSSI_Antenna_ID;
  uint8_t CTE_Type;
  uint8_t Slot_Durations;
  uint8_t Packet_Status;
  uint16_t Connection_Event_Counter;
  uint8_t Sample_Count;
  packed_Samples_t Samples[(HCI_MAX_PAYLOAD_SIZE - 13)/sizeof(packed_Samples_t)];
} hci_le_connection_iq_report_event_rp0;

typedef PACKED(struct) hci_le_cte_request_failed_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
} hci_le_cte_request_failed_event_rp0;

typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_received_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint16_t Service_data;
  uint16_t Sync_Handle;
  uint8_t Advertising_SID;
  uint8_t Advertiser_Address_Type;
  uint8_t Advertiser_Address[6];
  uint8_t Advertiser_PHY;
  uint16_t Periodic_Advertising_Interval;
  uint8_t Advertiser_Clock_Accuracy;
} hci_le_periodic_advertising_sync_transfer_received_event_rp0;

typedef PACKED(struct) hci_le_path_loss_threshold_event_rp0_s {
  uint16_t Connection_Handle;
  uint8_t Current_Path_Loss;
  uint8_t Zone_Entered;
} hci_le_path_loss_threshold_event_rp0;

typedef PACKED(struct) hci_le_transmit_power_reporting_event_rp0_s {
  uint8_t Status;
  uint16_t Connection_Handle;
  uint8_t Reason;
  uint8_t PHY;
  int8_t Transmit_Power_Level;
  uint8_t Transmit_Power_Level_Flag;
  int8_t Delta;
} hci_le_transmit_power_reporting_event_rp0;

uint16_t hci_disconnect_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_remote_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

uint16_t hci_set_event_mask_page_2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_write_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_local_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS

uint16_t hci_read_local_supported_commands_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_read_bd_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_read_rssi_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS

uint16_t hci_le_read_buffer_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_advertising_channel_tx_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_create_connection_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_white_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_white_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_add_device_to_white_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_device_from_white_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

uint16_t hci_le_set_host_channel_classification_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_read_channel_map_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_read_remote_used_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_encrypt_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif

#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_rand_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_start_encryption_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_long_term_key_request_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_long_term_key_requested_negative_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_supported_states_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_receiver_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_test_end_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_read_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif 
uint16_t hci_le_write_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_local_p256_public_key_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);

#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_generate_dhkey_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_add_device_to_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_device_from_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_resolving_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_peer_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_local_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_address_resolution_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_resolvable_private_address_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_read_maximum_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_read_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif 
uint16_t hci_le_set_default_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_enhanced_receiver_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_enhanced_transmitter_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);

#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_set_advertising_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_maximum_advertising_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_number_of_supported_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_extended_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_extended_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_create_sync_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_add_device_to_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_remove_device_from_periodic_advertising_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_clear_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_periodic_advertiser_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_transmit_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_write_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_privacy_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_receiver_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connectionless_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connectionless_cte_transmit_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connectionless_iq_sampling_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connection_cte_receive_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_connection_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_connection_cte_request_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_connection_cte_response_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_antenna_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);

#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_set_periodic_advertising_receive_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_sync_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_periodic_advertising_set_info_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_default_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
uint16_t hci_le_enhanced_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_read_remote_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_path_loss_reporting_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_path_loss_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_set_transmit_power_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t hci_le_transmitter_test_v4_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_fw_build_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_firmware_details_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_write_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_read_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_tx_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_le_tx_test_packet_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_tone_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_tone_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_link_status_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_radio_activity_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_le_power_control_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_updater_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_transmitter_test_packets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_transmitter_test_packets_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_write_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_read_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_set_antenna_switch_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_hal_get_evt_fifo_max_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_io_capability_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_authentication_requirement_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_pass_key_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_slave_security_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_get_security_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_terminate_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_clear_security_db_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_allow_rebond_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_terminate_proc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_start_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_send_pairing_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_resolve_private_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_get_bonded_devices_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_is_device_bonded_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_numeric_comparison_value_confirm_yesno_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_passkey_input_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_get_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_remove_bonded_device_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_advertising_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_advertising_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_scan_response_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_scan_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_connection_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_start_procedure_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_discover_name_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_add_devices_to_white_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_configure_white_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_periodic_advertising_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_periodic_advertising_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_periodic_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_periodic_advertising_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_periodic_advertising_create_sync_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_periodic_advertising_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_add_device_to_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_remove_device_from_periodic_advertising_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_clear_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_read_periodic_advertiser_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_periodic_advertising_receive_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_periodic_advertising_sync_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_periodic_advertising_set_info_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gap_set_default_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_add_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_add_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_add_char_desc_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_write_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_rm_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_rm_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_rm_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_exchange_config_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_prepare_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_execute_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_all_primary_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_primary_service_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_find_included_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_all_char_of_service_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_char_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_disc_all_char_desc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_using_char_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_long_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_read_multiple_char_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_long_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_char_reliable_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_signed_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_clt_confirm_indication_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_set_security_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_read_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_set_access_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_notify_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_exec_write_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_authorize_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_read_prepare_queue_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_write_multiple_instance_handle_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_gatt_srv_read_multiple_instance_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_connection_parameter_update_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_connection_parameter_update_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cfc_connection_req_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_cfc_connection_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_send_flow_control_credits_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_disconnect_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_l2cap_transmit_sdu_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_tx_notification_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_tx_write_command_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_rx_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
uint16_t aci_test_report_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length);
#ifndef CONFIG_NO_HCI_COMMANDS
const hci_command_table_type hci_command_table[220 + CONTROLLER_POWER_CONTROL_COMMANDS] = {
#else
const hci_command_table_type hci_command_table[220 + CONTROLLER_POWER_CONTROL_COMMANDS-63] = {
#endif 
  /* hci_disconnect */
  {0x0406, hci_disconnect_process},
  /* hci_read_remote_version_information */
  {0x041d, hci_read_remote_version_information_process},
  /* hci_set_event_mask */
  {0x0c01, hci_set_event_mask_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_read_transmit_power_level */ 
  {0x0c2d, hci_read_transmit_power_level_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_set_event_mask_page_2 */
  {0x0c63, hci_set_event_mask_page_2_process},
  /* hci_read_authenticated_payload_timeout */
  {0x0c7b, hci_read_authenticated_payload_timeout_process},
  /* hci_write_authenticated_payload_timeout */
  {0x0c7c, hci_write_authenticated_payload_timeout_process},
  /* hci_read_local_version_information */
  {0x1001, hci_read_local_version_information_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_read_local_supported_commands */
  {0x1002, hci_read_local_supported_commands_process},
  /* hci_read_local_supported_features */
  {0x1003, hci_read_local_supported_features_process},
  /* hci_read_bd_addr */
  {0x1009, hci_read_bd_addr_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_read_rssi */
  {0x1405, hci_read_rssi_process},
  /* hci_le_set_event_mask */
  {0x2001, hci_le_set_event_mask_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_read_buffer_size */
  {0x2002, hci_le_read_buffer_size_process},
  /* hci_le_read_local_supported_features */
  {0x2003, hci_le_read_local_supported_features_process},
  /* hci_le_set_random_address */
  {0x2005, hci_le_set_random_address_process},
  /* hci_le_set_advertising_parameters */
  {0x2006, hci_le_set_advertising_parameters_process},
  /* hci_le_read_advertising_channel_tx_power */
  {0x2007, hci_le_read_advertising_channel_tx_power_process},
  /* hci_le_set_advertising_data */
  {0x2008, hci_le_set_advertising_data_process},
  /* hci_le_set_scan_response_data */
  {0x2009, hci_le_set_scan_response_data_process},
  /* hci_le_set_advertising_enable */
  {0x200a, hci_le_set_advertising_enable_process},
  /* hci_le_set_scan_parameters */
  {0x200b, hci_le_set_scan_parameters_process},
  /* hci_le_set_scan_enable */
  {0x200c, hci_le_set_scan_enable_process},
  /* hci_le_create_connection */
  {0x200d, hci_le_create_connection_process},
  /* hci_le_create_connection_cancel */
  {0x200e, hci_le_create_connection_cancel_process},
  /* hci_le_read_white_list_size */
  {0x200f, hci_le_read_white_list_size_process},
  /* hci_le_clear_white_list */
  {0x2010, hci_le_clear_white_list_process},
  /* hci_le_add_device_to_white_list */
  {0x2011, hci_le_add_device_to_white_list_process},
  /* hci_le_remove_device_from_white_list */
  {0x2012, hci_le_remove_device_from_white_list_process},
  /* hci_le_connection_update */
  {0x2013, hci_le_connection_update_process},
#endif
  /* hci_le_set_host_channel_classification */
  {0x2014, hci_le_set_host_channel_classification_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_read_channel_map */
  {0x2015, hci_le_read_channel_map_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_read_remote_used_features */
  {0x2016, hci_le_read_remote_used_features_process},

#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_encrypt */
  {0x2017, hci_le_encrypt_process},
  /* hci_le_rand */
  {0x2018, hci_le_rand_process},
#endif
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_start_encryption */
  {0x2019, hci_le_start_encryption_process},
  /* hci_le_long_term_key_request_reply */
  {0x201a, hci_le_long_term_key_request_reply_process},
  /* hci_le_long_term_key_requested_negative_reply */
  {0x201b, hci_le_long_term_key_requested_negative_reply_process},
  /* hci_le_read_supported_states */
  {0x201c, hci_le_read_supported_states_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_receiver_test */
  {0x201d, hci_le_receiver_test_process},
  /* hci_le_transmitter_test */
  {0x201e, hci_le_transmitter_test_process},
  /* hci_le_test_end */
  {0x201f, hci_le_test_end_process},
  /* hci_le_set_data_length */
  {0x2022, hci_le_set_data_length_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_read_suggested_default_data_length */
  {0x2023, hci_le_read_suggested_default_data_length_process},
#endif 
  /* hci_le_write_suggested_default_data_length */
  {0x2024, hci_le_write_suggested_default_data_length_process},
  /* hci_le_read_local_p256_public_key */
  {0x2025, hci_le_read_local_p256_public_key_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_generate_dhkey */
  {0x2026, hci_le_generate_dhkey_process},
  /* hci_le_add_device_to_resolving_list */
  {0x2027, hci_le_add_device_to_resolving_list_process},
  /* hci_le_remove_device_from_resolving_list */
  {0x2028, hci_le_remove_device_from_resolving_list_process},
  /* hci_le_clear_resolving_list */
  {0x2029, hci_le_clear_resolving_list_process},
  /* hci_le_read_resolving_list_size */
  {0x202a, hci_le_read_resolving_list_size_process},
  /* hci_le_read_peer_resolvable_address */
  {0x202b, hci_le_read_peer_resolvable_address_process},
  /* hci_le_read_local_resolvable_address */
  {0x202c, hci_le_read_local_resolvable_address_process},
  /* hci_le_set_address_resolution_enable */
  {0x202d, hci_le_set_address_resolution_enable_process},
  /* hci_le_set_resolvable_private_address_timeout */
  {0x202e, hci_le_set_resolvable_private_address_timeout_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_read_maximum_data_length */
  {0x202f, hci_le_read_maximum_data_length_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_read_phy */
  {0x2030, hci_le_read_phy_process},
#endif 
  /* hci_le_set_default_phy */
  {0x2031, hci_le_set_default_phy_process},
  /* hci_le_set_phy */
  {0x2032, hci_le_set_phy_process},
  /* hci_le_enhanced_receiver_test */
  {0x2033, hci_le_enhanced_receiver_test_process},
  /* hci_le_enhanced_transmitter_test */
  {0x2034, hci_le_enhanced_transmitter_test_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_set_advertising_set_random_address */
  {0x2035, hci_le_set_advertising_set_random_address_process},
  /* hci_le_set_extended_advertising_parameters */
  {0x2036, hci_le_set_extended_advertising_parameters_process},
  /* hci_le_set_extended_advertising_data */
  {0x2037, hci_le_set_extended_advertising_data_process},
  /* hci_le_set_extended_scan_response_data */
  {0x2038, hci_le_set_extended_scan_response_data_process},
  /* hci_le_set_extended_advertising_enable */
  {0x2039, hci_le_set_extended_advertising_enable_process},
  /* hci_le_read_maximum_advertising_data_length */
  {0x203a, hci_le_read_maximum_advertising_data_length_process},
  /* hci_le_read_number_of_supported_advertising_sets */
  {0x203b, hci_le_read_number_of_supported_advertising_sets_process},
  /* hci_le_remove_advertising_set */
  {0x203c, hci_le_remove_advertising_set_process},
  /* hci_le_clear_advertising_sets */
  {0x203d, hci_le_clear_advertising_sets_process},
  /* hci_le_set_periodic_advertising_parameters */
  {0x203e, hci_le_set_periodic_advertising_parameters_process},
  /* hci_le_set_periodic_advertising_data */
  {0x203f, hci_le_set_periodic_advertising_data_process},
  /* hci_le_set_periodic_advertising_enable */
  {0x2040, hci_le_set_periodic_advertising_enable_process},
  /* hci_le_set_extended_scan_parameters */
  {0x2041, hci_le_set_extended_scan_parameters_process},
  /* hci_le_set_extended_scan_enable */
  {0x2042, hci_le_set_extended_scan_enable_process},
  /* hci_le_extended_create_connection */
  {0x2043, hci_le_extended_create_connection_process},
  /* hci_le_periodic_advertising_create_sync */
  {0x2044, hci_le_periodic_advertising_create_sync_process},
  /* hci_le_periodic_advertising_create_sync_cancel */
  {0x2045, hci_le_periodic_advertising_create_sync_cancel_process},
  /* hci_le_periodic_advertising_terminate_sync */
  {0x2046, hci_le_periodic_advertising_terminate_sync_process},
  /* hci_le_add_device_to_periodic_advertiser_list */
  {0x2047, hci_le_add_device_to_periodic_advertiser_list_process},
  /* hci_le_remove_device_from_periodic_advertising_list */
  {0x2048, hci_le_remove_device_from_periodic_advertising_list_process},
  /* hci_le_clear_periodic_advertiser_list */
  {0x2049, hci_le_clear_periodic_advertiser_list_process},
  /* hci_le_read_periodic_advertiser_list_size */
  {0x204a, hci_le_read_periodic_advertiser_list_size_process},
  /* hci_le_read_transmit_power */
  {0x204b, hci_le_read_transmit_power_process},
  /* hci_le_read_rf_path_compensation */
  {0x204c, hci_le_read_rf_path_compensation_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_write_rf_path_compensation */
  {0x204d, hci_le_write_rf_path_compensation_process},
  /* hci_le_set_privacy_mode */
  {0x204e, hci_le_set_privacy_mode_process},
  /* hci_le_receiver_test_v3 */
  {0x204f, hci_le_receiver_test_v3_process},
  /* hci_le_transmitter_test_v3 */
  {0x2050, hci_le_transmitter_test_v3_process},
  /* hci_le_set_connectionless_cte_transmit_parameters */
  {0x2051, hci_le_set_connectionless_cte_transmit_parameters_process},
  /* hci_le_set_connectionless_cte_transmit_enable */
  {0x2052, hci_le_set_connectionless_cte_transmit_enable_process},
  /* hci_le_set_connectionless_iq_sampling_enable */
  {0x2053, hci_le_set_connectionless_iq_sampling_enable_process},
  /* hci_le_set_connection_cte_receive_parameters */
  {0x2054, hci_le_set_connection_cte_receive_parameters_process},
  /* hci_le_set_connection_cte_transmit_parameters */
  {0x2055, hci_le_set_connection_cte_transmit_parameters_process},
  /* hci_le_connection_cte_request_enable */
  {0x2056, hci_le_connection_cte_request_enable_process},
  /* hci_le_connection_cte_response_enable */
  {0x2057, hci_le_connection_cte_response_enable_process},
  /* hci_le_read_antenna_information */
  {0x2058, hci_le_read_antenna_information_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* hci_le_set_periodic_advertising_receive_enable */
  {0x2059, hci_le_set_periodic_advertising_receive_enable_process},
  /* hci_le_periodic_advertising_sync_transfer */
  {0x205a, hci_le_periodic_advertising_sync_transfer_process},
  /* hci_le_periodic_advertising_set_info_transfer */
  {0x205b, hci_le_periodic_advertising_set_info_transfer_process},
  /* hci_le_set_periodic_advertising_sync_transfer_parameters */
  {0x205c, hci_le_set_periodic_advertising_sync_transfer_parameters_process},
  /* hci_le_set_default_periodic_advertising_sync_transfer_parameters */
  {0x205d, hci_le_set_default_periodic_advertising_sync_transfer_parameters_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
#if (defined(CONTROLLER_POWER_CONTROL_ENABLED) &&\
            (CONTROLLER_POWER_CONTROL_ENABLED == 1)) 
  /* hci_le_enhanced_read_transmit_power_level */
  {0x2076, hci_le_enhanced_read_transmit_power_level_process},
  /* hci_le_read_remote_transmit_power_level */
  {0x2077, hci_le_read_remote_transmit_power_level_process},
  /* hci_le_set_path_loss_reporting_parameters */
  {0x2078, hci_le_set_path_loss_reporting_parameters_process},
  /* hci_le_set_path_loss_reporting_enable */
  {0x2079, hci_le_set_path_loss_reporting_enable_process},
  /* hci_le_set_transmit_power_reporting_enable */
  {0x207a, hci_le_set_transmit_power_reporting_enable_process},
#endif
  /* hci_le_transmitter_test_v4 */
  {0x207b, hci_le_transmitter_test_v4_process},
#ifndef CONFIG_NO_HCI_COMMANDS
  /* aci_hal_get_fw_build_number */
  {0xfc00, aci_hal_get_fw_build_number_process},
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
  /* aci_hal_get_firmware_details */
  {0xfc01, aci_hal_get_firmware_details_process},
  /* aci_hal_write_config_data */
  {0xfc0c, aci_hal_write_config_data_process},
  /* aci_hal_read_config_data */
  {0xfc0d, aci_hal_read_config_data_process},
  /* aci_hal_set_tx_power_level */
  {0xfc0f, aci_hal_set_tx_power_level_process},
  /* aci_hal_le_tx_test_packet_number */
  {0xfc14, aci_hal_le_tx_test_packet_number_process},
  /* aci_hal_tone_start */
  {0xfc15, aci_hal_tone_start_process},
  /* aci_hal_tone_stop */
  {0xfc16, aci_hal_tone_stop_process},
  /* aci_hal_get_link_status */
  {0xfc17, aci_hal_get_link_status_process},
  /* aci_hal_set_radio_activity_mask */
  {0xfc18, aci_hal_set_radio_activity_mask_process},
  /* aci_hal_set_event_mask */
  {0xfc1a, aci_hal_set_event_mask_process},
#if (defined(CONTROLLER_POWER_CONTROL_ENABLED) &&\
            (CONTROLLER_POWER_CONTROL_ENABLED == 1))  
  /* aci_hal_set_le_power_control */
  {0xfc1c, aci_hal_set_le_power_control_process},
#endif
  /* aci_hal_updater_start */
  {0xfc20, aci_hal_updater_start_process},
  /* aci_hal_transmitter_test_packets */
  {0xfc2b, aci_hal_transmitter_test_packets_process},
  /* aci_hal_transmitter_test_packets_v2 */
  {0xfc2c, aci_hal_transmitter_test_packets_v2_process},
  /* aci_hal_write_radio_reg */
  {0xfc35, aci_hal_write_radio_reg_process},
  /* aci_hal_read_radio_reg */
  {0xfc36, aci_hal_read_radio_reg_process},
  /* aci_hal_set_antenna_switch_parameters */
  {0xfc37, aci_hal_set_antenna_switch_parameters_process},
  /* aci_hal_get_evt_fifo_max_level */
  {0xfc60, aci_hal_get_evt_fifo_max_level_process},
  /* aci_gap_set_io_capability */
  {0xfc85, aci_gap_set_io_capability_process},
  /* aci_gap_set_authentication_requirement */
  {0xfc86, aci_gap_set_authentication_requirement_process},
  /* aci_gap_pass_key_resp */
  {0xfc88, aci_gap_pass_key_resp_process},
  /* aci_gap_init */
  {0xfc8a, aci_gap_init_process},
  /* aci_gap_slave_security_req */
  {0xfc8d, aci_gap_slave_security_req_process},
  /* aci_gap_get_security_level */
  {0xfc90, aci_gap_get_security_level_process},
  /* aci_gap_set_event_mask */
  {0xfc91, aci_gap_set_event_mask_process},
  /* aci_gap_terminate */
  {0xfc93, aci_gap_terminate_process},
  /* aci_gap_clear_security_db */
  {0xfc94, aci_gap_clear_security_db_process},
  /* aci_gap_allow_rebond */
  {0xfc95, aci_gap_allow_rebond_process},
  /* aci_gap_create_connection */
  {0xfc9c, aci_gap_create_connection_process},
  /* aci_gap_terminate_proc */
  {0xfc9d, aci_gap_terminate_proc_process},
  /* aci_gap_start_connection_update */
  {0xfc9e, aci_gap_start_connection_update_process},
  /* aci_gap_send_pairing_req */
  {0xfc9f, aci_gap_send_pairing_req_process},
  /* aci_gap_resolve_private_addr */
  {0xfca0, aci_gap_resolve_private_addr_process},
  /* aci_gap_get_bonded_devices */
  {0xfca3, aci_gap_get_bonded_devices_process},
  /* aci_gap_is_device_bonded */
  {0xfca4, aci_gap_is_device_bonded_process},
  /* aci_gap_numeric_comparison_value_confirm_yesno */
  {0xfca5, aci_gap_numeric_comparison_value_confirm_yesno_process},
  /* aci_gap_passkey_input */
  {0xfca6, aci_gap_passkey_input_process},
  /* aci_gap_get_oob_data */
  {0xfca7, aci_gap_get_oob_data_process},
  /* aci_gap_set_oob_data */
  {0xfca8, aci_gap_set_oob_data_process},
  /* aci_gap_remove_bonded_device */
  {0xfcaa, aci_gap_remove_bonded_device_process},
  /* aci_gap_set_advertising_configuration */
  {0xfcab, aci_gap_set_advertising_configuration_process},
  /* aci_gap_set_advertising_enable */
  {0xfcac, aci_gap_set_advertising_enable_process},
  /* aci_gap_set_advertising_data_nwk */
  {0xfcad, aci_gap_set_advertising_data_nwk_process},
  /* aci_gap_set_scan_response_data_nwk */
  {0xfcae, aci_gap_set_scan_response_data_nwk_process},
  /* aci_gap_set_scan_configuration */
  {0xfcaf, aci_gap_set_scan_configuration_process},
  /* aci_gap_set_connection_configuration */
  {0xfcb0, aci_gap_set_connection_configuration_process},
  /* aci_gap_start_procedure */
  {0xfcb1, aci_gap_start_procedure_process},
  /* aci_gap_discover_name */
  {0xfcb2, aci_gap_discover_name_process},
  /* aci_gap_add_devices_to_white_and_resolving_list */
  {0xfcb3, aci_gap_add_devices_to_white_and_resolving_list_process},
  /* aci_gap_configure_white_and_resolving_list */
  {0xfcb4, aci_gap_configure_white_and_resolving_list_process},
  /* aci_gap_set_periodic_advertising_configuration */
  {0xfcb5, aci_gap_set_periodic_advertising_configuration_process},
  /* aci_gap_set_periodic_advertising_data_nwk */
  {0xfcb6, aci_gap_set_periodic_advertising_data_nwk_process},
  /* aci_gap_set_periodic_advertising_enable */
  {0xfcb7, aci_gap_set_periodic_advertising_enable_process},
  /* aci_gap_periodic_advertising_create_sync */
  {0xfcb8, aci_gap_periodic_advertising_create_sync_process},
  /* aci_gap_periodic_advertising_create_sync_cancel */
  {0xfcb9, aci_gap_periodic_advertising_create_sync_cancel_process},
  /* aci_gap_remove_advertising_set */
  {0xfcba, aci_gap_remove_advertising_set_process},
  /* aci_gap_clear_advertising_sets */
  {0xfcbb, aci_gap_clear_advertising_sets_process},
  /* aci_gap_periodic_advertising_terminate_sync */
  {0xfcc0, aci_gap_periodic_advertising_terminate_sync_process},
  /* aci_gap_add_device_to_periodic_advertiser_list */
  {0xfcc1, aci_gap_add_device_to_periodic_advertiser_list_process},
  /* aci_gap_remove_device_from_periodic_advertising_list */
  {0xfcc2, aci_gap_remove_device_from_periodic_advertising_list_process},
  /* aci_gap_clear_periodic_advertiser_list */
  {0xfcc3, aci_gap_clear_periodic_advertiser_list_process},
  /* aci_gap_read_periodic_advertiser_list_size */
  {0xfcc4, aci_gap_read_periodic_advertiser_list_size_process},
  /* aci_gap_set_periodic_advertising_receive_enable */
  {0xfcc5, aci_gap_set_periodic_advertising_receive_enable_process},
  /* aci_gap_periodic_advertising_sync_transfer */
  {0xfcc6, aci_gap_periodic_advertising_sync_transfer_process},
  /* aci_gap_periodic_advertising_set_info_transfer */
  {0xfcc7, aci_gap_periodic_advertising_set_info_transfer_process},
  /* aci_gap_set_periodic_advertising_sync_transfer_parameters */
  {0xfcc8, aci_gap_set_periodic_advertising_sync_transfer_parameters_process},
  /* aci_gap_set_default_periodic_advertising_sync_transfer_parameters */
  {0xfcc9, aci_gap_set_default_periodic_advertising_sync_transfer_parameters_process},
  /* aci_gatt_srv_init */
  {0xfd01, aci_gatt_srv_init_process},
  /* aci_gatt_srv_add_service_nwk */
  {0xfd02, aci_gatt_srv_add_service_nwk_process},
  /* aci_gatt_srv_include_service_nwk */
  {0xfd03, aci_gatt_srv_include_service_nwk_process},
  /* aci_gatt_srv_add_char_nwk */
  {0xfd04, aci_gatt_srv_add_char_nwk_process},
  /* aci_gatt_srv_add_char_desc_nwk */
  {0xfd05, aci_gatt_srv_add_char_desc_nwk_process},
  /* aci_gatt_srv_write_handle_value_nwk */
  {0xfd06, aci_gatt_srv_write_handle_value_nwk_process},
  /* aci_gatt_srv_rm_char_nwk */
  {0xfd07, aci_gatt_srv_rm_char_nwk_process},
  /* aci_gatt_srv_rm_service_nwk */
  {0xfd08, aci_gatt_srv_rm_service_nwk_process},
  /* aci_gatt_srv_rm_include_service_nwk */
  {0xfd09, aci_gatt_srv_rm_include_service_nwk_process},
  /* aci_gatt_set_event_mask */
  {0xfd0a, aci_gatt_set_event_mask_process},
  /* aci_gatt_clt_exchange_config */
  {0xfd0b, aci_gatt_clt_exchange_config_process},
  /* aci_gatt_clt_prepare_write_req */
  {0xfd10, aci_gatt_clt_prepare_write_req_process},
  /* aci_gatt_clt_execute_write_req */
  {0xfd11, aci_gatt_clt_execute_write_req_process},
  /* aci_gatt_clt_disc_all_primary_services */
  {0xfd12, aci_gatt_clt_disc_all_primary_services_process},
  /* aci_gatt_clt_disc_primary_service_by_uuid */
  {0xfd13, aci_gatt_clt_disc_primary_service_by_uuid_process},
  /* aci_gatt_clt_find_included_services */
  {0xfd14, aci_gatt_clt_find_included_services_process},
  /* aci_gatt_clt_disc_all_char_of_service */
  {0xfd15, aci_gatt_clt_disc_all_char_of_service_process},
  /* aci_gatt_clt_disc_char_by_uuid */
  {0xfd16, aci_gatt_clt_disc_char_by_uuid_process},
  /* aci_gatt_clt_disc_all_char_desc */
  {0xfd17, aci_gatt_clt_disc_all_char_desc_process},
  /* aci_gatt_clt_read */
  {0xfd18, aci_gatt_clt_read_process},
  /* aci_gatt_clt_read_using_char_uuid */
  {0xfd19, aci_gatt_clt_read_using_char_uuid_process},
  /* aci_gatt_clt_read_long */
  {0xfd1a, aci_gatt_clt_read_long_process},
  /* aci_gatt_clt_read_multiple_char_value */
  {0xfd1b, aci_gatt_clt_read_multiple_char_value_process},
  /* aci_gatt_clt_write_nwk */
  {0xfd1c, aci_gatt_clt_write_nwk_process},
  /* aci_gatt_clt_write_long_nwk */
  {0xfd1d, aci_gatt_clt_write_long_nwk_process},
  /* aci_gatt_clt_write_char_reliable_nwk */
  {0xfd1e, aci_gatt_clt_write_char_reliable_nwk_process},
  /* aci_gatt_clt_write_without_resp */
  {0xfd23, aci_gatt_clt_write_without_resp_process},
  /* aci_gatt_clt_signed_write_without_resp */
  {0xfd24, aci_gatt_clt_signed_write_without_resp_process},
  /* aci_gatt_clt_confirm_indication */
  {0xfd25, aci_gatt_clt_confirm_indication_process},
  /* aci_gatt_srv_set_security_permission_nwk */
  {0xfd28, aci_gatt_srv_set_security_permission_nwk_process},
  /* aci_gatt_srv_read_handle_value_nwk */
  {0xfd2a, aci_gatt_srv_read_handle_value_nwk_process},
  /* aci_gatt_srv_set_access_permission_nwk */
  {0xfd2e, aci_gatt_srv_set_access_permission_nwk_process},
  /* aci_gatt_srv_notify */
  {0xfd2f, aci_gatt_srv_notify_process},
  /* aci_gatt_srv_exec_write_resp_nwk */
  {0xfd31, aci_gatt_srv_exec_write_resp_nwk_process},
  /* aci_gatt_srv_authorize_resp_nwk */
  {0xfd33, aci_gatt_srv_authorize_resp_nwk_process},
  /* aci_gatt_srv_read_prepare_queue_nwk */
  {0xfd35, aci_gatt_srv_read_prepare_queue_nwk_process},
  /* aci_gatt_srv_write_multiple_instance_handle_value */
  {0xfd36, aci_gatt_srv_write_multiple_instance_handle_value_process},
  /* aci_gatt_srv_read_multiple_instance_handle_value_nwk */
  {0xfd37, aci_gatt_srv_read_multiple_instance_handle_value_nwk_process},
  /* aci_l2cap_connection_parameter_update_req */
  {0xfd81, aci_l2cap_connection_parameter_update_req_process},
  /* aci_l2cap_connection_parameter_update_resp */
  {0xfd82, aci_l2cap_connection_parameter_update_resp_process},
  /* aci_l2cap_cfc_connection_req_nwk */
  {0xfd83, aci_l2cap_cfc_connection_req_nwk_process},
  /* aci_l2cap_cfc_connection_resp_nwk */
  {0xfd84, aci_l2cap_cfc_connection_resp_nwk_process},
  /* aci_l2cap_send_flow_control_credits */
  {0xfd85, aci_l2cap_send_flow_control_credits_process},
  /* aci_l2cap_disconnect */
  {0xfd86, aci_l2cap_disconnect_process},
  /* aci_l2cap_transmit_sdu_data_nwk */
  {0xfd87, aci_l2cap_transmit_sdu_data_nwk_process},
  /* aci_test_tx_notification_start */
  {0xfe00, aci_test_tx_notification_start_process},
  /* aci_test_tx_write_command_start */
  {0xfe01, aci_test_tx_write_command_start_process},
  /* aci_test_rx_start */
  {0xfe02, aci_test_rx_start_process},
  /* aci_test_stop */
  {0xfe03, aci_test_stop_process},
  /* aci_test_report */
  {0xfe04, aci_test_report_process},
};
/* tBleStatus hci_disconnect(uint16_t Connection_Handle,
                          uint8_t Reason);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t hci_disconnect_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_disconnect_cp0 *cp0 = (hci_disconnect_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_disconnect(cp0->Connection_Handle /* 2 */,
                           cp0->Reason /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x06;
  buffer_out[6] = 0x04;
  return (output_size + 6);
}
/* tBleStatus hci_read_remote_version_information(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_read_remote_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_remote_version_information_cp0 *cp0 = (hci_read_remote_version_information_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_read_remote_version_information(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1d;
  buffer_out[6] = 0x04;
  return (output_size + 6);
}
/* tBleStatus hci_set_event_mask(uint8_t Event_Mask[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t hci_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_set_event_mask_cp0 *cp0 = (hci_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_set_event_mask(cp0->Event_Mask /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_read_transmit_power_level(uint16_t Connection_Handle,
                                         uint8_t Type,
                                         int8_t *Transmit_Power_Level);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 + 1 */
uint16_t hci_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_transmit_power_level_cp0 *cp0 = (hci_read_transmit_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1;
  /* Output params */
  hci_read_transmit_power_level_rp0 *rp0 = (hci_read_transmit_power_level_rp0 *) (buffer_out + 6);
  int8_t Transmit_Power_Level = 0;

  if (buffer_out_max_length < (1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_transmit_power_level(cp0->Connection_Handle /* 2 */,
                                              cp0->Type /* 1 */,
                                              &Transmit_Power_Level);
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Transmit_Power_Level = Transmit_Power_Level;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2d;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_set_event_mask_page_2(uint8_t Event_Mask_Page_2[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t hci_set_event_mask_page_2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_set_event_mask_page_2_cp0 *cp0 = (hci_set_event_mask_page_2_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_set_event_mask_page_2(cp0->Event_Mask_Page_2 /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x63;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
/* tBleStatus hci_read_authenticated_payload_timeout(uint16_t Connection_Handle,
                                                  uint16_t *Authenticated_Payload_Timeout);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 2 */
uint16_t hci_read_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_authenticated_payload_timeout_cp0 *cp0 = (hci_read_authenticated_payload_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 2;
  /* Output params */
  hci_read_authenticated_payload_timeout_rp0 *rp0 = (hci_read_authenticated_payload_timeout_rp0 *) (buffer_out + 6);
  uint16_t Authenticated_Payload_Timeout = 0;

  if (buffer_out_max_length < (1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_authenticated_payload_timeout(cp0->Connection_Handle /* 2 */,
                                                       &Authenticated_Payload_Timeout);
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->Authenticated_Payload_Timeout = Authenticated_Payload_Timeout;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7b;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
/* tBleStatus hci_write_authenticated_payload_timeout(uint16_t Connection_Handle,
                                                   uint16_t Authenticated_Payload_Timeout);
 */
/* Command len: 2 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_write_authenticated_payload_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_write_authenticated_payload_timeout_cp0 *cp0 = (hci_write_authenticated_payload_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_write_authenticated_payload_timeout_rp0 *rp0 = (hci_write_authenticated_payload_timeout_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_write_authenticated_payload_timeout(cp0->Connection_Handle /* 2 */,
                                                        cp0->Authenticated_Payload_Timeout /* 2 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7c;
  buffer_out[5] = 0x0c;
  return (output_size + 6);
}
/* tBleStatus hci_read_local_version_information(uint8_t *HCI_Version,
                                              uint16_t *HCI_Revision,
                                              uint8_t *LMP_PAL_Version,
                                              uint16_t *Manufacturer_Name,
                                              uint16_t *LMP_PAL_Subversion);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 2 + 1 + 2 + 2 */
uint16_t hci_read_local_version_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 2 + 1 + 2 + 2;
  /* Output params */
  hci_read_local_version_information_rp0 *rp0 = (hci_read_local_version_information_rp0 *) (buffer_out + 6);
  uint8_t HCI_Version = 0;
  uint16_t HCI_Revision = 0;
  uint8_t LMP_PAL_Version = 0;
  uint16_t Manufacturer_Name = 0;
  uint16_t LMP_PAL_Subversion = 0;

  if (buffer_out_max_length < (1 + 1 + 2 + 1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_local_version_information(&HCI_Version,
                                                   &HCI_Revision,
                                                   &LMP_PAL_Version,
                                                   &Manufacturer_Name,
                                                   &LMP_PAL_Subversion);
  rp0->HCI_Version = HCI_Version;
  rp0->HCI_Revision = HCI_Revision;
  rp0->LMP_PAL_Version = LMP_PAL_Version;
  rp0->Manufacturer_Name = Manufacturer_Name;
  rp0->LMP_PAL_Subversion = LMP_PAL_Subversion;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_read_local_supported_commands(uint8_t Supported_Commands[64]);
 */
/* Command len: 0 */
/* Response len: 1 + 64 */
uint16_t hci_read_local_supported_commands_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 64;
  /* Output params */
  hci_read_local_supported_commands_rp0 *rp0 = (hci_read_local_supported_commands_rp0 *) (buffer_out + 6);
  uint8_t Supported_Commands[64];

  if (buffer_out_max_length < (1 + 64 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_local_supported_commands(Supported_Commands);
  Osal_MemCpy((void *) rp0->Supported_Commands,(const void *) Supported_Commands, 64);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}
/* tBleStatus hci_read_local_supported_features(uint8_t LMP_Features[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_read_local_supported_features_rp0 *rp0 = (hci_read_local_supported_features_rp0 *) (buffer_out + 6);
  uint8_t LMP_Features[8];

  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_local_supported_features(LMP_Features);
  Osal_MemCpy((void *) rp0->LMP_Features,(const void *) LMP_Features, 8);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}
/* tBleStatus hci_read_bd_addr(uint8_t BD_ADDR[6]);
 */
/* Command len: 0 */
/* Response len: 1 + 6 */
uint16_t hci_read_bd_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 6;
  /* Output params */
  hci_read_bd_addr_rp0 *rp0 = (hci_read_bd_addr_rp0 *) (buffer_out + 6);
  uint8_t BD_ADDR[6];

  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_bd_addr(BD_ADDR);
  Osal_MemCpy((void *) rp0->BD_ADDR,(const void *) BD_ADDR, 6);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x09;
  buffer_out[5] = 0x10;
  return (output_size + 6);
}

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_read_rssi(uint16_t Connection_Handle,
                         int8_t *RSSI);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 1 */
uint16_t hci_read_rssi_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_read_rssi_cp0 *cp0 = (hci_read_rssi_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1;
  /* Output params */
  hci_read_rssi_rp0 *rp0 = (hci_read_rssi_rp0 *) (buffer_out + 6);
  int8_t RSSI = 0;

  if (buffer_out_max_length < (1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_read_rssi(cp0->Connection_Handle /* 2 */,
                              &RSSI);
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->RSSI = RSSI;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x14;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_event_mask(uint8_t LE_Event_Mask[8]);
 */
/* Command len: 8 */
/* Response len: 1 */
uint16_t hci_le_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_event_mask_cp0 *cp0 = (hci_le_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 8)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_event_mask(cp0->LE_Event_Mask /* 8 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_read_buffer_size(uint16_t *HC_LE_ACL_Data_Packet_Length,
                                   uint8_t *HC_Total_Num_LE_ACL_Data_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 1 */
uint16_t hci_le_read_buffer_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 1;
  /* Output params */
  hci_le_read_buffer_size_rp0 *rp0 = (hci_le_read_buffer_size_rp0 *) (buffer_out + 6);
  uint16_t HC_LE_ACL_Data_Packet_Length = 0;
  uint8_t HC_Total_Num_LE_ACL_Data_Packets = 0;

  if (buffer_out_max_length < (1 + 2 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_buffer_size(&HC_LE_ACL_Data_Packet_Length,
                                        &HC_Total_Num_LE_ACL_Data_Packets);
  rp0->HC_LE_ACL_Data_Packet_Length = HC_LE_ACL_Data_Packet_Length;
  rp0->HC_Total_Num_LE_ACL_Data_Packets = HC_Total_Num_LE_ACL_Data_Packets;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_local_supported_features(uint8_t LE_Features[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_le_read_local_supported_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_le_read_local_supported_features_rp0 *rp0 = (hci_le_read_local_supported_features_rp0 *) (buffer_out + 6);
  uint8_t LE_Features[8];

  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_local_supported_features(LE_Features);
  Osal_MemCpy((void *) rp0->LE_Features,(const void *) LE_Features, 8);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_random_address(uint8_t Random_Address[6]);
 */
/* Command len: 6 */
/* Response len: 1 */
uint16_t hci_le_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_random_address_cp0 *cp0 = (hci_le_set_random_address_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_random_address(cp0->Random_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_advertising_parameters(uint16_t Advertising_Interval_Min,
                                             uint16_t Advertising_Interval_Max,
                                             uint8_t Advertising_Type,
                                             uint8_t Own_Address_Type,
                                             uint8_t Peer_Address_Type,
                                             uint8_t Peer_Address[6],
                                             uint8_t Advertising_Channel_Map,
                                             uint8_t Advertising_Filter_Policy);
 */
/* Command len: 2 + 2 + 1 + 1 + 1 + 6 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_parameters_cp0 *cp0 = (hci_le_set_advertising_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 1 + 1 + 6 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_advertising_parameters(cp0->Advertising_Interval_Min /* 2 */,
                                              cp0->Advertising_Interval_Max /* 2 */,
                                              cp0->Advertising_Type /* 1 */,
                                              cp0->Own_Address_Type /* 1 */,
                                              cp0->Peer_Address_Type /* 1 */,
                                              cp0->Peer_Address /* 6 */,
                                              cp0->Advertising_Channel_Map /* 1 */,
                                              cp0->Advertising_Filter_Policy /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x06;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_advertising_channel_tx_power(int8_t *Transmit_Power_Level);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_advertising_channel_tx_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_advertising_channel_tx_power_rp0 *rp0 = (hci_le_read_advertising_channel_tx_power_rp0 *) (buffer_out + 6);
  int8_t Transmit_Power_Level = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_advertising_channel_tx_power(&Transmit_Power_Level);
  rp0->Transmit_Power_Level = Transmit_Power_Level;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_advertising_data(uint8_t Advertising_Data_Length,
                                       uint8_t Advertising_Data[31]);
 */
/* Command len: 1 + 31 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_data_cp0 *cp0 = (hci_le_set_advertising_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 31)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_advertising_data(cp0->Advertising_Data_Length /* 1 */,
                                        cp0->Advertising_Data /* 31 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x08;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_scan_response_data(uint8_t Scan_Response_Data_Length,
                                         uint8_t Scan_Response_Data[31]);
 */
/* Command len: 1 + 31 */
/* Response len: 1 */
uint16_t hci_le_set_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_scan_response_data_cp0 *cp0 = (hci_le_set_scan_response_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 31)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_scan_response_data(cp0->Scan_Response_Data_Length /* 1 */,
                                          cp0->Scan_Response_Data /* 31 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x09;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_advertising_enable(uint8_t Advertising_Enable);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_enable_cp0 *cp0 = (hci_le_set_advertising_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_advertising_enable(cp0->Advertising_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_scan_parameters(uint8_t LE_Scan_Type,
                                      uint16_t LE_Scan_Interval,
                                      uint16_t LE_Scan_Window,
                                      uint8_t Own_Address_Type,
                                      uint8_t Scanning_Filter_Policy);
 */
/* Command len: 1 + 2 + 2 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_scan_parameters_cp0 *cp0 = (hci_le_set_scan_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_scan_parameters(cp0->LE_Scan_Type /* 1 */,
                                       cp0->LE_Scan_Interval /* 2 */,
                                       cp0->LE_Scan_Window /* 2 */,
                                       cp0->Own_Address_Type /* 1 */,
                                       cp0->Scanning_Filter_Policy /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_scan_enable(uint8_t LE_Scan_Enable,
                                  uint8_t Filter_Duplicates);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_scan_enable_cp0 *cp0 = (hci_le_set_scan_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_scan_enable(cp0->LE_Scan_Enable /* 1 */,
                                   cp0->Filter_Duplicates /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_create_connection(uint16_t LE_Scan_Interval,
                                    uint16_t LE_Scan_Window,
                                    uint8_t Initiator_Filter_Policy,
                                    uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6],
                                    uint8_t Own_Address_Type,
                                    uint16_t Conn_Interval_Min,
                                    uint16_t Conn_Interval_Max,
                                    uint16_t Conn_Latency,
                                    uint16_t Supervision_Timeout,
                                    uint16_t Minimum_CE_Length,
                                    uint16_t Maximum_CE_Length);
 */
/* Command len: 2 + 2 + 1 + 1 + 6 + 1 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_create_connection_cp0 *cp0 = (hci_le_create_connection_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 1 + 6 + 1 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_create_connection(cp0->LE_Scan_Interval /* 2 */,
                                     cp0->LE_Scan_Window /* 2 */,
                                     cp0->Initiator_Filter_Policy /* 1 */,
                                     cp0->Peer_Address_Type /* 1 */,
                                     cp0->Peer_Address /* 6 */,
                                     cp0->Own_Address_Type /* 1 */,
                                     cp0->Conn_Interval_Min /* 2 */,
                                     cp0->Conn_Interval_Max /* 2 */,
                                     cp0->Conn_Latency /* 2 */,
                                     cp0->Supervision_Timeout /* 2 */,
                                     cp0->Minimum_CE_Length /* 2 */,
                                     cp0->Maximum_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0d;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_create_connection_cancel(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_create_connection_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_create_connection_cancel();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_white_list_size(uint8_t *White_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_white_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_white_list_size_rp0 *rp0 = (hci_le_read_white_list_size_rp0 *) (buffer_out + 6);
  uint8_t White_List_Size = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_white_list_size(&White_List_Size);
  rp0->White_List_Size = White_List_Size;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_clear_white_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_white_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_clear_white_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x10;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_add_device_to_white_list(uint8_t Address_Type,
                                           uint8_t Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_add_device_to_white_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_add_device_to_white_list_cp0 *cp0 = (hci_le_add_device_to_white_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_add_device_to_white_list(cp0->Address_Type /* 1 */,
                                            cp0->Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x11;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_remove_device_from_white_list(uint8_t Address_Type,
                                                uint8_t Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_remove_device_from_white_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_device_from_white_list_cp0 *cp0 = (hci_le_remove_device_from_white_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_remove_device_from_white_list(cp0->Address_Type /* 1 */,
                                                 cp0->Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x12;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_connection_update(uint16_t Connection_Handle,
                                    uint16_t Conn_Interval_Min,
                                    uint16_t Conn_Interval_Max,
                                    uint16_t Conn_Latency,
                                    uint16_t Supervision_Timeout,
                                    uint16_t Minimum_CE_Length,
                                    uint16_t Maximum_CE_Length);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_connection_update_cp0 *cp0 = (hci_le_connection_update_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_connection_update(cp0->Connection_Handle /* 2 */,
                                     cp0->Conn_Interval_Min /* 2 */,
                                     cp0->Conn_Interval_Max /* 2 */,
                                     cp0->Conn_Latency /* 2 */,
                                     cp0->Supervision_Timeout /* 2 */,
                                     cp0->Minimum_CE_Length /* 2 */,
                                     cp0->Maximum_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x13;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}

#endif 

/* tBleStatus hci_le_set_host_channel_classification(uint8_t LE_Channel_Map[5]);
 */
/* Command len: 5 */
/* Response len: 1 */
uint16_t hci_le_set_host_channel_classification_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_host_channel_classification_cp0 *cp0 = (hci_le_set_host_channel_classification_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 5)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_host_channel_classification(cp0->LE_Channel_Map /* 5 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x14;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_read_channel_map(uint16_t Connection_Handle,
                                   uint8_t LE_Channel_Map[5]);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 5 */
uint16_t hci_le_read_channel_map_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_channel_map_cp0 *cp0 = (hci_le_read_channel_map_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 5;
  /* Output params */
  hci_le_read_channel_map_rp0 *rp0 = (hci_le_read_channel_map_rp0 *) (buffer_out + 6);
  uint8_t LE_Channel_Map[5];

  if (buffer_out_max_length < (1 + 2 + 5 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_channel_map(cp0->Connection_Handle /* 2 */,
                                        LE_Channel_Map);
  rp0->Connection_Handle = cp0->Connection_Handle;
  Osal_MemCpy((void *) rp0->LE_Channel_Map,(const void *) LE_Channel_Map, 5);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x15;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_read_remote_used_features(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_read_remote_used_features_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_remote_used_features_cp0 *cp0 = (hci_le_read_remote_used_features_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_read_remote_used_features(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x16;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_encrypt(uint8_t Key[16],
                          uint8_t Plaintext_Data[16],
                          uint8_t Encrypted_Data[16]);
 */
/* Command len: 16 + 16 */
/* Response len: 1 + 16 */
uint16_t hci_le_encrypt_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_encrypt_cp0 *cp0 = (hci_le_encrypt_cp0 *)(buffer_in + (0));

  int output_size = 1 + 16;
  /* Output params */
  hci_le_encrypt_rp0 *rp0 = (hci_le_encrypt_rp0 *) (buffer_out + 6);
  uint8_t Encrypted_Data[16];

  if (buffer_out_max_length < (1 + 16 + 6)) { return 0; }
  if(buffer_in_length != 16 + 16)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_encrypt(cp0->Key /* 16 */,
                               cp0->Plaintext_Data /* 16 */,
                               Encrypted_Data);
  Osal_MemCpy((void *) rp0->Encrypted_Data,(const void *) Encrypted_Data, 16);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x17;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_rand(uint8_t Random_Number[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_le_rand_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_le_rand_rp0 *rp0 = (hci_le_rand_rp0 *) (buffer_out + 6);
  uint8_t Random_Number[8];

  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_rand(Random_Number);
  Osal_MemCpy((void *) rp0->Random_Number,(const void *) Random_Number, 8);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x18;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif
#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_start_encryption(uint16_t Connection_Handle,
                                   uint8_t Random_Number[8],
                                   uint16_t Encrypted_Diversifier,
                                   uint8_t Long_Term_Key[16]);
 */
/* Command len: 2 + 8 + 2 + 16 */
/* Response len: 1 */
uint16_t hci_le_start_encryption_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_start_encryption_cp0 *cp0 = (hci_le_start_encryption_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 8 + 2 + 16)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_start_encryption(cp0->Connection_Handle /* 2 */,
                                    cp0->Random_Number /* 8 */,
                                    cp0->Encrypted_Diversifier /* 2 */,
                                    cp0->Long_Term_Key /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x19;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_long_term_key_request_reply(uint16_t Connection_Handle,
                                              uint8_t Long_Term_Key[16]);
 */
/* Command len: 2 + 16 */
/* Response len: 1 + 2 */
uint16_t hci_le_long_term_key_request_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_long_term_key_request_reply_cp0 *cp0 = (hci_le_long_term_key_request_reply_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_long_term_key_request_reply_rp0 *rp0 = (hci_le_long_term_key_request_reply_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 16)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_long_term_key_request_reply(cp0->Connection_Handle /* 2 */,
                                                   cp0->Long_Term_Key /* 16 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_long_term_key_requested_negative_reply(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_long_term_key_requested_negative_reply_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_long_term_key_requested_negative_reply_cp0 *cp0 = (hci_le_long_term_key_requested_negative_reply_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_long_term_key_requested_negative_reply_rp0 *rp0 = (hci_le_long_term_key_requested_negative_reply_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_long_term_key_requested_negative_reply(cp0->Connection_Handle /* 2 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_supported_states(uint8_t LE_States[8]);
 */
/* Command len: 0 */
/* Response len: 1 + 8 */
uint16_t hci_le_read_supported_states_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 8;
  /* Output params */
  hci_le_read_supported_states_rp0 *rp0 = (hci_le_read_supported_states_rp0 *) (buffer_out + 6);
  uint8_t LE_States[8];

  if (buffer_out_max_length < (1 + 8 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_supported_states(LE_States);
  Osal_MemCpy((void *) rp0->LE_States,(const void *) LE_States, 8);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif //#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_receiver_test(uint8_t RX_Frequency);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_receiver_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_receiver_test_cp0 *cp0 = (hci_le_receiver_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_receiver_test(cp0->RX_Frequency /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_transmitter_test(uint8_t TX_Frequency,
                                   uint8_t Length_Of_Test_Data,
                                   uint8_t Packet_Payload);
 */
/* Command len: 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_cp0 *cp0 = (hci_le_transmitter_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_transmitter_test(cp0->TX_Frequency /* 1 */,
                                    cp0->Length_Of_Test_Data /* 1 */,
                                    cp0->Packet_Payload /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_test_end(uint16_t *Number_Of_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t hci_le_test_end_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  hci_le_test_end_rp0 *rp0 = (hci_le_test_end_rp0 *) (buffer_out + 6);
  uint16_t Number_Of_Packets = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_test_end(&Number_Of_Packets);
  rp0->Number_Of_Packets = Number_Of_Packets;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_data_length(uint16_t Connection_Handle,
                                  uint16_t TxOctets,
                                  uint16_t TxTime);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_data_length_cp0 *cp0 = (hci_le_set_data_length_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_data_length_rp0 *rp0 = (hci_le_set_data_length_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_data_length(cp0->Connection_Handle /* 2 */,
                                       cp0->TxOctets /* 2 */,
                                       cp0->TxTime /* 2 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x22;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_read_suggested_default_data_length(uint16_t *SuggestedMaxTxOctets,
                                                     uint16_t *SuggestedMaxTxTime);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 */
uint16_t hci_le_read_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2;
  /* Output params */
  hci_le_read_suggested_default_data_length_rp0 *rp0 = (hci_le_read_suggested_default_data_length_rp0 *) (buffer_out + 6);
  uint16_t SuggestedMaxTxOctets = 0;
  uint16_t SuggestedMaxTxTime = 0;

  if (buffer_out_max_length < (1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_suggested_default_data_length(&SuggestedMaxTxOctets,
                                                          &SuggestedMaxTxTime);
  rp0->SuggestedMaxTxOctets = SuggestedMaxTxOctets;
  rp0->SuggestedMaxTxTime = SuggestedMaxTxTime;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x23;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif
/* tBleStatus hci_le_write_suggested_default_data_length(uint16_t SuggestedMaxTxOctets,
                                                      uint16_t SuggestedMaxTxTime);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_write_suggested_default_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_write_suggested_default_data_length_cp0 *cp0 = (hci_le_write_suggested_default_data_length_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_write_suggested_default_data_length(cp0->SuggestedMaxTxOctets /* 2 */,
                                                       cp0->SuggestedMaxTxTime /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x24;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_local_p256_public_key(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_read_local_p256_public_key_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_read_local_p256_public_key();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x25;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_generate_dhkey(uint8_t Remote_P256_Public_Key[64]);
 */
/* Command len: 64 */
/* Response len: 1 */
uint16_t hci_le_generate_dhkey_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_generate_dhkey_cp0 *cp0 = (hci_le_generate_dhkey_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 64)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_generate_dhkey(cp0->Remote_P256_Public_Key /* 64 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x26;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_add_device_to_resolving_list(uint8_t Peer_Identity_Address_Type,
                                               uint8_t Peer_Identity_Address[6],
                                               uint8_t Peer_IRK[16],
                                               uint8_t Local_IRK[16]);
 */
/* Command len: 1 + 6 + 16 + 16 */
/* Response len: 1 */
uint16_t hci_le_add_device_to_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_add_device_to_resolving_list_cp0 *cp0 = (hci_le_add_device_to_resolving_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 16 + 16)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_add_device_to_resolving_list(cp0->Peer_Identity_Address_Type /* 1 */,
                                                cp0->Peer_Identity_Address /* 6 */,
                                                cp0->Peer_IRK /* 16 */,
                                                cp0->Local_IRK /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x27;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_remove_device_from_resolving_list(uint8_t Peer_Identity_Address_Type,
                                                    uint8_t Peer_Identity_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_remove_device_from_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_device_from_resolving_list_cp0 *cp0 = (hci_le_remove_device_from_resolving_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_remove_device_from_resolving_list(cp0->Peer_Identity_Address_Type /* 1 */,
                                                     cp0->Peer_Identity_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x28;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_clear_resolving_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_clear_resolving_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x29;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_resolving_list_size(uint8_t *Resolving_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_resolving_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_resolving_list_size_rp0 *rp0 = (hci_le_read_resolving_list_size_rp0 *) (buffer_out + 6);
  uint8_t Resolving_List_Size = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_resolving_list_size(&Resolving_List_Size);
  rp0->Resolving_List_Size = Resolving_List_Size;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_peer_resolvable_address(uint8_t Peer_Identity_Address_Type,
                                               uint8_t Peer_Identity_Address[6],
                                               uint8_t Peer_Resolvable_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 + 6 */
uint16_t hci_le_read_peer_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_peer_resolvable_address_cp0 *cp0 = (hci_le_read_peer_resolvable_address_cp0 *)(buffer_in + (0));

  int output_size = 1 + 6;
  /* Output params */
  hci_le_read_peer_resolvable_address_rp0 *rp0 = (hci_le_read_peer_resolvable_address_rp0 *) (buffer_out + 6);
  uint8_t Peer_Resolvable_Address[6];

  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_peer_resolvable_address(cp0->Peer_Identity_Address_Type /* 1 */,
                                                    cp0->Peer_Identity_Address /* 6 */,
                                                    Peer_Resolvable_Address);
  Osal_MemCpy((void *) rp0->Peer_Resolvable_Address,(const void *) Peer_Resolvable_Address, 6);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_local_resolvable_address(uint8_t Peer_Identity_Address_Type,
                                                uint8_t Peer_Identity_Address[6],
                                                uint8_t Local_Resolvable_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 + 6 */
uint16_t hci_le_read_local_resolvable_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_local_resolvable_address_cp0 *cp0 = (hci_le_read_local_resolvable_address_cp0 *)(buffer_in + (0));

  int output_size = 1 + 6;
  /* Output params */
  hci_le_read_local_resolvable_address_rp0 *rp0 = (hci_le_read_local_resolvable_address_rp0 *) (buffer_out + 6);
  uint8_t Local_Resolvable_Address[6];

  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_local_resolvable_address(cp0->Peer_Identity_Address_Type /* 1 */,
                                                     cp0->Peer_Identity_Address /* 6 */,
                                                     Local_Resolvable_Address);
  Osal_MemCpy((void *) rp0->Local_Resolvable_Address,(const void *) Local_Resolvable_Address, 6);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_address_resolution_enable(uint8_t Address_Resolution_Enable);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_set_address_resolution_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_address_resolution_enable_cp0 *cp0 = (hci_le_set_address_resolution_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_address_resolution_enable(cp0->Address_Resolution_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_resolvable_private_address_timeout(uint16_t RPA_Timeout);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_set_resolvable_private_address_timeout_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_resolvable_private_address_timeout_cp0 *cp0 = (hci_le_set_resolvable_private_address_timeout_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_resolvable_private_address_timeout(cp0->RPA_Timeout /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}

#endif //#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_read_maximum_data_length(uint16_t *supportedMaxTxOctets,
                                           uint16_t *supportedMaxTxTime,
                                           uint16_t *supportedMaxRxOctets,
                                           uint16_t *supportedMaxRxTime);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 + 2 + 2 */
uint16_t hci_le_read_maximum_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2 + 2 + 2;
  /* Output params */
  hci_le_read_maximum_data_length_rp0 *rp0 = (hci_le_read_maximum_data_length_rp0 *) (buffer_out + 6);
  uint16_t supportedMaxTxOctets = 0;
  uint16_t supportedMaxTxTime = 0;
  uint16_t supportedMaxRxOctets = 0;
  uint16_t supportedMaxRxTime = 0;

  if (buffer_out_max_length < (1 + 2 + 2 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_maximum_data_length(&supportedMaxTxOctets,
                                                &supportedMaxTxTime,
                                                &supportedMaxRxOctets,
                                                &supportedMaxRxTime);
  rp0->supportedMaxTxOctets = supportedMaxTxOctets;
  rp0->supportedMaxTxTime = supportedMaxTxTime;
  rp0->supportedMaxRxOctets = supportedMaxRxOctets;
  rp0->supportedMaxRxTime = supportedMaxRxTime;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_read_phy(uint16_t Connection_Handle,
                           uint8_t *TX_PHY,
                           uint8_t *RX_PHY);
 */
/* Command len: 2 */
/* Response len: 1 + 2 + 1 + 1 */
uint16_t hci_le_read_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_phy_cp0 *cp0 = (hci_le_read_phy_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1 + 1;
  /* Output params */
  hci_le_read_phy_rp0 *rp0 = (hci_le_read_phy_rp0 *) (buffer_out + 6);
  uint8_t TX_PHY = 0;
  uint8_t RX_PHY = 0;

  if (buffer_out_max_length < (1 + 2 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_phy(cp0->Connection_Handle /* 2 */,
                                &TX_PHY,
                                &RX_PHY);
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->TX_PHY = TX_PHY;
  rp0->RX_PHY = RX_PHY;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x30;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif 
/* tBleStatus hci_le_set_default_phy(uint8_t ALL_PHYS,
                                  uint8_t TX_PHYS,
                                  uint8_t RX_PHYS);
 */
/* Command len: 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_default_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_default_phy_cp0 *cp0 = (hci_le_set_default_phy_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_default_phy(cp0->ALL_PHYS /* 1 */,
                                   cp0->TX_PHYS /* 1 */,
                                   cp0->RX_PHYS /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x31;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_phy(uint16_t Connection_Handle,
                          uint8_t ALL_PHYS,
                          uint8_t TX_PHYS,
                          uint8_t RX_PHYS,
                          uint16_t PHY_options);
 */
/* Command len: 2 + 1 + 1 + 1 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_phy_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_phy_cp0 *cp0 = (hci_le_set_phy_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_phy(cp0->Connection_Handle /* 2 */,
                           cp0->ALL_PHYS /* 1 */,
                           cp0->TX_PHYS /* 1 */,
                           cp0->RX_PHYS /* 1 */,
                           cp0->PHY_options /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x32;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_enhanced_receiver_test(uint8_t RX_Channel,
                                         uint8_t PHY,
                                         uint8_t Modulation_index);
 */
/* Command len: 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_enhanced_receiver_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_enhanced_receiver_test_cp0 *cp0 = (hci_le_enhanced_receiver_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_enhanced_receiver_test(cp0->RX_Channel /* 1 */,
                                          cp0->PHY /* 1 */,
                                          cp0->Modulation_index /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x33;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_enhanced_transmitter_test(uint8_t TX_Channel,
                                            uint8_t Length_Of_Test_Data,
                                            uint8_t Packet_Payload,
                                            uint8_t PHY);
 */
/* Command len: 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_enhanced_transmitter_test_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_enhanced_transmitter_test_cp0 *cp0 = (hci_le_enhanced_transmitter_test_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_enhanced_transmitter_test(cp0->TX_Channel /* 1 */,
                                             cp0->Length_Of_Test_Data /* 1 */,
                                             cp0->Packet_Payload /* 1 */,
                                             cp0->PHY /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x34;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}

#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_set_advertising_set_random_address(uint8_t Advertising_Handle,
                                                     uint8_t Advertising_Random_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t hci_le_set_advertising_set_random_address_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_advertising_set_random_address_cp0 *cp0 = (hci_le_set_advertising_set_random_address_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_advertising_set_random_address(cp0->Advertising_Handle /* 1 */,
                                                      cp0->Advertising_Random_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x35;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_extended_advertising_parameters(uint8_t Advertising_Handle,
                                                      uint16_t Advertising_Event_Properties,
                                                      uint8_t Primary_Advertising_Interval_Min[3],
                                                      uint8_t Primary_Advertising_Interval_Max[3],
                                                      uint8_t Primary_Advertising_Channel_Map,
                                                      uint8_t Own_Address_Type,
                                                      uint8_t Peer_Address_Type,
                                                      uint8_t Peer_Address[6],
                                                      uint8_t Advertising_Filter_Policy,
                                                      int8_t Advertising_Tx_Power,
                                                      uint8_t Primary_Advertising_PHY,
                                                      uint8_t Secondary_Advertising_Max_Skip,
                                                      uint8_t Secondary_Advertising_PHY,
                                                      uint8_t Advertising_SID,
                                                      uint8_t Scan_Request_Notification_Enable,
                                                      int8_t *Selected_Tx_Power);
 */
/* Command len: 1 + 2 + 3 + 3 + 1 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 1 */
uint16_t hci_le_set_extended_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_parameters_cp0 *cp0 = (hci_le_set_extended_advertising_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1;
  /* Output params */
  hci_le_set_extended_advertising_parameters_rp0 *rp0 = (hci_le_set_extended_advertising_parameters_rp0 *) (buffer_out + 6);
  int8_t Selected_Tx_Power = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 3 + 3 + 1 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_extended_advertising_parameters(cp0->Advertising_Handle /* 1 */,
                                                           cp0->Advertising_Event_Properties /* 2 */,
                                                           cp0->Primary_Advertising_Interval_Min /* 3 */,
                                                           cp0->Primary_Advertising_Interval_Max /* 3 */,
                                                           cp0->Primary_Advertising_Channel_Map /* 1 */,
                                                           cp0->Own_Address_Type /* 1 */,
                                                           cp0->Peer_Address_Type /* 1 */,
                                                           cp0->Peer_Address /* 6 */,
                                                           cp0->Advertising_Filter_Policy /* 1 */,
                                                           cp0->Advertising_Tx_Power /* 1 */,
                                                           cp0->Primary_Advertising_PHY /* 1 */,
                                                           cp0->Secondary_Advertising_Max_Skip /* 1 */,
                                                           cp0->Secondary_Advertising_PHY /* 1 */,
                                                           cp0->Advertising_SID /* 1 */,
                                                           cp0->Scan_Request_Notification_Enable /* 1 */,
                                                           &Selected_Tx_Power);
  rp0->Selected_Tx_Power = Selected_Tx_Power;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x36;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_extended_advertising_data(uint8_t Advertising_Handle,
                                                uint8_t Operation,
                                                uint8_t Fragment_Preference,
                                                uint8_t Advertising_Data_Length,
                                                uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_extended_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_data_cp0 *cp0 = (hci_le_set_extended_advertising_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_extended_advertising_data(cp0->Advertising_Handle /* 1 */,
                                                 cp0->Operation /* 1 */,
                                                 cp0->Fragment_Preference /* 1 */,
                                                 cp0->Advertising_Data_Length /* 1 */,
                                                 cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x37;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_extended_scan_response_data(uint8_t Advertising_Handle,
                                                  uint8_t Operation,
                                                  uint8_t Fragment_Preference,
                                                  uint8_t Scan_Response_Data_Length,
                                                  uint8_t Scan_Response_Data[]);
 */
/* Command len: 1 + 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_extended_scan_response_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_scan_response_data_cp0 *cp0 = (hci_le_set_extended_scan_response_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_extended_scan_response_data(cp0->Advertising_Handle /* 1 */,
                                                   cp0->Operation /* 1 */,
                                                   cp0->Fragment_Preference /* 1 */,
                                                   cp0->Scan_Response_Data_Length /* 1 */,
                                                   cp0->Scan_Response_Data /* cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x38;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
tBleStatus hci_le_set_extended_advertising_enable_preprocess(uint8_t Enable,
                                                             uint8_t Number_of_Sets,
                                                             Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
/* tBleStatus hci_le_set_extended_advertising_enable(uint8_t Enable,
                                                  uint8_t Number_of_Sets,
                                                  Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
 */
/* Command len: 1 + 1 + cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)) */
/* Response len: 1 */
uint16_t hci_le_set_extended_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_advertising_enable_cp0 *cp0 = (hci_le_set_extended_advertising_enable_cp0 *)(buffer_in + (0));
  Advertising_Set_Parameters_t Advertising_Set_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Set_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  for (i = 0; i < cp0->Number_of_Sets; i++) {
    Advertising_Set_Parameters[i].Advertising_Handle = cp0->Advertising_Set_Parameters[i].Advertising_Handle;
    Advertising_Set_Parameters[i].Duration = cp0->Advertising_Set_Parameters[i].Duration;
    Advertising_Set_Parameters[i].Max_Extended_Advertising_Events = cp0->Advertising_Set_Parameters[i].Max_Extended_Advertising_Events;
  }
  if(buffer_in_length != 1 + 1 + cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_extended_advertising_enable_preprocess(cp0->Enable /* 1 */,
                                                              cp0->Number_of_Sets /* 1 */,
                                                              Advertising_Set_Parameters /* cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)) */);
  if(*status)
    goto fail;

  *status = hci_le_set_extended_advertising_enable(cp0->Enable /* 1 */,
                                                   cp0->Number_of_Sets /* 1 */,
                                                   Advertising_Set_Parameters /* cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x39;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_maximum_advertising_data_length(uint16_t *Maximum_Advertising_Data_Length);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t hci_le_read_maximum_advertising_data_length_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  hci_le_read_maximum_advertising_data_length_rp0 *rp0 = (hci_le_read_maximum_advertising_data_length_rp0 *) (buffer_out + 6);
  uint16_t Maximum_Advertising_Data_Length = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_maximum_advertising_data_length(&Maximum_Advertising_Data_Length);
  rp0->Maximum_Advertising_Data_Length = Maximum_Advertising_Data_Length;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_number_of_supported_advertising_sets(uint8_t *Num_Supported_Advertising_Sets);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_number_of_supported_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_number_of_supported_advertising_sets_rp0 *rp0 = (hci_le_read_number_of_supported_advertising_sets_rp0 *) (buffer_out + 6);
  uint8_t Num_Supported_Advertising_Sets = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_number_of_supported_advertising_sets(&Num_Supported_Advertising_Sets);
  rp0->Num_Supported_Advertising_Sets = Num_Supported_Advertising_Sets;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_remove_advertising_set(uint8_t Advertising_Handle);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t hci_le_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_advertising_set_cp0 *cp0 = (hci_le_remove_advertising_set_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_remove_advertising_set(cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_clear_advertising_sets(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_clear_advertising_sets();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_periodic_advertising_parameters(uint8_t Advertising_Handle,
                                                      uint16_t Periodic_Advertising_Interval_Min,
                                                      uint16_t Periodic_Advertising_Interval_Max,
                                                      uint16_t Periodic_Advertising_Properties);
 */
/* Command len: 1 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_parameters_cp0 *cp0 = (hci_le_set_periodic_advertising_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_parameters(cp0->Advertising_Handle /* 1 */,
                                                       cp0->Periodic_Advertising_Interval_Min /* 2 */,
                                                       cp0->Periodic_Advertising_Interval_Max /* 2 */,
                                                       cp0->Periodic_Advertising_Properties /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_periodic_advertising_data(uint8_t Advertising_Handle,
                                                uint8_t Operation,
                                                uint8_t Advertising_Data_Length,
                                                uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_data_cp0 *cp0 = (hci_le_set_periodic_advertising_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_data(cp0->Advertising_Handle /* 1 */,
                                                 cp0->Operation /* 1 */,
                                                 cp0->Advertising_Data_Length /* 1 */,
                                                 cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x3f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
tBleStatus hci_le_set_periodic_advertising_enable_preprocess(uint8_t Enable,
                                                             uint8_t Advertising_Handle);
/* tBleStatus hci_le_set_periodic_advertising_enable(uint8_t Enable,
                                                  uint8_t Advertising_Handle);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_enable_cp0 *cp0 = (hci_le_set_periodic_advertising_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_enable_preprocess(cp0->Enable /* 1 */,
                                                              cp0->Advertising_Handle /* 1 */);
  if(*status)
    goto fail;

  *status = hci_le_set_periodic_advertising_enable(cp0->Enable /* 1 */,
                                                   cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x40;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_extended_scan_parameters(uint8_t Own_Address_Type,
                                               uint8_t Scanning_Filter_Policy,
                                               uint8_t Scanning_PHYs,
                                               Extended_Scan_Parameters_t Extended_Scan_Parameters[]);
 */
/* Command len: 1 + 1 + 1 + len * (sizeof(packed_Extended_Scan_Parameters_t)) */
/* Response len: 1 */
uint16_t hci_le_set_extended_scan_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_scan_parameters_cp0 *cp0 = (hci_le_set_extended_scan_parameters_cp0 *)(buffer_in + (0));
  Extended_Scan_Parameters_t Extended_Scan_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Scan_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int len = 0;

  for (i = 0; i < sizeof( cp0->Scanning_PHYs)*8; i++) {
    if((cp0->Scanning_PHYs >> i) & 0x01){
      len++;
    }
  }
  for (i = 0; i < len; i++) {
    Extended_Scan_Parameters[i].Scan_Type = cp0->Extended_Scan_Parameters[i].Scan_Type;
    Extended_Scan_Parameters[i].Scan_Interval = cp0->Extended_Scan_Parameters[i].Scan_Interval;
    Extended_Scan_Parameters[i].Scan_Window = cp0->Extended_Scan_Parameters[i].Scan_Window;
  }
  if(buffer_in_length != 1 + 1 + 1 + len * (sizeof(packed_Extended_Scan_Parameters_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_extended_scan_parameters(cp0->Own_Address_Type /* 1 */,
                                                cp0->Scanning_Filter_Policy /* 1 */,
                                                cp0->Scanning_PHYs /* 1 */,
                                                Extended_Scan_Parameters /* len * (sizeof(packed_Extended_Scan_Parameters_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x41;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_extended_scan_enable(uint8_t Enable,
                                           uint8_t Filter_Duplicates,
                                           uint16_t Duration,
                                           uint16_t Period);
 */
/* Command len: 1 + 1 + 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_set_extended_scan_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_extended_scan_enable_cp0 *cp0 = (hci_le_set_extended_scan_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_extended_scan_enable(cp0->Enable /* 1 */,
                                            cp0->Filter_Duplicates /* 1 */,
                                            cp0->Duration /* 2 */,
                                            cp0->Period /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x42;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_extended_create_connection(uint8_t Initiating_Filter_Policy,
                                             uint8_t Own_Address_Type,
                                             uint8_t Peer_Address_Type,
                                             uint8_t Peer_Address[6],
                                             uint8_t Initiating_PHYs,
                                             Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[]);
 */
/* Command len: 1 + 1 + 1 + 6 + 1 + len * (sizeof(packed_Extended_Create_Connection_Parameters_t)) */
/* Response len: 1 */
uint16_t hci_le_extended_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_extended_create_connection_cp0 *cp0 = (hci_le_extended_create_connection_cp0 *)(buffer_in + (0));
  Extended_Create_Connection_Parameters_t Extended_Create_Connection_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Extended_Create_Connection_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  int len = 0;

  for (i = 0; i < sizeof( cp0->Initiating_PHYs)*8; i++) {
    if((cp0->Initiating_PHYs >> i) & 0x01){
      len++;
    }
  }
  for (i = 0; i < len; i++) {
    Extended_Create_Connection_Parameters[i].Scan_Interval = cp0->Extended_Create_Connection_Parameters[i].Scan_Interval;
    Extended_Create_Connection_Parameters[i].Scan_Window = cp0->Extended_Create_Connection_Parameters[i].Scan_Window;
    Extended_Create_Connection_Parameters[i].Conn_Interval_Min = cp0->Extended_Create_Connection_Parameters[i].Conn_Interval_Min;
    Extended_Create_Connection_Parameters[i].Conn_Interval_Max = cp0->Extended_Create_Connection_Parameters[i].Conn_Interval_Max;
    Extended_Create_Connection_Parameters[i].Conn_Latency = cp0->Extended_Create_Connection_Parameters[i].Conn_Latency;
    Extended_Create_Connection_Parameters[i].Supervision_Timeout = cp0->Extended_Create_Connection_Parameters[i].Supervision_Timeout;
    Extended_Create_Connection_Parameters[i].Minimum_CE_Length = cp0->Extended_Create_Connection_Parameters[i].Minimum_CE_Length;
    Extended_Create_Connection_Parameters[i].Maximum_CE_Length = cp0->Extended_Create_Connection_Parameters[i].Maximum_CE_Length;
  }
  if(buffer_in_length != 1 + 1 + 1 + 6 + 1 + len * (sizeof(packed_Extended_Create_Connection_Parameters_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_extended_create_connection(cp0->Initiating_Filter_Policy /* 1 */,
                                              cp0->Own_Address_Type /* 1 */,
                                              cp0->Peer_Address_Type /* 1 */,
                                              cp0->Peer_Address /* 6 */,
                                              cp0->Initiating_PHYs /* 1 */,
                                              Extended_Create_Connection_Parameters /* len * (sizeof(packed_Extended_Create_Connection_Parameters_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x43;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_periodic_advertising_create_sync(uint8_t Options,
                                                   uint8_t Advertising_SID,
                                                   uint8_t Advertising_Address_Type,
                                                   uint8_t Advertiser_Address[6],
                                                   uint16_t Skip,
                                                   uint16_t Sync_Timeout,
                                                   uint8_t Sync_CTE_Type);
 */
/* Command len: 1 + 1 + 1 + 6 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_periodic_advertising_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_create_sync_cp0 *cp0 = (hci_le_periodic_advertising_create_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 6 + 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_periodic_advertising_create_sync(cp0->Options /* 1 */,
                                                    cp0->Advertising_SID /* 1 */,
                                                    cp0->Advertising_Address_Type /* 1 */,
                                                    cp0->Advertiser_Address /* 6 */,
                                                    cp0->Skip /* 2 */,
                                                    cp0->Sync_Timeout /* 2 */,
                                                    cp0->Sync_CTE_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x44;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_periodic_advertising_create_sync_cancel(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_periodic_advertising_create_sync_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_periodic_advertising_create_sync_cancel();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x45;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_periodic_advertising_terminate_sync(uint16_t Sync_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t hci_le_periodic_advertising_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_terminate_sync_cp0 *cp0 = (hci_le_periodic_advertising_terminate_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_periodic_advertising_terminate_sync(cp0->Sync_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x46;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_add_device_to_periodic_advertiser_list(uint8_t Advertiser_Address_Type,
                                                         uint8_t Advertiser_Address[6],
                                                         uint8_t Advertising_SID);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t hci_le_add_device_to_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_add_device_to_periodic_advertiser_list_cp0 *cp0 = (hci_le_add_device_to_periodic_advertiser_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_add_device_to_periodic_advertiser_list(cp0->Advertiser_Address_Type /* 1 */,
                                                          cp0->Advertiser_Address /* 6 */,
                                                          cp0->Advertising_SID /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x47;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_remove_device_from_periodic_advertising_list(uint8_t Advertiser_Address_Type,
                                                               uint8_t Advertiser_Address[6],
                                                               uint8_t Advertising_SID);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t hci_le_remove_device_from_periodic_advertising_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_remove_device_from_periodic_advertising_list_cp0 *cp0 = (hci_le_remove_device_from_periodic_advertising_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_remove_device_from_periodic_advertising_list(cp0->Advertiser_Address_Type /* 1 */,
                                                                cp0->Advertiser_Address /* 6 */,
                                                                cp0->Advertising_SID /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x48;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_clear_periodic_advertiser_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t hci_le_clear_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_clear_periodic_advertiser_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x49;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_periodic_advertiser_list_size(uint8_t *Periodic_Advertiser_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t hci_le_read_periodic_advertiser_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  hci_le_read_periodic_advertiser_list_size_rp0 *rp0 = (hci_le_read_periodic_advertiser_list_size_rp0 *) (buffer_out + 6);
  uint8_t Periodic_Advertiser_List_Size = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_periodic_advertiser_list_size(&Periodic_Advertiser_List_Size);
  rp0->Periodic_Advertiser_List_Size = Periodic_Advertiser_List_Size;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_transmit_power(int8_t *Min_Tx_Power,
                                      int8_t *Max_Tx_Power);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 */
uint16_t hci_le_read_transmit_power_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1;
  /* Output params */
  hci_le_read_transmit_power_rp0 *rp0 = (hci_le_read_transmit_power_rp0 *) (buffer_out + 6);
  int8_t Min_Tx_Power = 0;
  int8_t Max_Tx_Power = 0;

  if (buffer_out_max_length < (1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_transmit_power(&Min_Tx_Power,
                                           &Max_Tx_Power);
  rp0->Min_Tx_Power = Min_Tx_Power;
  rp0->Max_Tx_Power = Max_Tx_Power;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_rf_path_compensation(int16_t *RF_TX_Path_Compensation_Value,
                                            int16_t *RF_RX_Path_Compensation_Value);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 */
uint16_t hci_le_read_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2;
  /* Output params */
  hci_le_read_rf_path_compensation_rp0 *rp0 = (hci_le_read_rf_path_compensation_rp0 *) (buffer_out + 6);
  int16_t RF_TX_Path_Compensation_Value = 0;
  int16_t RF_RX_Path_Compensation_Value = 0;

  if (buffer_out_max_length < (1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_rf_path_compensation(&RF_TX_Path_Compensation_Value,
                                                 &RF_RX_Path_Compensation_Value);
  rp0->RF_TX_Path_Compensation_Value = RF_TX_Path_Compensation_Value;
  rp0->RF_RX_Path_Compensation_Value = RF_RX_Path_Compensation_Value;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_write_rf_path_compensation(int16_t RF_TX_Path_Compensation_Value,
                                             int16_t RF_RX_Path_Compensation_Value);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t hci_le_write_rf_path_compensation_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_write_rf_path_compensation_cp0 *cp0 = (hci_le_write_rf_path_compensation_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_write_rf_path_compensation(cp0->RF_TX_Path_Compensation_Value /* 2 */,
                                              cp0->RF_RX_Path_Compensation_Value /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_privacy_mode(uint8_t Peer_Identity_Address_Type,
                                   uint8_t Peer_Identity_Address[6],
                                   uint8_t Privacy_Mode);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_privacy_mode_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_privacy_mode_cp0 *cp0 = (hci_le_set_privacy_mode_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_privacy_mode(cp0->Peer_Identity_Address_Type /* 1 */,
                                    cp0->Peer_Identity_Address /* 6 */,
                                    cp0->Privacy_Mode /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4e;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_receiver_test_v3(uint8_t RX_Channel,
                                   uint8_t PHY,
                                   uint8_t Modulation_Index,
                                   uint8_t Expected_CTE_Length,
                                   uint8_t Expected_CTE_Type,
                                   uint8_t Slot_Durations,
                                   uint8_t Switching_Pattern_Length,
                                   uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_receiver_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_receiver_test_v3_cp0 *cp0 = (hci_le_receiver_test_v3_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_receiver_test_v3(cp0->RX_Channel /* 1 */,
                                    cp0->PHY /* 1 */,
                                    cp0->Modulation_Index /* 1 */,
                                    cp0->Expected_CTE_Length /* 1 */,
                                    cp0->Expected_CTE_Type /* 1 */,
                                    cp0->Slot_Durations /* 1 */,
                                    cp0->Switching_Pattern_Length /* 1 */,
                                    cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x4f;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_transmitter_test_v3(uint8_t TX_Channel,
                                      uint8_t Test_Data_Length,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY,
                                      uint8_t CTE_Length,
                                      uint8_t CTE_Type,
                                      uint8_t Switching_Pattern_Length,
                                      uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_v3_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_v3_cp0 *cp0 = (hci_le_transmitter_test_v3_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_transmitter_test_v3(cp0->TX_Channel /* 1 */,
                                       cp0->Test_Data_Length /* 1 */,
                                       cp0->Packet_Payload /* 1 */,
                                       cp0->PHY /* 1 */,
                                       cp0->CTE_Length /* 1 */,
                                       cp0->CTE_Type /* 1 */,
                                       cp0->Switching_Pattern_Length /* 1 */,
                                       cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x50;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_connectionless_cte_transmit_parameters(uint8_t Advertising_Handle,
                                                             uint8_t CTE_Length,
                                                             uint8_t CTE_Type,
                                                             uint8_t CTE_Count,
                                                             uint8_t Switching_Pattern_Length,
                                                             uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t hci_le_set_connectionless_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connectionless_cte_transmit_parameters_cp0 *cp0 = (hci_le_set_connectionless_cte_transmit_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_connectionless_cte_transmit_parameters(cp0->Advertising_Handle /* 1 */,
                                                              cp0->CTE_Length /* 1 */,
                                                              cp0->CTE_Type /* 1 */,
                                                              cp0->CTE_Count /* 1 */,
                                                              cp0->Switching_Pattern_Length /* 1 */,
                                                              cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x51;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_connectionless_cte_transmit_enable(uint8_t Advertising_Handle,
                                                         uint8_t CTE_Enable);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_connectionless_cte_transmit_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connectionless_cte_transmit_enable_cp0 *cp0 = (hci_le_set_connectionless_cte_transmit_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_connectionless_cte_transmit_enable(cp0->Advertising_Handle /* 1 */,
                                                          cp0->CTE_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x52;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_connectionless_iq_sampling_enable(uint16_t Sync_Handle,
                                                        uint8_t Sampling_Enable,
                                                        uint8_t Slot_Durations,
                                                        uint8_t Max_Sampled_CTEs,
                                                        uint8_t Switching_Pattern_Length,
                                                        uint8_t Antenna_IDs[]);
 */
/* Command len: 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_connectionless_iq_sampling_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connectionless_iq_sampling_enable_cp0 *cp0 = (hci_le_set_connectionless_iq_sampling_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_connectionless_iq_sampling_enable_rp0 *rp0 = (hci_le_set_connectionless_iq_sampling_enable_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_connectionless_iq_sampling_enable(cp0->Sync_Handle /* 2 */,
                                                             cp0->Sampling_Enable /* 1 */,
                                                             cp0->Slot_Durations /* 1 */,
                                                             cp0->Max_Sampled_CTEs /* 1 */,
                                                             cp0->Switching_Pattern_Length /* 1 */,
                                                             cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
  rp0->Sync_Handle = cp0->Sync_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x53;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_connection_cte_receive_parameters(uint16_t Connection_Handle,
                                                        uint8_t Sampling_Enable,
                                                        uint8_t Slot_Durations,
                                                        uint8_t Switching_Pattern_Length,
                                                        uint8_t Antenna_IDs[]);
 */
/* Command len: 2 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_connection_cte_receive_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connection_cte_receive_parameters_cp0 *cp0 = (hci_le_set_connection_cte_receive_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_connection_cte_receive_parameters_rp0 *rp0 = (hci_le_set_connection_cte_receive_parameters_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_connection_cte_receive_parameters(cp0->Connection_Handle /* 2 */,
                                                             cp0->Sampling_Enable /* 1 */,
                                                             cp0->Slot_Durations /* 1 */,
                                                             cp0->Switching_Pattern_Length /* 1 */,
                                                             cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x54;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_connection_cte_transmit_parameters(uint16_t Connection_Handle,
                                                         uint8_t CTE_Type,
                                                         uint8_t Switching_Pattern_Length,
                                                         uint8_t Antenna_IDs[]);
 */
/* Command len: 2 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 + 2 */
uint16_t hci_le_set_connection_cte_transmit_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_connection_cte_transmit_parameters_cp0 *cp0 = (hci_le_set_connection_cte_transmit_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_connection_cte_transmit_parameters_rp0 *rp0 = (hci_le_set_connection_cte_transmit_parameters_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_connection_cte_transmit_parameters(cp0->Connection_Handle /* 2 */,
                                                              cp0->CTE_Type /* 1 */,
                                                              cp0->Switching_Pattern_Length /* 1 */,
                                                              cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x55;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_connection_cte_request_enable(uint16_t Connection_Handle,
                                                uint8_t Enable,
                                                uint16_t CTE_Request_Interval,
                                                uint8_t Requested_CTE_Length,
                                                uint8_t Requested_CTE_Type);
 */
/* Command len: 2 + 1 + 2 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_connection_cte_request_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_connection_cte_request_enable_cp0 *cp0 = (hci_le_connection_cte_request_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_connection_cte_request_enable_rp0 *rp0 = (hci_le_connection_cte_request_enable_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_connection_cte_request_enable(cp0->Connection_Handle /* 2 */,
                                                     cp0->Enable /* 1 */,
                                                     cp0->CTE_Request_Interval /* 2 */,
                                                     cp0->Requested_CTE_Length /* 1 */,
                                                     cp0->Requested_CTE_Type /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x56;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_connection_cte_response_enable(uint16_t Connection_Handle,
                                                 uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_connection_cte_response_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_connection_cte_response_enable_cp0 *cp0 = (hci_le_connection_cte_response_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_connection_cte_response_enable_rp0 *rp0 = (hci_le_connection_cte_response_enable_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_connection_cte_response_enable(cp0->Connection_Handle /* 2 */,
                                                      cp0->Enable /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x57;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_antenna_information(uint8_t *Supported_Switching_Sampling_Rates,
                                           uint8_t *Num_Antennae,
                                           uint8_t *Max_Switching_Pattern_Length,
                                           uint8_t *Max_CTE_Length);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 + 1 + 1 */
uint16_t hci_le_read_antenna_information_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1 + 1 + 1;
  /* Output params */
  hci_le_read_antenna_information_rp0 *rp0 = (hci_le_read_antenna_information_rp0 *) (buffer_out + 6);
  uint8_t Supported_Switching_Sampling_Rates = 0;
  uint8_t Num_Antennae = 0;
  uint8_t Max_Switching_Pattern_Length = 0;
  uint8_t Max_CTE_Length = 0;

  if (buffer_out_max_length < (1 + 1 + 1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_read_antenna_information(&Supported_Switching_Sampling_Rates,
                                                &Num_Antennae,
                                                &Max_Switching_Pattern_Length,
                                                &Max_CTE_Length);
  rp0->Supported_Switching_Sampling_Rates = Supported_Switching_Sampling_Rates;
  rp0->Num_Antennae = Num_Antennae;
  rp0->Max_Switching_Pattern_Length = Max_Switching_Pattern_Length;
  rp0->Max_CTE_Length = Max_CTE_Length;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x58;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#ifndef CONFIG_NO_HCI_COMMANDS

/* tBleStatus hci_le_set_periodic_advertising_receive_enable(uint16_t Sync_Handle,
                                                          uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_periodic_advertising_receive_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_receive_enable_cp0 *cp0 = (hci_le_set_periodic_advertising_receive_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_periodic_advertising_receive_enable(cp0->Sync_Handle /* 2 */,
                                                           cp0->Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x59;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_periodic_advertising_sync_transfer(uint16_t Connection_Handle,
                                                     uint16_t Service_Data,
                                                     uint16_t Sync_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_periodic_advertising_sync_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_sync_transfer_cp0 *cp0 = (hci_le_periodic_advertising_sync_transfer_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_periodic_advertising_sync_transfer_rp0 *rp0 = (hci_le_periodic_advertising_sync_transfer_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_periodic_advertising_sync_transfer(cp0->Connection_Handle /* 2 */,
                                                          cp0->Service_Data /* 2 */,
                                                          cp0->Sync_Handle /* 2 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_periodic_advertising_set_info_transfer(uint16_t Connection_Handle,
                                                         uint16_t Service_Data,
                                                         uint8_t Advertising_Handle);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_periodic_advertising_set_info_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_periodic_advertising_set_info_transfer_cp0 *cp0 = (hci_le_periodic_advertising_set_info_transfer_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_periodic_advertising_set_info_transfer_rp0 *rp0 = (hci_le_periodic_advertising_set_info_transfer_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_periodic_advertising_set_info_transfer(cp0->Connection_Handle /* 2 */,
                                                              cp0->Service_Data /* 2 */,
                                                              cp0->Advertising_Handle /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_periodic_advertising_sync_transfer_parameters(uint16_t Connection_Handle,
                                                                    uint8_t Mode,
                                                                    uint16_t Skip,
                                                                    uint16_t Sync_Timeout,
                                                                    uint8_t CTE_Type);
 */
/* Command len: 2 + 1 + 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_periodic_advertising_sync_transfer_parameters_cp0 *cp0 = (hci_le_set_periodic_advertising_sync_transfer_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_periodic_advertising_sync_transfer_parameters_rp0 *rp0 = (hci_le_set_periodic_advertising_sync_transfer_parameters_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_periodic_advertising_sync_transfer_parameters(cp0->Connection_Handle /* 2 */,
                                                                         cp0->Mode /* 1 */,
                                                                         cp0->Skip /* 2 */,
                                                                         cp0->Sync_Timeout /* 2 */,
                                                                         cp0->CTE_Type /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5c;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_default_periodic_advertising_sync_transfer_parameters(uint8_t Mode,
                                                                            uint16_t Skip,
                                                                            uint16_t Sync_Timeout,
                                                                            uint8_t CTE_Type);
 */
/* Command len: 1 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_set_default_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0 *cp0 = (hci_le_set_default_periodic_advertising_sync_transfer_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_set_default_periodic_advertising_sync_transfer_parameters(cp0->Mode /* 1 */,
                                                                             cp0->Skip /* 2 */,
                                                                             cp0->Sync_Timeout /* 2 */,
                                                                             cp0->CTE_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x5d;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
#endif //#ifndef CONFIG_NO_HCI_COMMANDS
/* tBleStatus hci_le_enhanced_read_transmit_power_level(uint16_t Connection_Handle,
                                                     uint8_t PHY,
                                                     int8_t *Current_Transmit_Power_Level,
                                                     int8_t *Max_Transmit_Power_Level);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 + 1 + 1 + 1 */
uint16_t hci_le_enhanced_read_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_enhanced_read_transmit_power_level_cp0 *cp0 = (hci_le_enhanced_read_transmit_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 1 + 1 + 1;
  /* Output params */
  hci_le_enhanced_read_transmit_power_level_rp0 *rp0 = (hci_le_enhanced_read_transmit_power_level_rp0 *) (buffer_out + 6);
  int8_t Current_Transmit_Power_Level = 0;
  int8_t Max_Transmit_Power_Level = 0;

  if (buffer_out_max_length < (1 + 2 + 1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_enhanced_read_transmit_power_level(cp0->Connection_Handle /* 2 */,
                                                          cp0->PHY /* 1 */,
                                                          &Current_Transmit_Power_Level,
                                                          &Max_Transmit_Power_Level);
  rp0->Connection_Handle = cp0->Connection_Handle;
  rp0->PHY = cp0->PHY;
  rp0->Current_Transmit_Power_Level = Current_Transmit_Power_Level;
  rp0->Max_Transmit_Power_Level = Max_Transmit_Power_Level;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x76;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_read_remote_transmit_power_level(uint16_t Connection_Handle,
                                                   uint8_t PHY);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t hci_le_read_remote_transmit_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_read_remote_transmit_power_level_cp0 *cp0 = (hci_le_read_remote_transmit_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_read_remote_transmit_power_level(cp0->Connection_Handle /* 2 */,
                                                    cp0->PHY /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x77;
  buffer_out[6] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_path_loss_reporting_parameters(uint16_t Connection_Handle,
                                                     uint8_t High_Threshold,
                                                     uint8_t High_Hysteresis,
                                                     uint8_t Low_Threshold,
                                                     uint8_t Low_Hysteresis,
                                                     uint16_t Min_Time_Spent);
 */
/* Command len: 2 + 1 + 1 + 1 + 1 + 2 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_path_loss_reporting_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_path_loss_reporting_parameters_cp0 *cp0 = (hci_le_set_path_loss_reporting_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_path_loss_reporting_parameters_rp0 *rp0 = (hci_le_set_path_loss_reporting_parameters_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1 + 1 + 1 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_path_loss_reporting_parameters(cp0->Connection_Handle /* 2 */,
                                                          cp0->High_Threshold /* 1 */,
                                                          cp0->High_Hysteresis /* 1 */,
                                                          cp0->Low_Threshold /* 1 */,
                                                          cp0->Low_Hysteresis /* 1 */,
                                                          cp0->Min_Time_Spent /* 2 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x78;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_path_loss_reporting_enable(uint16_t Connection_Handle,
                                                 uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_path_loss_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_path_loss_reporting_enable_cp0 *cp0 = (hci_le_set_path_loss_reporting_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_path_loss_reporting_enable_rp0 *rp0 = (hci_le_set_path_loss_reporting_enable_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_path_loss_reporting_enable(cp0->Connection_Handle /* 2 */,
                                                      cp0->Enable /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x79;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_set_transmit_power_reporting_enable(uint16_t Connection_Handle,
                                                      uint8_t Local_Enable,
                                                      uint8_t Remote_Enable);
 */
/* Command len: 2 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t hci_le_set_transmit_power_reporting_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_set_transmit_power_reporting_enable_cp0 *cp0 = (hci_le_set_transmit_power_reporting_enable_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  hci_le_set_transmit_power_reporting_enable_rp0 *rp0 = (hci_le_set_transmit_power_reporting_enable_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = hci_le_set_transmit_power_reporting_enable(cp0->Connection_Handle /* 2 */,
                                                           cp0->Local_Enable /* 1 */,
                                                           cp0->Remote_Enable /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7a;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus hci_le_transmitter_test_v4(uint8_t TX_Channel,
                                      uint8_t Test_Data_Length,
                                      uint8_t Packet_Payload,
                                      uint8_t PHY,
                                      uint8_t CTE_Length,
                                      uint8_t CTE_Type,
                                      uint8_t Switching_Pattern_Length,
                                      uint8_t Antenna_IDs[],
                                      int8_t Transmit_Power_Level);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) + 1 */
/* Response len: 1 */
uint16_t hci_le_transmitter_test_v4_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  hci_le_transmitter_test_v4_cp0 *cp0 = (hci_le_transmitter_test_v4_cp0 *)(buffer_in + (0));
  hci_le_transmitter_test_v4_cp1 *cp1 = (hci_le_transmitter_test_v4_cp1 *)(buffer_in + (0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t))));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = hci_le_transmitter_test_v4(cp0->TX_Channel /* 1 */,
                                       cp0->Test_Data_Length /* 1 */,
                                       cp0->Packet_Payload /* 1 */,
                                       cp0->PHY /* 1 */,
                                       cp0->CTE_Length /* 1 */,
                                       cp0->CTE_Type /* 1 */,
                                       cp0->Switching_Pattern_Length /* 1 */,
                                       cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */,
                                       cp1->Transmit_Power_Level /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x7b;
  buffer_out[5] = 0x20;
  return (output_size + 6);
}
/* tBleStatus aci_hal_get_fw_build_number(uint16_t *Build_Number);
 */
/* Command len: 0 */
/* Response len: 1 + 2 */
uint16_t aci_hal_get_fw_build_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2;
  /* Output params */
  aci_hal_get_fw_build_number_rp0 *rp0 = (aci_hal_get_fw_build_number_rp0 *) (buffer_out + 6);
  uint16_t Build_Number = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_get_fw_build_number(&Build_Number);
  rp0->Build_Number = Build_Number;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x00;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_get_firmware_details(uint8_t *DTM_version_major,
                                        uint8_t *DTM_version_minor,
                                        uint8_t *DTM_version_patch,
                                        uint8_t *DTM_variant,
                                        uint16_t *DTM_Build_Number,
                                        uint8_t *BTLE_Stack_version_major,
                                        uint8_t *BTLE_Stack_version_minor,
                                        uint8_t *BTLE_Stack_version_patch,
                                        uint8_t *BTLE_Stack_development,
                                        uint16_t *BTLE_Stack_variant,
                                        uint16_t *BTLE_Stack_Build_Number);
 */
/* Command len: 0 */
/* Response len: 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 */
uint16_t aci_hal_get_firmware_details_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2;
  /* Output params */
  aci_hal_get_firmware_details_rp0 *rp0 = (aci_hal_get_firmware_details_rp0 *) (buffer_out + 6);
  uint8_t DTM_version_major = 0;
  uint8_t DTM_version_minor = 0;
  uint8_t DTM_version_patch = 0;
  uint8_t DTM_variant = 0;
  uint16_t DTM_Build_Number = 0;
  uint8_t BTLE_Stack_version_major = 0;
  uint8_t BTLE_Stack_version_minor = 0;
  uint8_t BTLE_Stack_version_patch = 0;
  uint8_t BTLE_Stack_development = 0;
  uint16_t BTLE_Stack_variant = 0;
  uint16_t BTLE_Stack_Build_Number = 0;

  if (buffer_out_max_length < (1 + 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_get_firmware_details(&DTM_version_major,
                                             &DTM_version_minor,
                                             &DTM_version_patch,
                                             &DTM_variant,
                                             &DTM_Build_Number,
                                             &BTLE_Stack_version_major,
                                             &BTLE_Stack_version_minor,
                                             &BTLE_Stack_version_patch,
                                             &BTLE_Stack_development,
                                             &BTLE_Stack_variant,
                                             &BTLE_Stack_Build_Number);
  rp0->DTM_version_major = DTM_version_major;
  rp0->DTM_version_minor = DTM_version_minor;
  rp0->DTM_version_patch = DTM_version_patch;
  rp0->DTM_variant = DTM_variant;
  rp0->DTM_Build_Number = DTM_Build_Number;
  rp0->BTLE_Stack_version_major = BTLE_Stack_version_major;
  rp0->BTLE_Stack_version_minor = BTLE_Stack_version_minor;
  rp0->BTLE_Stack_version_patch = BTLE_Stack_version_patch;
  rp0->BTLE_Stack_development = BTLE_Stack_development;
  rp0->BTLE_Stack_variant = BTLE_Stack_variant;
  rp0->BTLE_Stack_Build_Number = BTLE_Stack_Build_Number;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_write_config_data(uint8_t Offset,
                                     uint8_t Length,
                                     uint8_t Value[]);
 */
/* Command len: 1 + 1 + cp0->Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_hal_write_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_write_config_data_cp0 *cp0 = (aci_hal_write_config_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + cp0->Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_write_config_data(cp0->Offset /* 1 */,
                                      cp0->Length /* 1 */,
                                      cp0->Value /* cp0->Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0c;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_read_config_data(uint8_t Offset,
                                    uint8_t *Data_Length,
                                    uint8_t Data[]);
 */
/* Command len: 1 */
/* Response len: 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
uint16_t aci_hal_read_config_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_read_config_data_cp0 *cp0 = (aci_hal_read_config_data_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_hal_read_config_data_rp0 *rp0 = (aci_hal_read_config_data_rp0 *) (buffer_out + 6);
  uint8_t Data_Length = 0;
  uint8_t Data[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)];

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_read_config_data(cp0->Offset /* 1 */,
                                         &Data_Length,
                                         Data);
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Data_Length = Data_Length;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->Data_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, rp0->Data_Length * (sizeof(uint8_t)));
  output_size += rp0->Data_Length * (sizeof(uint8_t));
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0d;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_set_tx_power_level(uint8_t En_High_Power,
                                      uint8_t PA_Level);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_set_tx_power_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_tx_power_level_cp0 *cp0 = (aci_hal_set_tx_power_level_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_set_tx_power_level(cp0->En_High_Power /* 1 */,
                                       cp0->PA_Level /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0f;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_le_tx_test_packet_number(uint32_t *Number_Of_Packets);
 */
/* Command len: 0 */
/* Response len: 1 + 4 */
uint16_t aci_hal_le_tx_test_packet_number_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 4;
  /* Output params */
  aci_hal_le_tx_test_packet_number_rp0 *rp0 = (aci_hal_le_tx_test_packet_number_rp0 *) (buffer_out + 6);
  uint32_t Number_Of_Packets = 0;

  if (buffer_out_max_length < (1 + 4 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_le_tx_test_packet_number(&Number_Of_Packets);
  rp0->Number_Of_Packets = Number_Of_Packets;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x14;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_tone_start(uint8_t RF_Channel,
                              uint8_t Offset);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_tone_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_tone_start_cp0 *cp0 = (aci_hal_tone_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_tone_start(cp0->RF_Channel /* 1 */,
                               cp0->Offset /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x15;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_tone_stop(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_hal_tone_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_tone_stop();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x16;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_get_link_status(uint8_t Bank_index,
                                   uint8_t Link_Status[8],
                                   uint16_t Link_Connection_Handle[16 / 2]);
 */
/* Command len: 1 */
/* Response len: 1 + 8 + 16 */
uint16_t aci_hal_get_link_status_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_get_link_status_cp0 *cp0 = (aci_hal_get_link_status_cp0 *)(buffer_in + (0));

  int output_size = 1 + 8 + 16;
  /* Output params */
  aci_hal_get_link_status_rp0 *rp0 = (aci_hal_get_link_status_rp0 *) (buffer_out + 6);
  uint8_t Link_Status[8];
  uint16_t Link_Connection_Handle[16 / 2];

  if (buffer_out_max_length < (1 + 8 + 16 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_get_link_status(cp0->Bank_index /* 1 */,
                                        Link_Status,
                                        Link_Connection_Handle);
  Osal_MemCpy((void *) rp0->Link_Status,(const void *) Link_Status, 8);
  Osal_MemCpy((void *) rp0->Link_Connection_Handle,(const void *) Link_Connection_Handle, 16);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x17;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_set_radio_activity_mask(uint16_t Radio_Activity_Mask);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_hal_set_radio_activity_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_radio_activity_mask_cp0 *cp0 = (aci_hal_set_radio_activity_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_set_radio_activity_mask(cp0->Radio_Activity_Mask /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x18;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_set_event_mask(uint32_t Event_Mask);
 */
/* Command len: 4 */
/* Response len: 1 */
uint16_t aci_hal_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_event_mask_cp0 *cp0 = (aci_hal_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_set_event_mask(cp0->Event_Mask /* 4 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1a;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_set_le_power_control(uint8_t Enable,
                                        uint8_t PHY,
                                        int8_t RSSI_Target,
                                        uint8_t RSSI_Hysteresis,
                                        int8_t Initial_TX_Power,
                                        uint8_t RSSI_Filtering_Coefficient);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_set_le_power_control_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_le_power_control_cp0 *cp0 = (aci_hal_set_le_power_control_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_set_le_power_control(cp0->Enable /* 1 */,
                                         cp0->PHY /* 1 */,
                                         cp0->RSSI_Target /* 1 */,
                                         cp0->RSSI_Hysteresis /* 1 */,
                                         cp0->Initial_TX_Power /* 1 */,
                                         cp0->RSSI_Filtering_Coefficient /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x1c;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_updater_start(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_hal_updater_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_updater_start();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x20;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_transmitter_test_packets(uint8_t TX_Frequency,
                                            uint8_t Length_Of_Test_Data,
                                            uint8_t Packet_Payload,
                                            uint16_t Number_Of_Packets,
                                            uint8_t PHY);
 */
/* Command len: 1 + 1 + 1 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_hal_transmitter_test_packets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_transmitter_test_packets_cp0 *cp0 = (aci_hal_transmitter_test_packets_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_transmitter_test_packets(cp0->TX_Frequency /* 1 */,
                                             cp0->Length_Of_Test_Data /* 1 */,
                                             cp0->Packet_Payload /* 1 */,
                                             cp0->Number_Of_Packets /* 2 */,
                                             cp0->PHY /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x2b;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_transmitter_test_packets_v2(uint8_t TX_Channel,
                                               uint8_t Test_Data_Length,
                                               uint8_t Packet_Payload,
                                               uint16_t Number_Of_Packets,
                                               uint8_t PHY,
                                               uint8_t CTE_Length,
                                               uint8_t CTE_Type,
                                               uint8_t Switching_Pattern_Length,
                                               uint8_t Antenna_IDs[]);
 */
/* Command len: 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_hal_transmitter_test_packets_v2_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_transmitter_test_packets_v2_cp0 *cp0 = (aci_hal_transmitter_test_packets_v2_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + cp0->Switching_Pattern_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_transmitter_test_packets_v2(cp0->TX_Channel /* 1 */,
                                                cp0->Test_Data_Length /* 1 */,
                                                cp0->Packet_Payload /* 1 */,
                                                cp0->Number_Of_Packets /* 2 */,
                                                cp0->PHY /* 1 */,
                                                cp0->CTE_Length /* 1 */,
                                                cp0->CTE_Type /* 1 */,
                                                cp0->Switching_Pattern_Length /* 1 */,
                                                cp0->Antenna_IDs /* cp0->Switching_Pattern_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2c;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_write_radio_reg(uint32_t Start_Address,
                                   uint8_t Num_Bytes,
                                   uint8_t Data[]);
 */
/* Command len: 4 + 1 + cp0->Num_Bytes * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_hal_write_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_write_radio_reg_cp0 *cp0 = (aci_hal_write_radio_reg_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4 + 1 + cp0->Num_Bytes * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_write_radio_reg(cp0->Start_Address /* 4 */,
                                    cp0->Num_Bytes /* 1 */,
                                    cp0->Data /* cp0->Num_Bytes * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x35;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_read_radio_reg(uint32_t Start_Address,
                                  uint8_t Num_Bytes,
                                  uint8_t *Data_Length,
                                  uint8_t Data[]);
 */
/* Command len: 4 + 1 */
/* Response len: 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
uint16_t aci_hal_read_radio_reg_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_read_radio_reg_cp0 *cp0 = (aci_hal_read_radio_reg_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_hal_read_radio_reg_rp0 *rp0 = (aci_hal_read_radio_reg_rp0 *) (buffer_out + 6);
  uint8_t Data_Length = 0;
  uint8_t Data[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)];

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_read_radio_reg(cp0->Start_Address /* 4 */,
                                       cp0->Num_Bytes /* 1 */,
                                       &Data_Length,
                                       Data);
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Data_Length = Data_Length;
  output_size += 1;
  if (buffer_out_max_length < (output_size + (rp0->Data_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, rp0->Data_Length * (sizeof(uint8_t)));
  output_size += rp0->Data_Length * (sizeof(uint8_t));
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x36;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_set_antenna_switch_parameters(uint8_t Antenna_IDs,
                                                 uint8_t Antenna_ID_Shift,
                                                 uint8_t Default_Antenna_ID,
                                                 uint8_t RF_Activity_Enable);
 */
/* Command len: 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_hal_set_antenna_switch_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_hal_set_antenna_switch_parameters_cp0 *cp0 = (aci_hal_set_antenna_switch_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_hal_set_antenna_switch_parameters(cp0->Antenna_IDs /* 1 */,
                                                  cp0->Antenna_ID_Shift /* 1 */,
                                                  cp0->Default_Antenna_ID /* 1 */,
                                                  cp0->RF_Activity_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x37;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_hal_get_evt_fifo_max_level(uint16_t *ISR0_FIFO_Max_Level,
                                          uint16_t *ISR1_FIFO_Max_Level,
                                          uint16_t *User_FIFO_Max_Level);
 */
/* Command len: 0 */
/* Response len: 1 + 2 + 2 + 2 */
uint16_t aci_hal_get_evt_fifo_max_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 2 + 2 + 2;
  /* Output params */
  aci_hal_get_evt_fifo_max_level_rp0 *rp0 = (aci_hal_get_evt_fifo_max_level_rp0 *) (buffer_out + 6);
  uint16_t ISR0_FIFO_Max_Level = 0;
  uint16_t ISR1_FIFO_Max_Level = 0;
  uint16_t User_FIFO_Max_Level = 0;

  if (buffer_out_max_length < (1 + 2 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_hal_get_evt_fifo_max_level(&ISR0_FIFO_Max_Level,
                                               &ISR1_FIFO_Max_Level,
                                               &User_FIFO_Max_Level);
  rp0->ISR0_FIFO_Max_Level = ISR0_FIFO_Max_Level;
  rp0->ISR1_FIFO_Max_Level = ISR1_FIFO_Max_Level;
  rp0->User_FIFO_Max_Level = User_FIFO_Max_Level;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x60;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_io_capability(uint8_t IO_Capability);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_set_io_capability_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_io_capability(cp0->IO_Capability /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x85;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_authentication_requirement(uint8_t Bonding_Mode,
                                                  uint8_t MITM_Mode,
                                                  uint8_t SC_Support,
                                                  uint8_t KeyPress_Notification_Support,
                                                  uint8_t Min_Encryption_Key_Size,
                                                  uint8_t Max_Encryption_Key_Size,
                                                  uint8_t Use_Fixed_Pin,
                                                  uint32_t Fixed_Pin);
 */
/* Command len: 1 + 1 + 1 + 1 + 1 + 1 + 1 + 4 */
/* Response len: 1 */
uint16_t aci_gap_set_authentication_requirement_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_authentication_requirement_cp0 *cp0 = (aci_gap_set_authentication_requirement_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 1 + 1 + 1 + 4)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_authentication_requirement(cp0->Bonding_Mode /* 1 */,
                                                   cp0->MITM_Mode /* 1 */,
                                                   cp0->SC_Support /* 1 */,
                                                   cp0->KeyPress_Notification_Support /* 1 */,
                                                   cp0->Min_Encryption_Key_Size /* 1 */,
                                                   cp0->Max_Encryption_Key_Size /* 1 */,
                                                   cp0->Use_Fixed_Pin /* 1 */,
                                                   cp0->Fixed_Pin /* 4 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x86;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_pass_key_resp(uint16_t Connection_Handle,
                                 uint32_t Pass_Key);
 */
/* Command len: 2 + 4 */
/* Response len: 1 */
uint16_t aci_gap_pass_key_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 4)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_pass_key_resp(cp0->Connection_Handle /* 2 */,
                                  cp0->Pass_Key /* 4 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x88;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_init(uint8_t Role,
                        uint8_t Privacy_Type,
                        uint8_t Device_Name_Char_Len,
                        uint8_t Identity_Address_Type,
                        uint16_t *Service_Handle,
                        uint16_t *Dev_Name_Char_Handle,
                        uint16_t *Appearance_Char_Handle);
 */
/* Command len: 1 + 1 + 1 + 1 */
/* Response len: 1 + 2 + 2 + 2 */
uint16_t aci_gap_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2 + 2 + 2;
  /* Output params */
  aci_gap_init_rp0 *rp0 = (aci_gap_init_rp0 *) (buffer_out + 6);
  uint16_t Service_Handle = 0;
  uint16_t Dev_Name_Char_Handle = 0;
  uint16_t Appearance_Char_Handle = 0;

  if (buffer_out_max_length < (1 + 2 + 2 + 2 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_init(cp0->Role /* 1 */,
                             cp0->Privacy_Type /* 1 */,
                             cp0->Device_Name_Char_Len /* 1 */,
                             cp0->Identity_Address_Type /* 1 */,
                             &Service_Handle,
                             &Dev_Name_Char_Handle,
                             &Appearance_Char_Handle);
  rp0->Service_Handle = Service_Handle;
  rp0->Dev_Name_Char_Handle = Dev_Name_Char_Handle;
  rp0->Appearance_Char_Handle = Appearance_Char_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x8a;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_slave_security_req(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gap_slave_security_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_slave_security_req_cp0 *cp0 = (aci_gap_slave_security_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_slave_security_req(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x8d;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_get_security_level(uint16_t Connection_Handle,
                                      uint8_t *Security_Mode,
                                      uint8_t *Security_Level);
 */
/* Command len: 2 */
/* Response len: 1 + 1 + 1 */
uint16_t aci_gap_get_security_level_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_get_security_level_cp0 *cp0 = (aci_gap_get_security_level_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1 + 1;
  /* Output params */
  aci_gap_get_security_level_rp0 *rp0 = (aci_gap_get_security_level_rp0 *) (buffer_out + 6);
  uint8_t Security_Mode = 0;
  uint8_t Security_Level = 0;

  if (buffer_out_max_length < (1 + 1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_get_security_level(cp0->Connection_Handle /* 2 */,
                                           &Security_Mode,
                                           &Security_Level);
  rp0->Security_Mode = Security_Mode;
  rp0->Security_Level = Security_Level;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x90;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_event_mask(uint16_t GAP_Evt_Mask);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gap_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_event_mask_cp0 *cp0 = (aci_gap_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_event_mask(cp0->GAP_Evt_Mask /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x91;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_terminate(uint16_t Connection_Handle,
                             uint8_t Reason);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_terminate_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_terminate_cp0 *cp0 = (aci_gap_terminate_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_terminate(cp0->Connection_Handle /* 2 */,
                              cp0->Reason /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x93;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_clear_security_db(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gap_clear_security_db_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_clear_security_db();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x94;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_allow_rebond(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gap_allow_rebond_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_allow_rebond_cp0 *cp0 = (aci_gap_allow_rebond_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_allow_rebond(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x95;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_create_connection(uint8_t Initiating_PHY,
                                     uint8_t Peer_Address_Type,
                                     uint8_t Peer_Address[6]);
 */
/* Command len: 1 + 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_create_connection_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_create_connection_cp0 *cp0 = (aci_gap_create_connection_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_create_connection(cp0->Initiating_PHY /* 1 */,
                                      cp0->Peer_Address_Type /* 1 */,
                                      cp0->Peer_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9c;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_terminate_proc(uint8_t Procedure_Code);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_terminate_proc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_terminate_proc_cp0 *cp0 = (aci_gap_terminate_proc_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_terminate_proc(cp0->Procedure_Code /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9d;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_start_connection_update(uint16_t Connection_Handle,
                                           uint16_t Conn_Interval_Min,
                                           uint16_t Conn_Interval_Max,
                                           uint16_t Conn_Latency,
                                           uint16_t Supervision_Timeout,
                                           uint16_t Minimum_CE_Length,
                                           uint16_t Maximum_CE_Length);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_start_connection_update_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_start_connection_update_cp0 *cp0 = (aci_gap_start_connection_update_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_start_connection_update(cp0->Connection_Handle /* 2 */,
                                            cp0->Conn_Interval_Min /* 2 */,
                                            cp0->Conn_Interval_Max /* 2 */,
                                            cp0->Conn_Latency /* 2 */,
                                            cp0->Supervision_Timeout /* 2 */,
                                            cp0->Minimum_CE_Length /* 2 */,
                                            cp0->Maximum_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9e;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_send_pairing_req(uint16_t Connection_Handle,
                                    uint8_t Force_Rebond);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_send_pairing_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_send_pairing_req_cp0 *cp0 = (aci_gap_send_pairing_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_send_pairing_req(cp0->Connection_Handle /* 2 */,
                                     cp0->Force_Rebond /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x9f;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_resolve_private_addr(uint8_t Address[6],
                                        uint8_t Actual_Address[6]);
 */
/* Command len: 6 */
/* Response len: 1 + 6 */
uint16_t aci_gap_resolve_private_addr_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_resolve_private_addr_cp0 *cp0 = (aci_gap_resolve_private_addr_cp0 *)(buffer_in + (0));

  int output_size = 1 + 6;
  /* Output params */
  aci_gap_resolve_private_addr_rp0 *rp0 = (aci_gap_resolve_private_addr_rp0 *) (buffer_out + 6);
  uint8_t Actual_Address[6];

  if (buffer_out_max_length < (1 + 6 + 6)) { return 0; }
  if(buffer_in_length != 6)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_resolve_private_addr(cp0->Address /* 6 */,
                                             Actual_Address);
  Osal_MemCpy((void *) rp0->Actual_Address,(const void *) Actual_Address, 6);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa0;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_get_bonded_devices(uint8_t Offset,
                                      uint8_t Max_Num_Of_Addresses,
                                      uint8_t *Num_of_Addresses,
                                      Bonded_Device_Entry_t Bonded_Device_Entry[]);
 */
/* Command len: 1 + 1 */
/* Response len: 1 + 1 + rp0->Num_of_Addresses * (sizeof(packed_Bonded_Device_Entry_t)) */
uint16_t aci_gap_get_bonded_devices_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_get_bonded_devices_cp0 *cp0 = (aci_gap_get_bonded_devices_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gap_get_bonded_devices_rp0 *rp0 = (aci_gap_get_bonded_devices_rp0 *) (buffer_out + 6);
  uint8_t Num_of_Addresses = 0;
  Bonded_Device_Entry_t Bonded_Device_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(Bonded_Device_Entry_t)];

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_get_bonded_devices(cp0->Offset /* 1 */,
                                           cp0->Max_Num_Of_Addresses /* 1 */,
                                           &Num_of_Addresses,
                                           Bonded_Device_Entry);
  output_size += 1;
  if (buffer_out_max_length < (output_size + (1) + 6)) { return 0; }
  rp0->Num_of_Addresses = Num_of_Addresses;
  output_size += 1;
  {
    int i;
    for (i = 0; i < Num_of_Addresses; i++) {
      if (buffer_out_max_length < (output_size + (sizeof(uint8_t)) + 6)) { return 0; }
      rp0->Bonded_Device_Entry[i].Address_Type = Bonded_Device_Entry[i].Address_Type;
      output_size += sizeof(uint8_t);
      if (buffer_out_max_length < (output_size + (6) + 6)) { return 0; }
      Osal_MemCpy((void *) &rp0->Bonded_Device_Entry[i].Address, (const void *) Bonded_Device_Entry[i].Address, 6);
      output_size += 6;
    }
  }
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa3;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_is_device_bonded(uint8_t Peer_Address_Type,
                                    uint8_t Peer_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_is_device_bonded_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_is_device_bonded_cp0 *cp0 = (aci_gap_is_device_bonded_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_is_device_bonded(cp0->Peer_Address_Type /* 1 */,
                                     cp0->Peer_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa4;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_numeric_comparison_value_confirm_yesno(uint16_t Connection_Handle,
                                                          uint8_t Confirm_Yes_No);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_numeric_comparison_value_confirm_yesno_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 = (aci_gap_numeric_comparison_value_confirm_yesno_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_numeric_comparison_value_confirm_yesno(cp0->Connection_Handle /* 2 */,
                                                           cp0->Confirm_Yes_No /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa5;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_passkey_input(uint16_t Connection_Handle,
                                 uint8_t Input_Type);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_passkey_input_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_passkey_input_cp0 *cp0 = (aci_gap_passkey_input_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_passkey_input(cp0->Connection_Handle /* 2 */,
                                  cp0->Input_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa6;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_get_oob_data(uint8_t OOB_Data_Type,
                                uint8_t *Address_Type,
                                uint8_t Address[6],
                                uint8_t *OOB_Data_Len,
                                uint8_t OOB_Data[16]);
 */
/* Command len: 1 */
/* Response len: 1 + 1 + 6 + 1 + 1 + 16 */
uint16_t aci_gap_get_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_get_oob_data_cp0 *cp0 = (aci_gap_get_oob_data_cp0 *)(buffer_in + (0));

  int output_size = 1 + 1 + 6 + 1 + 1 + 16;
  /* Output params */
  aci_gap_get_oob_data_rp0 *rp0 = (aci_gap_get_oob_data_rp0 *) (buffer_out + 6);
  uint8_t Address_Type = 0;
  uint8_t Address[6];
  uint8_t OOB_Data_Len = 0;
  uint8_t OOB_Data[16];

  if (buffer_out_max_length < (1 + 1 + 6 + 1 + 1 + 16 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_get_oob_data(cp0->OOB_Data_Type /* 1 */,
                                     &Address_Type,
                                     Address,
                                     &OOB_Data_Len,
                                     OOB_Data);
  rp0->Address_Type = Address_Type;
  Osal_MemCpy((void *) rp0->Address,(const void *) Address, 6);
  rp0->OOB_Data_Type = cp0->OOB_Data_Type;
  rp0->OOB_Data_Len = OOB_Data_Len;
  Osal_MemCpy((void *) rp0->OOB_Data,(const void *) OOB_Data, 16);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa7;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_oob_data(uint8_t Device_Type,
                                uint8_t Address_Type,
                                uint8_t Address[6],
                                uint8_t OOB_Data_Type,
                                uint8_t OOB_Data_Len,
                                uint8_t OOB_Data[16]);
 */
/* Command len: 1 + 1 + 6 + 1 + 1 + 16 */
/* Response len: 1 */
uint16_t aci_gap_set_oob_data_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_oob_data_cp0 *cp0 = (aci_gap_set_oob_data_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 6 + 1 + 1 + 16)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_oob_data(cp0->Device_Type /* 1 */,
                                 cp0->Address_Type /* 1 */,
                                 cp0->Address /* 6 */,
                                 cp0->OOB_Data_Type /* 1 */,
                                 cp0->OOB_Data_Len /* 1 */,
                                 cp0->OOB_Data /* 16 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xa8;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_remove_bonded_device(uint8_t Peer_Identity_Address_Type,
                                        uint8_t Peer_Identity_Address[6]);
 */
/* Command len: 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_remove_bonded_device_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_remove_bonded_device_cp0 *cp0 = (aci_gap_remove_bonded_device_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_remove_bonded_device(cp0->Peer_Identity_Address_Type /* 1 */,
                                         cp0->Peer_Identity_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xaa;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_advertising_configuration(uint8_t Advertising_Handle,
                                                 uint8_t Discoverable_Mode,
                                                 uint16_t Advertising_Event_Properties,
                                                 uint32_t Primary_Advertising_Interval_Min,
                                                 uint32_t Primary_Advertising_Interval_Max,
                                                 uint8_t Primary_Advertising_Channel_Map,
                                                 uint8_t Peer_Address_Type,
                                                 uint8_t Peer_Address[6],
                                                 uint8_t Advertising_Filter_Policy,
                                                 int8_t Advertising_Tx_Power,
                                                 uint8_t Primary_Advertising_PHY,
                                                 uint8_t Secondary_Advertising_Max_Skip,
                                                 uint8_t Secondary_Advertising_PHY,
                                                 uint8_t Advertising_SID,
                                                 uint8_t Scan_Request_Notification_Enable);
 */
/* Command len: 1 + 1 + 2 + 4 + 4 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_advertising_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_advertising_configuration_cp0 *cp0 = (aci_gap_set_advertising_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 2 + 4 + 4 + 1 + 1 + 6 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_advertising_configuration(cp0->Advertising_Handle /* 1 */,
                                                  cp0->Discoverable_Mode /* 1 */,
                                                  cp0->Advertising_Event_Properties /* 2 */,
                                                  cp0->Primary_Advertising_Interval_Min /* 4 */,
                                                  cp0->Primary_Advertising_Interval_Max /* 4 */,
                                                  cp0->Primary_Advertising_Channel_Map /* 1 */,
                                                  cp0->Peer_Address_Type /* 1 */,
                                                  cp0->Peer_Address /* 6 */,
                                                  cp0->Advertising_Filter_Policy /* 1 */,
                                                  cp0->Advertising_Tx_Power /* 1 */,
                                                  cp0->Primary_Advertising_PHY /* 1 */,
                                                  cp0->Secondary_Advertising_Max_Skip /* 1 */,
                                                  cp0->Secondary_Advertising_PHY /* 1 */,
                                                  cp0->Advertising_SID /* 1 */,
                                                  cp0->Scan_Request_Notification_Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xab;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
tBleStatus aci_gap_set_advertising_enable_preprocess(uint8_t Enable,
                                                     uint8_t Number_of_Sets,
                                                     Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
/* tBleStatus aci_gap_set_advertising_enable(uint8_t Enable,
                                          uint8_t Number_of_Sets,
                                          Advertising_Set_Parameters_t Advertising_Set_Parameters[]);
 */
/* Command len: 1 + 1 + cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)) */
/* Response len: 1 */
uint16_t aci_gap_set_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_advertising_enable_cp0 *cp0 = (aci_gap_set_advertising_enable_cp0 *)(buffer_in + (0));
  Advertising_Set_Parameters_t Advertising_Set_Parameters[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Set_Parameters_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  for (i = 0; i < cp0->Number_of_Sets; i++) {
    Advertising_Set_Parameters[i].Advertising_Handle = cp0->Advertising_Set_Parameters[i].Advertising_Handle;
    Advertising_Set_Parameters[i].Duration = cp0->Advertising_Set_Parameters[i].Duration;
    Advertising_Set_Parameters[i].Max_Extended_Advertising_Events = cp0->Advertising_Set_Parameters[i].Max_Extended_Advertising_Events;
  }
  if(buffer_in_length != 1 + 1 + cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_advertising_enable_preprocess(cp0->Enable /* 1 */,
                                                      cp0->Number_of_Sets /* 1 */,
                                                      Advertising_Set_Parameters /* cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)) */);
  if(*status)
    goto fail;

  *status = aci_gap_set_advertising_enable(cp0->Enable /* 1 */,
                                           cp0->Number_of_Sets /* 1 */,
                                           Advertising_Set_Parameters /* cp0->Number_of_Sets * (sizeof(packed_Advertising_Set_Parameters_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xac;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_advertising_data_nwk(uint8_t Advertising_Handle,
                                            uint8_t Operation,
                                            uint8_t Advertising_Data_Length,
                                            uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gap_set_advertising_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_advertising_data_nwk_cp0 *cp0 = (aci_gap_set_advertising_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_advertising_data_nwk(cp0->Advertising_Handle /* 1 */,
                                             cp0->Operation /* 1 */,
                                             cp0->Advertising_Data_Length /* 1 */,
                                             cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xad;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_scan_response_data_nwk(uint8_t Advertising_Handle,
                                              uint8_t Operation,
                                              uint8_t Scan_Response_Data_Length,
                                              uint8_t Scan_Response_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gap_set_scan_response_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_scan_response_data_nwk_cp0 *cp0 = (aci_gap_set_scan_response_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Scan_Response_Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_scan_response_data_nwk(cp0->Advertising_Handle /* 1 */,
                                               cp0->Operation /* 1 */,
                                               cp0->Scan_Response_Data_Length /* 1 */,
                                               cp0->Scan_Response_Data /* cp0->Scan_Response_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xae;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_scan_configuration(uint8_t Filter_Duplicates,
                                          uint8_t Scanning_Filter_Policy,
                                          uint8_t Scanning_PHY,
                                          uint8_t Scan_Type,
                                          uint16_t Scan_Interval,
                                          uint16_t Scan_Window);
 */
/* Command len: 1 + 1 + 1 + 1 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_set_scan_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_scan_configuration_cp0 *cp0 = (aci_gap_set_scan_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 1 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_scan_configuration(cp0->Filter_Duplicates /* 1 */,
                                           cp0->Scanning_Filter_Policy /* 1 */,
                                           cp0->Scanning_PHY /* 1 */,
                                           cp0->Scan_Type /* 1 */,
                                           cp0->Scan_Interval /* 2 */,
                                           cp0->Scan_Window /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xaf;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_connection_configuration(uint8_t Initiating_PHY,
                                                uint16_t Conn_Interval_Min,
                                                uint16_t Conn_Interval_Max,
                                                uint16_t Conn_Latency,
                                                uint16_t Supervision_Timeout,
                                                uint16_t Minimum_CE_Length,
                                                uint16_t Maximum_CE_Length);
 */
/* Command len: 1 + 2 + 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_set_connection_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_connection_configuration_cp0 *cp0 = (aci_gap_set_connection_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 2 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_connection_configuration(cp0->Initiating_PHY /* 1 */,
                                                 cp0->Conn_Interval_Min /* 2 */,
                                                 cp0->Conn_Interval_Max /* 2 */,
                                                 cp0->Conn_Latency /* 2 */,
                                                 cp0->Supervision_Timeout /* 2 */,
                                                 cp0->Minimum_CE_Length /* 2 */,
                                                 cp0->Maximum_CE_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb0;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_start_procedure(uint8_t Procedure_Code,
                                   uint8_t PHYs,
                                   uint16_t Duration,
                                   uint16_t Period);
 */
/* Command len: 1 + 1 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_start_procedure_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_start_procedure_cp0 *cp0 = (aci_gap_start_procedure_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_start_procedure(cp0->Procedure_Code /* 1 */,
                                    cp0->PHYs /* 1 */,
                                    cp0->Duration /* 2 */,
                                    cp0->Period /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb1;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_discover_name(uint8_t PHYs,
                                 uint8_t Peer_Address_Type,
                                 uint8_t Peer_Address[6]);
 */
/* Command len: 1 + 1 + 6 */
/* Response len: 1 */
uint16_t aci_gap_discover_name_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_discover_name_cp0 *cp0 = (aci_gap_discover_name_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 6)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_discover_name(cp0->PHYs /* 1 */,
                                  cp0->Peer_Address_Type /* 1 */,
                                  cp0->Peer_Address /* 6 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb2;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_add_devices_to_white_and_resolving_list(uint8_t Lists,
                                                           uint8_t Clear_Lists,
                                                           uint8_t Num_of_List_Entries,
                                                           List_Entry_t List_Entry[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Num_of_List_Entries * (sizeof(packed_List_Entry_t)) */
/* Response len: 1 */
uint16_t aci_gap_add_devices_to_white_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_add_devices_to_white_and_resolving_list_cp0 *cp0 = (aci_gap_add_devices_to_white_and_resolving_list_cp0 *)(buffer_in + (0));
  List_Entry_t List_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(List_Entry_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  for (i = 0; i < cp0->Num_of_List_Entries; i++) {
    List_Entry[i].Peer_Address_Type = cp0->List_Entry[i].Peer_Address_Type;
    Osal_MemCpy((void *) &List_Entry[i].Peer_Address, (const void *) &cp0->List_Entry[i].Peer_Address, 6);
  }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Num_of_List_Entries * (sizeof(packed_List_Entry_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_add_devices_to_white_and_resolving_list(cp0->Lists /* 1 */,
                                                            cp0->Clear_Lists /* 1 */,
                                                            cp0->Num_of_List_Entries /* 1 */,
                                                            List_Entry /* cp0->Num_of_List_Entries * (sizeof(packed_List_Entry_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb3;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_configure_white_and_resolving_list(uint8_t Lists);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_configure_white_and_resolving_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_configure_white_and_resolving_list_cp0 *cp0 = (aci_gap_configure_white_and_resolving_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_configure_white_and_resolving_list(cp0->Lists /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb4;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_periodic_advertising_configuration(uint8_t Advertising_Handle,
                                                          uint16_t Periodic_Advertising_Interval_Min,
                                                          uint16_t Periodic_Advertising_Interval_Max,
                                                          uint16_t Periodic_Advertising_Properties);
 */
/* Command len: 1 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gap_set_periodic_advertising_configuration_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_periodic_advertising_configuration_cp0 *cp0 = (aci_gap_set_periodic_advertising_configuration_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_periodic_advertising_configuration(cp0->Advertising_Handle /* 1 */,
                                                           cp0->Periodic_Advertising_Interval_Min /* 2 */,
                                                           cp0->Periodic_Advertising_Interval_Max /* 2 */,
                                                           cp0->Periodic_Advertising_Properties /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb5;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_periodic_advertising_data_nwk(uint8_t Advertising_Handle,
                                                     uint8_t Operation,
                                                     uint8_t Advertising_Data_Length,
                                                     uint8_t Advertising_Data[]);
 */
/* Command len: 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gap_set_periodic_advertising_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_periodic_advertising_data_nwk_cp0 *cp0 = (aci_gap_set_periodic_advertising_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + cp0->Advertising_Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_periodic_advertising_data_nwk(cp0->Advertising_Handle /* 1 */,
                                                      cp0->Operation /* 1 */,
                                                      cp0->Advertising_Data_Length /* 1 */,
                                                      cp0->Advertising_Data /* cp0->Advertising_Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb6;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_periodic_advertising_enable(uint8_t Enable,
                                                   uint8_t Advertising_Handle);
 */
/* Command len: 1 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_periodic_advertising_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_periodic_advertising_enable_cp0 *cp0 = (aci_gap_set_periodic_advertising_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_periodic_advertising_enable(cp0->Enable /* 1 */,
                                                    cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb7;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_periodic_advertising_create_sync(uint8_t Options,
                                                    uint8_t Advertising_SID,
                                                    uint8_t Advertising_Address_Type,
                                                    uint8_t Advertiser_Address[6],
                                                    uint16_t Skip,
                                                    uint16_t Sync_Timeout,
                                                    uint8_t Sync_CTE_Type);
 */
/* Command len: 1 + 1 + 1 + 6 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_periodic_advertising_create_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_periodic_advertising_create_sync_cp0 *cp0 = (aci_gap_periodic_advertising_create_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 1 + 1 + 6 + 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_periodic_advertising_create_sync(cp0->Options /* 1 */,
                                                     cp0->Advertising_SID /* 1 */,
                                                     cp0->Advertising_Address_Type /* 1 */,
                                                     cp0->Advertiser_Address /* 6 */,
                                                     cp0->Skip /* 2 */,
                                                     cp0->Sync_Timeout /* 2 */,
                                                     cp0->Sync_CTE_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xb8;
  buffer_out[6] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_periodic_advertising_create_sync_cancel(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gap_periodic_advertising_create_sync_cancel_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_periodic_advertising_create_sync_cancel();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xb9;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_remove_advertising_set(uint8_t Advertising_Handle);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_gap_remove_advertising_set_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_remove_advertising_set_cp0 *cp0 = (aci_gap_remove_advertising_set_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_remove_advertising_set(cp0->Advertising_Handle /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xba;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_clear_advertising_sets(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gap_clear_advertising_sets_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_clear_advertising_sets();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xbb;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_periodic_advertising_terminate_sync(uint16_t Sync_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gap_periodic_advertising_terminate_sync_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_periodic_advertising_terminate_sync_cp0 *cp0 = (aci_gap_periodic_advertising_terminate_sync_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_periodic_advertising_terminate_sync(cp0->Sync_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc0;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_add_device_to_periodic_advertiser_list(uint8_t Advertiser_Address_Type,
                                                          uint8_t Advertiser_Address[6],
                                                          uint8_t Advertising_SID);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t aci_gap_add_device_to_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_add_device_to_periodic_advertiser_list_cp0 *cp0 = (aci_gap_add_device_to_periodic_advertiser_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_add_device_to_periodic_advertiser_list(cp0->Advertiser_Address_Type /* 1 */,
                                                           cp0->Advertiser_Address /* 6 */,
                                                           cp0->Advertising_SID /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc1;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_remove_device_from_periodic_advertising_list(uint8_t Advertiser_Address_Type,
                                                                uint8_t Advertiser_Address[6],
                                                                uint8_t Advertising_SID);
 */
/* Command len: 1 + 6 + 1 */
/* Response len: 1 */
uint16_t aci_gap_remove_device_from_periodic_advertising_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_remove_device_from_periodic_advertising_list_cp0 *cp0 = (aci_gap_remove_device_from_periodic_advertising_list_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 6 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_remove_device_from_periodic_advertising_list(cp0->Advertiser_Address_Type /* 1 */,
                                                                 cp0->Advertiser_Address /* 6 */,
                                                                 cp0->Advertising_SID /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc2;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_clear_periodic_advertiser_list(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gap_clear_periodic_advertiser_list_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_clear_periodic_advertiser_list();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc3;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_read_periodic_advertiser_list_size(uint8_t *Periodic_Advertiser_List_Size);
 */
/* Command len: 0 */
/* Response len: 1 + 1 */
uint16_t aci_gap_read_periodic_advertiser_list_size_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 1;
  /* Output params */
  aci_gap_read_periodic_advertiser_list_size_rp0 *rp0 = (aci_gap_read_periodic_advertiser_list_size_rp0 *) (buffer_out + 6);
  uint8_t Periodic_Advertiser_List_Size = 0;

  if (buffer_out_max_length < (1 + 1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_read_periodic_advertiser_list_size(&Periodic_Advertiser_List_Size);
  rp0->Periodic_Advertiser_List_Size = Periodic_Advertiser_List_Size;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc4;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_periodic_advertising_receive_enable(uint16_t Sync_Handle,
                                                           uint8_t Enable);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_periodic_advertising_receive_enable_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_periodic_advertising_receive_enable_cp0 *cp0 = (aci_gap_set_periodic_advertising_receive_enable_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_periodic_advertising_receive_enable(cp0->Sync_Handle /* 2 */,
                                                            cp0->Enable /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc5;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_periodic_advertising_sync_transfer(uint16_t Connection_Handle,
                                                      uint16_t Service_Data,
                                                      uint16_t Sync_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 */
uint16_t aci_gap_periodic_advertising_sync_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_periodic_advertising_sync_transfer_cp0 *cp0 = (aci_gap_periodic_advertising_sync_transfer_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_gap_periodic_advertising_sync_transfer_rp0 *rp0 = (aci_gap_periodic_advertising_sync_transfer_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_periodic_advertising_sync_transfer(cp0->Connection_Handle /* 2 */,
                                                           cp0->Service_Data /* 2 */,
                                                           cp0->Sync_Handle /* 2 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc6;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_periodic_advertising_set_info_transfer(uint16_t Connection_Handle,
                                                          uint16_t Service_Data,
                                                          uint8_t Advertising_Handle);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gap_periodic_advertising_set_info_transfer_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_periodic_advertising_set_info_transfer_cp0 *cp0 = (aci_gap_periodic_advertising_set_info_transfer_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_gap_periodic_advertising_set_info_transfer_rp0 *rp0 = (aci_gap_periodic_advertising_set_info_transfer_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_periodic_advertising_set_info_transfer(cp0->Connection_Handle /* 2 */,
                                                               cp0->Service_Data /* 2 */,
                                                               cp0->Advertising_Handle /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc7;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_periodic_advertising_sync_transfer_parameters(uint16_t Connection_Handle,
                                                                     uint8_t Mode,
                                                                     uint16_t Skip,
                                                                     uint16_t Sync_Timeout,
                                                                     uint8_t CTE_Type);
 */
/* Command len: 2 + 1 + 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gap_set_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_periodic_advertising_sync_transfer_parameters_cp0 *cp0 = (aci_gap_set_periodic_advertising_sync_transfer_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_gap_set_periodic_advertising_sync_transfer_parameters_rp0 *rp0 = (aci_gap_set_periodic_advertising_sync_transfer_parameters_rp0 *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gap_set_periodic_advertising_sync_transfer_parameters(cp0->Connection_Handle /* 2 */,
                                                                          cp0->Mode /* 1 */,
                                                                          cp0->Skip /* 2 */,
                                                                          cp0->Sync_Timeout /* 2 */,
                                                                          cp0->CTE_Type /* 1 */);
  rp0->Connection_Handle = cp0->Connection_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc8;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gap_set_default_periodic_advertising_sync_transfer_parameters(uint8_t Mode,
                                                                             uint16_t Skip,
                                                                             uint16_t Sync_Timeout,
                                                                             uint8_t CTE_Type);
 */
/* Command len: 1 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_gap_set_default_periodic_advertising_sync_transfer_parameters_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gap_set_default_periodic_advertising_sync_transfer_parameters_cp0 *cp0 = (aci_gap_set_default_periodic_advertising_sync_transfer_parameters_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1 + 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gap_set_default_periodic_advertising_sync_transfer_parameters(cp0->Mode /* 1 */,
                                                                              cp0->Skip /* 2 */,
                                                                              cp0->Sync_Timeout /* 2 */,
                                                                              cp0->CTE_Type /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0xc9;
  buffer_out[5] = 0xfc;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_init(void);
 */
/* Command len: 0 */
/* Response len: 1 */
uint16_t aci_gatt_srv_init_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_init();
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_add_service_nwk(uint8_t Service_UUID_Type,
                                        Service_UUID_t *Service_UUID,
                                        uint8_t Service_Type,
                                        uint8_t Max_Attribute_Records,
                                        uint16_t *Service_Handle);
 */
/* Command len: 1 + (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)) + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_add_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_add_service_nwk_cp0 *cp0 = (aci_gatt_srv_add_service_nwk_cp0 *)(buffer_in + (0));
  aci_gatt_srv_add_service_nwk_cp1 *cp1 = (aci_gatt_srv_add_service_nwk_cp1 *)(buffer_in + (0 + 1 + (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0))));
  Service_UUID_t Service_UUID;

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_add_service_nwk_rp0 *rp0 = (aci_gatt_srv_add_service_nwk_rp0 *) (buffer_out + 6);
  uint16_t Service_Handle = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  Osal_MemCpy((void *) &Service_UUID.Service_UUID_16, (const void *) &cp0->Service_UUID.Service_UUID_16, (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 1 + (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)) + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_add_service_nwk(cp0->Service_UUID_Type /* 1 */,
                                             &Service_UUID /* (cp0->Service_UUID_Type == 1 ? 2 : (cp0->Service_UUID_Type == 2 ? 16 : 0)) */,
                                             cp1->Service_Type /* 1 */,
                                             cp1->Max_Attribute_Records /* 1 */,
                                             &Service_Handle);
  rp0->Service_Handle = Service_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_include_service_nwk(uint16_t Service_Handle,
                                            uint16_t Included_Service_Handle,
                                            uint16_t *Include_Handle);
 */
/* Command len: 2 + 2 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_include_service_nwk_cp0 *cp0 = (aci_gatt_srv_include_service_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_include_service_nwk_rp0 *rp0 = (aci_gatt_srv_include_service_nwk_rp0 *) (buffer_out + 6);
  uint16_t Include_Handle = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_include_service_nwk(cp0->Service_Handle /* 2 */,
                                                 cp0->Included_Service_Handle /* 2 */,
                                                 &Include_Handle);
  rp0->Include_Handle = Include_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_add_char_nwk(uint16_t Service_Handle,
                                     uint8_t Char_UUID_Type,
                                     Char_UUID_t *Char_UUID,
                                     uint16_t Char_Value_Length,
                                     uint8_t Char_Properties,
                                     uint8_t Security_Permissions,
                                     uint8_t GATT_Evt_Mask,
                                     uint8_t Enc_Key_Size,
                                     uint8_t Is_Variable,
                                     uint16_t *Char_Handle);
 */
/* Command len: 2 + 1 + (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)) + 2 + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_add_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_add_char_nwk_cp0 *cp0 = (aci_gatt_srv_add_char_nwk_cp0 *)(buffer_in + (0));
  aci_gatt_srv_add_char_nwk_cp1 *cp1 = (aci_gatt_srv_add_char_nwk_cp1 *)(buffer_in + (0 + 2 + 1 + (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0))));
  Char_UUID_t Char_UUID;

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_add_char_nwk_rp0 *rp0 = (aci_gatt_srv_add_char_nwk_rp0 *) (buffer_out + 6);
  uint16_t Char_Handle = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  Osal_MemCpy((void *) &Char_UUID.Char_UUID_16, (const void *) &cp0->Char_UUID.Char_UUID_16, (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 1 + (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)) + 2 + 1 + 1 + 1 + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_add_char_nwk(cp0->Service_Handle /* 2 */,
                                          cp0->Char_UUID_Type /* 1 */,
                                          &Char_UUID /* (cp0->Char_UUID_Type == 1 ? 2 : (cp0->Char_UUID_Type == 2 ? 16 : 0)) */,
                                          cp1->Char_Value_Length /* 2 */,
                                          cp1->Char_Properties /* 1 */,
                                          cp1->Security_Permissions /* 1 */,
                                          cp1->GATT_Evt_Mask /* 1 */,
                                          cp1->Enc_Key_Size /* 1 */,
                                          cp1->Is_Variable /* 1 */,
                                          &Char_Handle);
  rp0->Char_Handle = Char_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x04;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_add_char_desc_nwk(uint16_t Char_Handle,
                                          uint8_t Char_Desc_Uuid_Type,
                                          Char_Desc_Uuid_t *Char_Desc_Uuid,
                                          uint16_t Char_Desc_Value_Max_Len,
                                          uint16_t Char_Desc_Value_Length,
                                          uint8_t Char_Desc_Value[],
                                          uint8_t Security_Permissions,
                                          uint8_t Access_Permissions,
                                          uint8_t GATT_Evt_Mask,
                                          uint8_t Enc_Key_Size,
                                          uint8_t Is_Variable,
                                          uint16_t *Char_Desc_Handle);
 */
/* Command len: 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) + 2 + 2 + cp1->Char_Desc_Value_Length * (sizeof(uint8_t)) + 1 + 1 + 1 + 1 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_gatt_srv_add_char_desc_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_add_char_desc_nwk_cp0 *cp0 = (aci_gatt_srv_add_char_desc_nwk_cp0 *)(buffer_in + (0));
  aci_gatt_srv_add_char_desc_nwk_cp1 *cp1 = (aci_gatt_srv_add_char_desc_nwk_cp1 *)(buffer_in + (0 + 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0))));
  aci_gatt_srv_add_char_desc_nwk_cp2 *cp2 = (aci_gatt_srv_add_char_desc_nwk_cp2 *)(buffer_in + (0 + 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) + 2 + 2 + cp1->Char_Desc_Value_Length * (sizeof(uint8_t))));
  Char_Desc_Uuid_t Char_Desc_Uuid;

  int output_size = 1 + 2;
  /* Output params */
  aci_gatt_srv_add_char_desc_nwk_rp0 *rp0 = (aci_gatt_srv_add_char_desc_nwk_rp0 *) (buffer_out + 6);
  uint16_t Char_Desc_Handle = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  Osal_MemCpy((void *) &Char_Desc_Uuid.Char_UUID_16, (const void *) &cp0->Char_Desc_Uuid.Char_UUID_16, (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 1 + (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) + 2 + 2 + cp1->Char_Desc_Value_Length * (sizeof(uint8_t)) + 1 + 1 + 1 + 1 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_add_char_desc_nwk(cp0->Char_Handle /* 2 */,
                                               cp0->Char_Desc_Uuid_Type /* 1 */,
                                               &Char_Desc_Uuid /* (cp0->Char_Desc_Uuid_Type == 1 ? 2 : (cp0->Char_Desc_Uuid_Type == 2 ? 16 : 0)) */,
                                               cp1->Char_Desc_Value_Max_Len /* 2 */,
                                               cp1->Char_Desc_Value_Length /* 2 */,
                                               cp1->Char_Desc_Value /* cp1->Char_Desc_Value_Length * (sizeof(uint8_t)) */,
                                               cp2->Security_Permissions /* 1 */,
                                               cp2->Access_Permissions /* 1 */,
                                               cp2->GATT_Evt_Mask /* 1 */,
                                               cp2->Enc_Key_Size /* 1 */,
                                               cp2->Is_Variable /* 1 */,
                                               &Char_Desc_Handle);
  rp0->Char_Desc_Handle = Char_Desc_Handle;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x05;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_write_handle_value_nwk(uint16_t Attr_Handle,
                                               uint16_t Val_Offset,
                                               uint16_t Value_Length,
                                               uint8_t Value[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_write_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_write_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_write_handle_value_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_write_handle_value_nwk(cp0->Attr_Handle /* 2 */,
                                                cp0->Val_Offset /* 2 */,
                                                cp0->Value_Length /* 2 */,
                                                cp0->Value /* cp0->Value_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x06;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_rm_char_nwk(uint16_t Char_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_srv_rm_char_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_rm_char_nwk_cp0 *cp0 = (aci_gatt_srv_rm_char_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_rm_char_nwk(cp0->Char_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x07;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_rm_service_nwk(uint16_t Serv_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_srv_rm_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_rm_service_nwk_cp0 *cp0 = (aci_gatt_srv_rm_service_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_rm_service_nwk(cp0->Serv_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x08;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_rm_include_service_nwk(uint16_t Include_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_srv_rm_include_service_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_rm_include_service_nwk_cp0 *cp0 = (aci_gatt_srv_rm_include_service_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_rm_include_service_nwk(cp0->Include_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x09;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_set_event_mask(uint32_t GATT_Evt_Mask);
 */
/* Command len: 4 */
/* Response len: 1 */
uint16_t aci_gatt_set_event_mask_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_set_event_mask_cp0 *cp0 = (aci_gatt_set_event_mask_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 4)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_set_event_mask(cp0->GATT_Evt_Mask /* 4 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_exchange_config(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_exchange_config_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_exchange_config_cp0 *cp0 = (aci_gatt_clt_exchange_config_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_exchange_config(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0b;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_prepare_write_req(uint16_t Connection_Handle,
                                          uint16_t Attr_Handle,
                                          uint16_t Val_Offset,
                                          uint16_t Attribute_Val_Length,
                                          uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_prepare_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_prepare_write_req_cp0 *cp0 = (aci_gatt_clt_prepare_write_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_prepare_write_req(cp0->Connection_Handle /* 2 */,
                                           cp0->Attr_Handle /* 2 */,
                                           cp0->Val_Offset /* 2 */,
                                           cp0->Attribute_Val_Length /* 2 */,
                                           cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x10;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_execute_write_req(uint16_t Connection_Handle,
                                          uint8_t Execute);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_clt_execute_write_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_execute_write_req_cp0 *cp0 = (aci_gatt_clt_execute_write_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_execute_write_req(cp0->Connection_Handle /* 2 */,
                                           cp0->Execute /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x11;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_disc_all_primary_services(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_all_primary_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_all_primary_services_cp0 *cp0 = (aci_gatt_clt_disc_all_primary_services_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_disc_all_primary_services(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x12;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_disc_primary_service_by_uuid(uint16_t Connection_Handle,
                                                     uint8_t UUID_Type,
                                                     UUID_t *UUID);
 */
/* Command len: 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_primary_service_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_primary_service_by_uuid_cp0 *cp0 = (aci_gatt_clt_disc_primary_service_by_uuid_cp0 *)(buffer_in + (0));
  UUID_t UUID;

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy((void *) &UUID.UUID_16, (const void *) &cp0->UUID.UUID_16, (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_disc_primary_service_by_uuid(cp0->Connection_Handle /* 2 */,
                                                      cp0->UUID_Type /* 1 */,
                                                      &UUID /* (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x13;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_find_included_services(uint16_t Connection_Handle,
                                               uint16_t Start_Handle,
                                               uint16_t End_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_find_included_services_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_find_included_services_cp0 *cp0 = (aci_gatt_clt_find_included_services_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_find_included_services(cp0->Connection_Handle /* 2 */,
                                                cp0->Start_Handle /* 2 */,
                                                cp0->End_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x14;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_disc_all_char_of_service(uint16_t Connection_Handle,
                                                 uint16_t Start_Handle,
                                                 uint16_t End_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_all_char_of_service_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_all_char_of_service_cp0 *cp0 = (aci_gatt_clt_disc_all_char_of_service_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_disc_all_char_of_service(cp0->Connection_Handle /* 2 */,
                                                  cp0->Start_Handle /* 2 */,
                                                  cp0->End_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x15;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_disc_char_by_uuid(uint16_t Connection_Handle,
                                          uint16_t Start_Handle,
                                          uint16_t End_Handle,
                                          uint8_t UUID_Type,
                                          UUID_t *UUID);
 */
/* Command len: 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_char_by_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_char_by_uuid_cp0 *cp0 = (aci_gatt_clt_disc_char_by_uuid_cp0 *)(buffer_in + (0));
  UUID_t UUID;

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy((void *) &UUID.UUID_16, (const void *) &cp0->UUID.UUID_16, (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_disc_char_by_uuid(cp0->Connection_Handle /* 2 */,
                                           cp0->Start_Handle /* 2 */,
                                           cp0->End_Handle /* 2 */,
                                           cp0->UUID_Type /* 1 */,
                                           &UUID /* (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x16;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_disc_all_char_desc(uint16_t Connection_Handle,
                                           uint16_t Char_Handle,
                                           uint16_t End_Handle);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_disc_all_char_desc_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_disc_all_char_desc_cp0 *cp0 = (aci_gatt_clt_disc_all_char_desc_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_disc_all_char_desc(cp0->Connection_Handle /* 2 */,
                                            cp0->Char_Handle /* 2 */,
                                            cp0->End_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x17;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_read(uint16_t Connection_Handle,
                             uint16_t Attr_Handle);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_cp0 *cp0 = (aci_gatt_clt_read_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_read(cp0->Connection_Handle /* 2 */,
                              cp0->Attr_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x18;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_read_using_char_uuid(uint16_t Connection_Handle,
                                             uint16_t Start_Handle,
                                             uint16_t End_Handle,
                                             uint8_t UUID_Type,
                                             UUID_t *UUID);
 */
/* Command len: 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_using_char_uuid_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_using_char_uuid_cp0 *cp0 = (aci_gatt_clt_read_using_char_uuid_cp0 *)(buffer_in + (0));
  UUID_t UUID;

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  Osal_MemCpy((void *) &UUID.UUID_16, (const void *) &cp0->UUID.UUID_16, (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)));
  if(buffer_in_length != 2 + 2 + 2 + 1 + (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_read_using_char_uuid(cp0->Connection_Handle /* 2 */,
                                              cp0->Start_Handle /* 2 */,
                                              cp0->End_Handle /* 2 */,
                                              cp0->UUID_Type /* 1 */,
                                              &UUID /* (cp0->UUID_Type == 1 ? 2 : (cp0->UUID_Type == 2 ? 16 : 0)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x19;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_read_long(uint16_t Connection_Handle,
                                  uint16_t Attr_Handle,
                                  uint16_t Val_Offset);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_long_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_long_cp0 *cp0 = (aci_gatt_clt_read_long_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_read_long(cp0->Connection_Handle /* 2 */,
                                   cp0->Attr_Handle /* 2 */,
                                   cp0->Val_Offset /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1a;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_read_multiple_char_value(uint16_t Connection_Handle,
                                                 uint8_t Number_of_Handles,
                                                 Handle_Entry_t Handle_Entry[]);
 */
/* Command len: 2 + 1 + cp0->Number_of_Handles * (sizeof(packed_Handle_Entry_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_read_multiple_char_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_read_multiple_char_value_cp0 *cp0 = (aci_gatt_clt_read_multiple_char_value_cp0 *)(buffer_in + (0));
  Handle_Entry_t Handle_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(Handle_Entry_t)];

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  int i;
  for (i = 0; i < cp0->Number_of_Handles; i++) {
    Handle_Entry[i].Handle = cp0->Handle_Entry[i].Handle;
  }
  if(buffer_in_length != 2 + 1 + cp0->Number_of_Handles * (sizeof(packed_Handle_Entry_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_read_multiple_char_value(cp0->Connection_Handle /* 2 */,
                                                  cp0->Number_of_Handles /* 1 */,
                                                  Handle_Entry /* cp0->Number_of_Handles * (sizeof(packed_Handle_Entry_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1b;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_write_nwk(uint16_t Connection_Handle,
                                  uint16_t Attr_Handle,
                                  uint16_t Attribute_Val_Length,
                                  uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_nwk_cp0 *cp0 = (aci_gatt_clt_write_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_write_nwk(cp0->Connection_Handle /* 2 */,
                                   cp0->Attr_Handle /* 2 */,
                                   cp0->Attribute_Val_Length /* 2 */,
                                   cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1c;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_write_long_nwk(uint16_t Connection_Handle,
                                       uint16_t Attr_Handle,
                                       uint16_t Val_Offset,
                                       uint16_t Attribute_Val_Length,
                                       uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_long_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_long_nwk_cp0 *cp0 = (aci_gatt_clt_write_long_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_write_long_nwk(cp0->Connection_Handle /* 2 */,
                                        cp0->Attr_Handle /* 2 */,
                                        cp0->Val_Offset /* 2 */,
                                        cp0->Attribute_Val_Length /* 2 */,
                                        cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1d;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_write_char_reliable_nwk(uint16_t Connection_Handle,
                                                uint16_t Attr_Handle,
                                                uint16_t Val_Offset,
                                                uint16_t Attribute_Val_Length,
                                                uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_char_reliable_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_char_reliable_nwk_cp0 *cp0 = (aci_gatt_clt_write_char_reliable_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_write_char_reliable_nwk(cp0->Connection_Handle /* 2 */,
                                                 cp0->Attr_Handle /* 2 */,
                                                 cp0->Val_Offset /* 2 */,
                                                 cp0->Attribute_Val_Length /* 2 */,
                                                 cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x1e;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_write_without_resp(uint16_t Connection_Handle,
                                           uint16_t Attr_Handle,
                                           uint16_t Attribute_Val_Length,
                                           uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_write_without_resp_cp0 *cp0 = (aci_gatt_clt_write_without_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_write_without_resp(cp0->Connection_Handle /* 2 */,
                                            cp0->Attr_Handle /* 2 */,
                                            cp0->Attribute_Val_Length /* 2 */,
                                            cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x23;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_signed_write_without_resp(uint16_t Connection_Handle,
                                                  uint16_t Attr_Handle,
                                                  uint16_t Attribute_Val_Length,
                                                  uint8_t Attribute_Val[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_clt_signed_write_without_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_signed_write_without_resp_cp0 *cp0 = (aci_gatt_clt_signed_write_without_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Attribute_Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_signed_write_without_resp(cp0->Connection_Handle /* 2 */,
                                                   cp0->Attr_Handle /* 2 */,
                                                   cp0->Attribute_Val_Length /* 2 */,
                                                   cp0->Attribute_Val /* cp0->Attribute_Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x24;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_clt_confirm_indication(uint16_t Connection_Handle);
 */
/* Command len: 2 */
/* Response len: 1 */
uint16_t aci_gatt_clt_confirm_indication_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_clt_confirm_indication_cp0 *cp0 = (aci_gatt_clt_confirm_indication_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_clt_confirm_indication(cp0->Connection_Handle /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x25;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_set_security_permission_nwk(uint16_t Attr_Handle,
                                                    uint8_t Security_Permissions);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_srv_set_security_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_set_security_permission_nwk_cp0 *cp0 = (aci_gatt_srv_set_security_permission_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_set_security_permission_nwk(cp0->Attr_Handle /* 2 */,
                                                     cp0->Security_Permissions /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x28;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_read_handle_value_nwk(uint16_t Attr_Handle,
                                              uint16_t Offset,
                                              uint16_t Value_Length_Requested,
                                              uint16_t *Length,
                                              uint16_t *Value_Length,
                                              uint8_t Value[]);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 + 2 + 2 + rp0->Value_Length * (sizeof(uint8_t)) */
uint16_t aci_gatt_srv_read_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_read_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_read_handle_value_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gatt_srv_read_handle_value_nwk_rp0 *rp0 = (aci_gatt_srv_read_handle_value_nwk_rp0 *) (buffer_out + 6);
  uint16_t Length = 0;
  uint16_t Value_Length = 0;
  uint8_t Value[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)];

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_read_handle_value_nwk(cp0->Attr_Handle /* 2 */,
                                                   cp0->Offset /* 2 */,
                                                   cp0->Value_Length_Requested /* 2 */,
                                                   &Length,
                                                   &Value_Length,
                                                   Value);
  output_size += 1;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Length = Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Length = Value_Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (rp0->Value_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Value,(const void *) Value, rp0->Value_Length * (sizeof(uint8_t)));
  output_size += rp0->Value_Length * (sizeof(uint8_t));
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2a;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_set_access_permission_nwk(uint16_t Attr_Handle,
                                                  uint8_t Access_Permissions);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_srv_set_access_permission_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_set_access_permission_nwk_cp0 *cp0 = (aci_gatt_srv_set_access_permission_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_set_access_permission_nwk(cp0->Attr_Handle /* 2 */,
                                                   cp0->Access_Permissions /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2e;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_notify(uint16_t Connection_Handle,
                               uint16_t Attr_Handle,
                               uint8_t Flags,
                               uint16_t Val_Length,
                               uint8_t Val[]);
 */
/* Command len: 2 + 2 + 1 + 2 + cp0->Val_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_notify_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_notify_cp0 *cp0 = (aci_gatt_srv_notify_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 2 + cp0->Val_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_notify(cp0->Connection_Handle /* 2 */,
                                cp0->Attr_Handle /* 2 */,
                                cp0->Flags /* 1 */,
                                cp0->Val_Length /* 2 */,
                                cp0->Val /* cp0->Val_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x2f;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_exec_write_resp_nwk(uint16_t Conn_Handle,
                                            uint8_t Exec);
 */
/* Command len: 2 + 1 */
/* Response len: 1 */
uint16_t aci_gatt_srv_exec_write_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_exec_write_resp_nwk_cp0 *cp0 = (aci_gatt_srv_exec_write_resp_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_exec_write_resp_nwk(cp0->Conn_Handle /* 2 */,
                                             cp0->Exec /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x31;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_authorize_resp_nwk(uint16_t Conn_Handle,
                                           uint16_t Attr_Handle,
                                           uint8_t Operation_Type,
                                           uint8_t Error_Code,
                                           uint16_t Attr_Val_Offset,
                                           uint16_t Data_Length,
                                           uint8_t Data[]);
 */
/* Command len: 2 + 2 + 1 + 1 + 2 + 2 + cp0->Data_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_authorize_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_authorize_resp_nwk_cp0 *cp0 = (aci_gatt_srv_authorize_resp_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1 + 1 + 2 + 2 + cp0->Data_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_authorize_resp_nwk(cp0->Conn_Handle /* 2 */,
                                            cp0->Attr_Handle /* 2 */,
                                            cp0->Operation_Type /* 1 */,
                                            cp0->Error_Code /* 1 */,
                                            cp0->Attr_Val_Offset /* 2 */,
                                            cp0->Data_Length /* 2 */,
                                            cp0->Data /* cp0->Data_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x33;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_read_prepare_queue_nwk(uint16_t Conn_Handle,
                                               uint8_t Item_Index,
                                               uint16_t *Attr_Handle,
                                               uint16_t *Value_Offset,
                                               uint16_t *Value_Length,
                                               uint8_t Value[]);
 */
/* Command len: 2 + 1 */
/* Response len: 1 + 2 + 2 + 2 + rp0->Value_Length * (sizeof(uint8_t)) */
uint16_t aci_gatt_srv_read_prepare_queue_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_read_prepare_queue_nwk_cp0 *cp0 = (aci_gatt_srv_read_prepare_queue_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gatt_srv_read_prepare_queue_nwk_rp0 *rp0 = (aci_gatt_srv_read_prepare_queue_nwk_rp0 *) (buffer_out + 6);
  uint16_t Attr_Handle = 0;
  uint16_t Value_Offset = 0;
  uint16_t Value_Length = 0;
  uint8_t Value[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)];

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_read_prepare_queue_nwk(cp0->Conn_Handle /* 2 */,
                                                    cp0->Item_Index /* 1 */,
                                                    &Attr_Handle,
                                                    &Value_Offset,
                                                    &Value_Length,
                                                    Value);
  output_size += 1;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Attr_Handle = Attr_Handle;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Offset = Value_Offset;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Length = Value_Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (rp0->Value_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Value,(const void *) Value, rp0->Value_Length * (sizeof(uint8_t)));
  output_size += rp0->Value_Length * (sizeof(uint8_t));
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x35;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_write_multiple_instance_handle_value(uint16_t Connection_Handle,
                                                             uint16_t Attr_Handle,
                                                             uint16_t Value_Length,
                                                             uint8_t Value[]);
 */
/* Command len: 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_gatt_srv_write_multiple_instance_handle_value_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_write_multiple_instance_handle_value_cp0 *cp0 = (aci_gatt_srv_write_multiple_instance_handle_value_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->Value_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_gatt_srv_write_multiple_instance_handle_value(cp0->Connection_Handle /* 2 */,
                                                              cp0->Attr_Handle /* 2 */,
                                                              cp0->Value_Length /* 2 */,
                                                              cp0->Value /* cp0->Value_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x36;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_gatt_srv_read_multiple_instance_handle_value_nwk(uint16_t Connection_Handle,
                                                                uint16_t Attr_Handle,
                                                                uint16_t *Value_Length,
                                                                uint8_t Value[]);
 */
/* Command len: 2 + 2 */
/* Response len: 1 + 2 + rp0->Value_Length * (sizeof(uint8_t)) */
uint16_t aci_gatt_srv_read_multiple_instance_handle_value_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0 *cp0 = (aci_gatt_srv_read_multiple_instance_handle_value_nwk_cp0 *)(buffer_in + (0));

  int output_size = 0;
  /* Output params */
  aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0 *rp0 = (aci_gatt_srv_read_multiple_instance_handle_value_nwk_rp0 *) (buffer_out + 6);
  uint16_t Value_Length = 0;
  uint8_t Value[HCI_MAX_PAYLOAD_SIZE/sizeof(uint8_t)];

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_gatt_srv_read_multiple_instance_handle_value_nwk(cp0->Connection_Handle /* 2 */,
                                                                     cp0->Attr_Handle /* 2 */,
                                                                     &Value_Length,
                                                                     Value);
  output_size += 1;
  if (buffer_out_max_length < (output_size + (2) + 6)) { return 0; }
  rp0->Value_Length = Value_Length;
  output_size += 2;
  if (buffer_out_max_length < (output_size + (rp0->Value_Length * (sizeof(uint8_t))) + 6)) { return 0; }
  Osal_MemCpy((void *) rp0->Value,(const void *) Value, rp0->Value_Length * (sizeof(uint8_t)));
  output_size += rp0->Value_Length * (sizeof(uint8_t));
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x37;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_connection_parameter_update_req(uint16_t Connection_Handle,
                                                     uint16_t Conn_Interval_Min,
                                                     uint16_t Conn_Interval_Max,
                                                     uint16_t Slave_latency,
                                                     uint16_t Timeout_Multiplier);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_l2cap_connection_parameter_update_req_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_connection_parameter_update_req_cp0 *cp0 = (aci_l2cap_connection_parameter_update_req_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_l2cap_connection_parameter_update_req(cp0->Connection_Handle /* 2 */,
                                                      cp0->Conn_Interval_Min /* 2 */,
                                                      cp0->Conn_Interval_Max /* 2 */,
                                                      cp0->Slave_latency /* 2 */,
                                                      cp0->Timeout_Multiplier /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x81;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_connection_parameter_update_resp(uint16_t Connection_Handle,
                                                      uint16_t Conn_Interval_Min,
                                                      uint16_t Conn_Interval_Max,
                                                      uint16_t Slave_latency,
                                                      uint16_t Timeout_Multiplier,
                                                      uint16_t Minimum_CE_Length,
                                                      uint16_t Maximum_CE_Length,
                                                      uint8_t Identifier,
                                                      uint8_t Accept);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 */
/* Response len: 1 */
uint16_t aci_l2cap_connection_parameter_update_resp_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_connection_parameter_update_resp_cp0 *cp0 = (aci_l2cap_connection_parameter_update_resp_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_l2cap_connection_parameter_update_resp(cp0->Connection_Handle /* 2 */,
                                                       cp0->Conn_Interval_Min /* 2 */,
                                                       cp0->Conn_Interval_Max /* 2 */,
                                                       cp0->Slave_latency /* 2 */,
                                                       cp0->Timeout_Multiplier /* 2 */,
                                                       cp0->Minimum_CE_Length /* 2 */,
                                                       cp0->Maximum_CE_Length /* 2 */,
                                                       cp0->Identifier /* 1 */,
                                                       cp0->Accept /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x82;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_cfc_connection_req_nwk(uint16_t Connection_Handle,
                                            uint16_t SPSM,
                                            uint16_t CID,
                                            uint16_t MTU,
                                            uint16_t MPS,
                                            uint8_t CFC_Policy);
 */
/* Command len: 2 + 2 + 2 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_l2cap_cfc_connection_req_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cfc_connection_req_nwk_cp0 *cp0 = (aci_l2cap_cfc_connection_req_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_l2cap_cfc_connection_req_nwk(cp0->Connection_Handle /* 2 */,
                                             cp0->SPSM /* 2 */,
                                             cp0->CID /* 2 */,
                                             cp0->MTU /* 2 */,
                                             cp0->MPS /* 2 */,
                                             cp0->CFC_Policy /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x83;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_cfc_connection_resp_nwk(uint16_t Connection_Handle,
                                             uint8_t Identifier,
                                             uint16_t CID,
                                             uint16_t MTU,
                                             uint16_t MPS,
                                             uint16_t Result,
                                             uint8_t CFC_Policy);
 */
/* Command len: 2 + 1 + 2 + 2 + 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_l2cap_cfc_connection_resp_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_cfc_connection_resp_nwk_cp0 *cp0 = (aci_l2cap_cfc_connection_resp_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 1 + 2 + 2 + 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_l2cap_cfc_connection_resp_nwk(cp0->Connection_Handle /* 2 */,
                                              cp0->Identifier /* 1 */,
                                              cp0->CID /* 2 */,
                                              cp0->MTU /* 2 */,
                                              cp0->MPS /* 2 */,
                                              cp0->Result /* 2 */,
                                              cp0->CFC_Policy /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x84;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_send_flow_control_credits(uint16_t Connection_Handle,
                                               uint16_t CID,
                                               uint16_t RX_Credits,
                                               uint8_t CFC_Policy,
                                               uint16_t *RX_Credit_Balance);
 */
/* Command len: 2 + 2 + 2 + 1 */
/* Response len: 1 + 2 */
uint16_t aci_l2cap_send_flow_control_credits_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_send_flow_control_credits_cp0 *cp0 = (aci_l2cap_send_flow_control_credits_cp0 *)(buffer_in + (0));

  int output_size = 1 + 2;
  /* Output params */
  aci_l2cap_send_flow_control_credits_rp0 *rp0 = (aci_l2cap_send_flow_control_credits_rp0 *) (buffer_out + 6);
  uint16_t RX_Credit_Balance = 0;

  if (buffer_out_max_length < (1 + 2 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 1)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_l2cap_send_flow_control_credits(cp0->Connection_Handle /* 2 */,
                                                    cp0->CID /* 2 */,
                                                    cp0->RX_Credits /* 2 */,
                                                    cp0->CFC_Policy /* 1 */,
                                                    &RX_Credit_Balance);
  rp0->RX_Credit_Balance = RX_Credit_Balance;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x85;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_disconnect(uint16_t Connection_Handle,
                                uint16_t CID);
 */
/* Command len: 2 + 2 */
/* Response len: 1 */
uint16_t aci_l2cap_disconnect_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_disconnect_cp0 *cp0 = (aci_l2cap_disconnect_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 3);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_l2cap_disconnect(cp0->Connection_Handle /* 2 */,
                                 cp0->CID /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0F;
  buffer_out[2] = output_size + 3;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x86;
  buffer_out[6] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_l2cap_transmit_sdu_data_nwk(uint16_t Connection_Handle,
                                           uint16_t CID,
                                           uint16_t SDU_Length,
                                           uint8_t SDU_Data[]);
 */
/* Command len: 2 + 2 + 2 + cp0->SDU_Length * (sizeof(uint8_t)) */
/* Response len: 1 */
uint16_t aci_l2cap_transmit_sdu_data_nwk_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_l2cap_transmit_sdu_data_nwk_cp0 *cp0 = (aci_l2cap_transmit_sdu_data_nwk_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + cp0->SDU_Length * (sizeof(uint8_t)))
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_l2cap_transmit_sdu_data_nwk(cp0->Connection_Handle /* 2 */,
                                            cp0->CID /* 2 */,
                                            cp0->SDU_Length /* 2 */,
                                            cp0->SDU_Data /* cp0->SDU_Length * (sizeof(uint8_t)) */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x87;
  buffer_out[5] = 0xfd;
  return (output_size + 6);
}
/* tBleStatus aci_test_tx_notification_start(uint16_t Connection_Handle,
                                          uint16_t Service_Handle,
                                          uint16_t Char_Handle,
                                          uint16_t Value_Length);
 */
/* Command len: 2 + 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_test_tx_notification_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_tx_notification_start_cp0 *cp0 = (aci_test_tx_notification_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_test_tx_notification_start(cp0->Connection_Handle /* 2 */,
                                           cp0->Service_Handle /* 2 */,
                                           cp0->Char_Handle /* 2 */,
                                           cp0->Value_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x00;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
/* tBleStatus aci_test_tx_write_command_start(uint16_t Connection_Handle,
                                           uint16_t Attr_Handle,
                                           uint16_t Value_Length);
 */
/* Command len: 2 + 2 + 2 */
/* Response len: 1 */
uint16_t aci_test_tx_write_command_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_tx_write_command_start_cp0 *cp0 = (aci_test_tx_write_command_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 2)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_test_tx_write_command_start(cp0->Connection_Handle /* 2 */,
                                            cp0->Attr_Handle /* 2 */,
                                            cp0->Value_Length /* 2 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x01;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
/* tBleStatus aci_test_rx_start(uint16_t Connection_Handle,
                             uint16_t Attr_Handle,
                             uint8_t Notifications_WriteCmds);
 */
/* Command len: 2 + 2 + 1 */
/* Response len: 1 */
uint16_t aci_test_rx_start_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_rx_start_cp0 *cp0 = (aci_test_rx_start_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 2 + 2 + 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_test_rx_start(cp0->Connection_Handle /* 2 */,
                              cp0->Attr_Handle /* 2 */,
                              cp0->Notifications_WriteCmds /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x02;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
/* tBleStatus aci_test_stop(uint8_t TX_RX);
 */
/* Command len: 1 */
/* Response len: 1 */
uint16_t aci_test_stop_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{
  /* Input params */
  aci_test_stop_cp0 *cp0 = (aci_test_stop_cp0 *)(buffer_in + (0));

  int output_size = 1;
  /* Output params */
  uint8_t *status = (uint8_t *) (buffer_out + 6);

  if (buffer_out_max_length < (1 + 6)) { return 0; }
  if(buffer_in_length != 1)
  {
    *status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  *status = aci_test_stop(cp0->TX_RX /* 1 */);
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x03;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
/* tBleStatus aci_test_report(uint32_t *TX_Packets,
                           uint32_t *RX_Packets,
                           uint16_t *RX_Data_Length,
                           uint32_t *RX_Sequence_Errors);
 */
/* Command len: 0 */
/* Response len: 1 + 4 + 4 + 2 + 4 */
uint16_t aci_test_report_process(uint8_t *buffer_in, uint16_t buffer_in_length, uint8_t *buffer_out, uint16_t buffer_out_max_length)
{

  int output_size = 1 + 4 + 4 + 2 + 4;
  /* Output params */
  aci_test_report_rp0 *rp0 = (aci_test_report_rp0 *) (buffer_out + 6);
  uint32_t TX_Packets = 0;
  uint32_t RX_Packets = 0;
  uint16_t RX_Data_Length = 0;
  uint32_t RX_Sequence_Errors = 0;

  if (buffer_out_max_length < (1 + 4 + 4 + 2 + 4 + 6)) { return 0; }
  if(buffer_in_length != 0)
  {
    rp0->Status = BLE_ERROR_INVALID_HCI_CMD_PARAMS;
    goto fail;
  }

  rp0->Status = aci_test_report(&TX_Packets,
                                &RX_Packets,
                                &RX_Data_Length,
                                &RX_Sequence_Errors);
  rp0->TX_Packets = TX_Packets;
  rp0->RX_Packets = RX_Packets;
  rp0->RX_Data_Length = RX_Data_Length;
  rp0->RX_Sequence_Errors = RX_Sequence_Errors;
fail:
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0E;
  buffer_out[2] = output_size + 3;
  buffer_out[3] = 0x01;
  buffer_out[4] = 0x04;
  buffer_out[5] = 0xfe;
  return (output_size + 6);
}
int hci_disconnection_complete_event_preprocess(uint8_t Status,
                                                uint16_t Connection_Handle,
                                                uint8_t Reason);
/* hci_disconnection_complete_event */
/* Event len: 1 + 2 + 1 */
/**
 * @brief The Disconnection Complete event occurs when a connection is
 *        terminated. The status parameter indicates if the disconnection was
 *        successful or not. The reason parameter indicates the reason for the
 *        disconnection if the disconnection was successful. If the
 *        disconnection was not successful, the value of the reason parameter
 *        can be ignored by the Host. For example, this can be the case if the
 *        Host has issued the Disconnect command and there was a parameter
 *        error, or the command was not presently allowed, or a
 *        Connection_Handle that didn't correspond to a connection was given.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection_Handle which was disconnected.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Reason Reason for disconnection. See Error Codes.
 * @retval None
 */
void hci_disconnection_complete_event(uint8_t Status,
                                      uint16_t Connection_Handle,
                                      uint8_t Reason)
{
  uint8_t buffer_out[258];

  if(hci_disconnection_complete_event_preprocess(Status, Connection_Handle, Reason)) return;

  /* Output params */
  hci_disconnection_complete_event_rp0 *rp0 = (hci_disconnection_complete_event_rp0 *) (buffer_out + 3);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Reason = Reason;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x05;
  buffer_out[2] = 1 + 2 + 1;
  send_event(buffer_out, buffer_out[2] + 3, 0);
}

/* hci_encryption_change_event */
/* Event len: 1 + 2 + 1 */
/**
 * @brief The Encryption Change event is used to indicate that the change of the
 *        encryption mode has been completed. The Connection_Handle will be a
 *        Connection_Handle for an ACL connection. The Encryption_Enabled event
 *        parameter specifies the new Encryption_Enabled parameter for the
 *        Connection_Handle specified by the Connection_Handle event parameter.
 *        This event will occur on both devices to notify the Hosts when
 *        Encryption has changed for the specified Connection_Handle between two
 *        devices. Note: This event shall not be generated if encryption is
 *        paused or resumed; during a role switch, for example. The meaning of
 *        the Encryption_Enabled parameter depends on whether the Host has
 *        indicated support for Secure Connections in the
 *        Secure_Connections_Host_Support parameter. When
 *        Secure_Connections_Host_Support is 'disabled' or the Connection_Handle
 *        refers to an LE link, the Controller shall only use Encryption_Enabled
 *        values 0x00 (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1,
 *        Vol. 2, Part E, 7.7.8)
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Encryption_Enabled Link Level Encryption.
 *        Values:
 *        - 0x00: Link Level Encryption OFF
 *        - 0x01: Link Level Encryption is ON with AES-CCM
 * @retval None
 */
void hci_encryption_change_event(uint8_t Status,
                                 uint16_t Connection_Handle,
                                 uint8_t Encryption_Enabled)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_encryption_change_event_rp0 *rp0 = (hci_encryption_change_event_rp0 *) (buffer_out + 3);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Encryption_Enabled = Encryption_Enabled;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x08;
  buffer_out[2] = 1 + 2 + 1;
  send_event(buffer_out, buffer_out[2] + 3, 1);
}

/* hci_read_remote_version_information_complete_event */
/* Event len: 1 + 2 + 1 + 2 + 2 */
/**
 * @brief The Read Remote Version Information Complete event is used to indicate
 *        the completion of the process obtaining the version information of the
 *        remote Controller specified by the Connection_Handle event parameter.
 *        The Connection_Handle shall be for an ACL connection. The Version
 *        event parameter defines the specification version of the LE
 *        Controller. The Manufacturer_Name event parameter indicates the
 *        manufacturer of the remote Controller. The Subversion event parameter
 *        is controlled by the manufacturer and is implementation dependent. The
 *        Subversion event parameter defines the various revisions that each
 *        version of the Bluetooth hardware will go through as design processes
 *        change and errors are fixed. This allows the software to determine
 *        what Bluetooth hardware is being used and, if necessary, to work
 *        around various bugs in the hardware. When the Connection_Handle is
 *        associated with an LE-U logical link, the Version event parameter
 *        shall be Link Layer VersNr parameter, the Manufacturer_Name event
 *        parameter shall be the CompId parameter, and the Subversion event
 *        parameter shall be the SubVersNr parameter. (See Bluetooth
 *        Specification v.4.1, Vol. 2, Part E, 7.7.12)
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Version Version of the Current LMP in the remote Controller
 * @param Manufacturer_Name Manufacturer Name of the remote Controller
 * @param Subversion Subversion of the LMP in the remote Controller
 * @retval None
 */
void hci_read_remote_version_information_complete_event(uint8_t Status,
                                                        uint16_t Connection_Handle,
                                                        uint8_t Version,
                                                        uint16_t Manufacturer_Name,
                                                        uint16_t Subversion)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_read_remote_version_information_complete_event_rp0 *rp0 = (hci_read_remote_version_information_complete_event_rp0 *) (buffer_out + 3);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Version = Version;
  rp0->Manufacturer_Name = Manufacturer_Name;
  rp0->Subversion = Subversion;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x0c;
  buffer_out[2] = 1 + 2 + 1 + 2 + 2;
  send_event(buffer_out, buffer_out[2] + 3, 2);
}

/* hci_hardware_error_event */
/* Event len: 1 */
/**
 * @brief The Hardware Error event is used to indicate some implementation
 *        specific type of hardware failure for the controller. This event is
 *        used to notify the Host that a hardware failure has occurred in the
 *        Controller.
 * @param Hardware_Code Error code 0x01 and 0x02 are errors generally caused by
 *        hardware issue on the PCB; another possible cause is a slow crystal
 *        startup. In the latter case, the HS_STARTUP_TIME in the device
 *        configuration needs to be tuned. Error code 0x03 indicates an internal
 *        error of the protocol stack. This event with error code 0x04 is raised
 *        when a radio interrupt is served late. This usually happens when
 *        interrupts are disabled for too long time or when a flash operation is
 *        performed. Stack will try to recover the situation, so there is
 *        normally no need to reset the device. However this condition should be
 *        avoided as much as possible. Error code 0x05 is raised when an error
 *        happens during a TX transaction. After this event is received with
 *        error code 0x00, 0x01, 0x02 or 0x03, it is recommended to force a
 *        device reset.
 *        Values:
 *        - 0x00: Generic HW error
 *        - 0x01: Radio state error
 *        - 0x02: Timer overrun error
 *        - 0x03: Internal queue overflow error
 *        - 0x04: Late Radio ISR
 *        - 0x05: TX Error
 * @retval None
 */
void hci_hardware_error_event(uint8_t Hardware_Code)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_hardware_error_event_rp0 *rp0 = (hci_hardware_error_event_rp0 *) (buffer_out + 3);
  rp0->Hardware_Code = Hardware_Code;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x10;
  buffer_out[2] = 1;
  send_event(buffer_out, buffer_out[2] + 3, 5);
}

/* hci_number_of_completed_packets_event */
/* Event len: 1 + rp0->Number_of_Handles * (sizeof(packed_Handle_Packets_Pair_Entry_t)) */
/**
 * @brief The Number Of Completed Packets event is used by the Controller to
 *        indicate to the Host how many HCI Data Packets have been completed
 *        (transmitted or flushed) for each Connection_Handle since the previous
 *        Number Of Completed Packets event was sent to the Host. This means
 *        that the corresponding buffer space has been freed in the Controller.
 *        Based on this information, and the HC_Total_Num_ACL_Data_Packets and
 *        HC_Total_Num_Synchronous_- Data_Packets return parameter of the
 *        Read_Buffer_Size command, the Host can determine for which
 *        Connection_Handles the following HCI Data Packets should be sent to
 *        the Controller. The Number Of Completed Packets event must not be sent
 *        before the corresponding Connection Complete event. While the
 *        Controller has HCI data packets in its buffer, it must keep sending
 *        the Number Of Completed Packets event to the Host at least
 *        periodically, until it finally reports that all the pending ACL Data
 *        Packets have been transmitted or flushed.
 * @param Number_of_Handles The number of Connection_Handles and
 *        Num_HCI_Data_Packets parameters pairs contained in this event
 * @param Handle_Packets_Pair_Entry See @ref Handle_Packets_Pair_Entry_t
 * @retval None
 */
void hci_number_of_completed_packets_event(uint8_t Number_of_Handles,
                                           Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[])
{
  uint8_t buffer_out[258];
  int output_size = 0;
  /* Output params */
  hci_number_of_completed_packets_event_rp0 *rp0 = (hci_number_of_completed_packets_event_rp0 *) (buffer_out + 3);
  rp0->Number_of_Handles = Number_of_Handles;
  {
    int i;
    for (i = 0; i < Number_of_Handles; i++) {
      rp0->Handle_Packets_Pair_Entry[i].Connection_Handle = Handle_Packets_Pair_Entry[i].Connection_Handle;
      output_size += sizeof(uint16_t);
      rp0->Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets = Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets;
      output_size += sizeof(uint16_t);
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x13;
  buffer_out[2] = 1 + output_size;
  send_event(buffer_out, buffer_out[2] + 3, 6);
}

/* hci_data_buffer_overflow_event */
/* Event len: 1 */
/**
 * @brief 'This event is used to indicate that the Controller's data buffers
 *        have been overflowed. This can occur if the Host has sent more packets
 *        than allowed. The Link_Type parameter is used to indicate that the
 *        overflow was caused by ACL data.
 * @param Link_Type On which type of channel overflow has occurred.
 *        Values:
 *        - 0x01: ACL Buffer Overflow
 * @retval None
 */
void hci_data_buffer_overflow_event(uint8_t Link_Type)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_data_buffer_overflow_event_rp0 *rp0 = (hci_data_buffer_overflow_event_rp0 *) (buffer_out + 3);
  rp0->Link_Type = Link_Type;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x1a;
  buffer_out[2] = 1;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_encryption_key_refresh_complete_event */
/* Event len: 1 + 2 */
/**
 * @brief 'The Encryption Key Refresh Complete event is used to indicate to the
 *        Host that the encryption key was refreshed on the given
 *        Connection_Handle any time encryption is paused and then resumed. If
 *        the Encryption Key Refresh Complete event was generated due to an
 *        encryption pause and resume operation embedded within a change
 *        connection link key procedure, the Encryption Key Refresh Complete
 *        event shall be sent prior to the Change Connection Link Key Complete
 *        event. If the Encryption Key Refresh Complete event was generated due
 *        to an encryption pause and resume operation embedded within a role
 *        switch procedure, the Encryption Key Refresh Complete event shall be
 *        sent prior to the Role Change event.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
void hci_encryption_key_refresh_complete_event(uint8_t Status,
                                               uint16_t Connection_Handle)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_encryption_key_refresh_complete_event_rp0 *rp0 = (hci_encryption_key_refresh_complete_event_rp0 *) (buffer_out + 3);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x30;
  buffer_out[2] = 1 + 2;
  send_event(buffer_out, buffer_out[2] + 3, 7);
}

/* hci_authenticated_payload_timeout_expired_event */
/* Event len: 2 */
/**
 * @brief The HCI_Authenticated_Payload_Timeout_Expired event is used to
 *        indicate that a packet containing a valid MIC on the Connection_Handle
 *        was not received within the authenticatedPayloadTO. Note: A Host may
 *        choose to disconnect the link when this occurs.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
void hci_authenticated_payload_timeout_expired_event(uint16_t Connection_Handle)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_authenticated_payload_timeout_expired_event_rp0 *rp0 = (hci_authenticated_payload_timeout_expired_event_rp0 *) (buffer_out + 3);
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x57;
  buffer_out[2] = 2;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* aci_blue_initialized_event */
/* Event len: 1 */
/**
 * @brief This event inform the application that the network coprocessor has
 *        been reset. If the reason code is a system crash, a following event
 *        @ref aci_blue_crash_info_event will provide more information regarding
 *        the system crash details.
 * @param Reason_Code Reason code describing why device was reset and in which
 *        mode is operating (Updater or Normal mode)
 *        Values:
 *        - 0x01: Firmware started properly
 *        - 0x02: Updater mode entered with ACI command
 *        - 0x03: Updater mode entered due to bad Blue Flag
 *        - 0x04: Updater mode entered due to boot pin
 *        - 0x05: System reset due to watchdog
 *        - 0x06: System reset due to lockup
 *        - 0x07: System reset due to brownout reset
 *        - 0x08: System reset due to crash
 *        - 0x09: System reset due to ECC error
 * @retval None
 */
void aci_blue_initialized_event(uint8_t Reason_Code)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *) (buffer_out + 6);
  rp0->Reason_Code = Reason_Code;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 2);
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 1 + 6, 8);
}

/* aci_blue_events_lost_event */
/* Event len: 8 */
/**
 * @brief This event is generated when an overflow occurs in the event queue
 *        read by the external microcontroller. This is normally caused when the
 *        external microcontroller does  not read pending events. The returned
 *        bitmap indicates which event has been lost. Please  note that one bit
 *        set to 1 indicates one or more occurrences of the particular events.
 *        The event ACI_BLUE_EVENTS_LOST_EVENT cannot be lost and it will
 *        inserted in the event queue as soon as a position is freed in the
 *        event queue. This event should not happen under normal operating
 *        condition where external microcontroller promptly reads events
 *        signaled by IRQ pin. It is provided to detected unexpected behavior of
 *        the external microcontroller or to allow application to recover
 *        situations where critical events are lost.
 * @param Lost_Events Bitmap of lost events. Each bit indicates one or more
 *        occurrences of the specific event.
 *        Flags:
 *        - 0x0000000000000001: HCI_DISCONNECTION_COMPLETE_EVENT
 *        - 0x0000000000000002: HCI_ENCRYPTION_CHANGE_EVENT
 *        - 0x0000000000000004: HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT
 *        - 0x0000000000000008: HCI_COMMAND_COMPLETE_EVENT
 *        - 0x0000000000000010: HCI_COMMAND_STATUS_EVENT
 *        - 0x0000000000000020: HCI_HARDWARE_ERROR_EVENT
 *        - 0x0000000000000040: HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT
 *        - 0x0000000000000080: HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT
 *        - 0x0000000000000100: ACI_BLUE_INITIALIZED_EVENT
 *        - 0x0000000000000200: ACI_GAP_LIMITED_DISCOVERABLE_EVENT
 *        - 0x0000000000000400: ACI_GAP_PAIRING_COMPLETE_EVENT
 *        - 0x0000000000000800: ACI_GAP_PASS_KEY_REQ_EVENT
 *        - 0x0000000000001000: ACI_GAP_AUTHORIZATION_REQ_EVENT
 *        - 0x0000000000002000: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
 *        - 0x0000000000004000: ACI_GAP_BOND_LOST_EVENT
 *        - 0x0000000000008000: ACI_GAP_PROC_COMPLETE_EVENT
 *        - 0x0000000000010000: ACI_GAP_ADDR_NOT_RESOLVED_EVENT
 *        - 0x0000000000020000: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
 *        - 0x0000000000040000: ACI_L2CAP_PROC_TIMEOUT_EVENT
 *        - 0x0000000000080000: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
 *        - 0x0000000000100000: ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
 *        - 0x0000000000200000: ACI_GATT_PROC_TIMEOUT_EVENT
 *        - 0x0000000000400000: ACI_ATT_EXCHANGE_MTU_RESP_EVENT
 *        - 0x0000000000800000: ACI_ATT_FIND_INFO_RESP_EVENT
 *        - 0x0000000001000000: ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
 *        - 0x0000000002000000: ACI_ATT_READ_BY_TYPE_RESP_EVENT
 *        - 0x0000000004000000: ACI_ATT_READ_RESP_EVENT
 *        - 0x0000000008000000: ACI_ATT_READ_BLOB_RESP_EVENT
 *        - 0x0000000010000000: ACI_ATT_READ_MULTIPLE_RESP_EVENT
 *        - 0x0000000020000000: ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
 *        - 0x0000000040000000: ACI_ATT_WRITE_RESP_EVENT
 *        - 0x0000000080000000: ACI_ATT_PREPARE_WRITE_RESP_EVENT
 *        - 0x0000000100000000: ACI_ATT_EXEC_WRITE_RESP_EVENT
 *        - 0x0000000200000000: ACI_GATT_INDICATION_EVENT
 *        - 0x0000000400000000: ACI_GATT_NOTIFICATION_EVENT
 *        - 0x0000000800000000: ACI_GATT_PROC_COMPLETE_EVENT
 *        - 0x0000001000000000: ACI_GATT_ERROR_RESP_EVENT
 *        - 0x0000002000000000: ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
 *        - 0x0000004000000000: ACI_GATT_WRITE_PERMIT_REQ_EVENT
 *        - 0x0000008000000000: ACI_GATT_READ_PERMIT_REQ_EVENT
 *        - 0x0000010000000000: ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT
 *        - 0x0000020000000000: ACI_GATT_TX_POOL_AVAILABLE_EVENT
 *        - 0x0000040000000000: ACI_GATT_SERVER_CONFIRMATION_EVENT
 *        - 0x0000080000000000: ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT
 *        - 0x0000100000000000: HCI_LE_CONNECTION_COMPLETE_EVENT
 *        - 0x0000200000000000: HCI_LE_ADVERTISING_REPORT_EVENT
 *        - 0x0000400000000000: HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT
 *        - 0x0000800000000000: HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT
 *        - 0x0001000000000000: HCI_LE_LONG_TERM_KEY_REQUEST_EVENT
 *        - 0x0002000000000000: HCI_LE_DATA_LENGTH_CHANGE_EVENT
 *        - 0x0004000000000000: HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_EVENT
 *        - 0x0008000000000000: HCI_LE_GENERATE_DHKEY_COMPLETE_EVENT
 *        - 0x0010000000000000: HCI_LE_ENHANCED_CONNECTION_COMPLETE_EVENT
 *        - 0x0020000000000000: HCI_LE_DIRECT_ADVERTISING_REPORT_EVENT
 *        - 0x0040000000000000: ACI_GAP_NUMERIC_COMPARISON_VALUE_EVENT
 *        - 0x0080000000000000: ACI_GAP_KEYPRESS_NOTIFICATION_EVENT
 * @retval None
 */
void aci_blue_events_lost_event(uint8_t Lost_Events[8])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_blue_events_lost_event_rp0 *rp0 = (aci_blue_events_lost_event_rp0 *) (buffer_out + 6);
  Osal_MemCpy((void *) rp0->Lost_Events,(const void *) Lost_Events, 8);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,8 + 2);
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 8 + 6, -1);
}

/* aci_blue_crash_info_event */
/* Event len: 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + rp0->Debug_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is given to the application after the @ref
 *        aci_blue_initialized_event when a system crash is detected. This
 *        events returns system crash information for debugging purposes.
 *        Information reported are useful to understand the root cause of the
 *        crash.
 * @param Crash_Type Crash type
 *        Values:
 *        - 0x00: Assert failed
 *        - 0x01: NMI fault
 *        - 0x02: Hard fault
 * @param SP Stack pointer
 * @param R0 Register R0
 * @param R1 Register R1
 * @param R2 Register R2
 * @param R3 Register R3
 * @param R12 Register R12
 * @param LR Link register
 * @param PC Program counter where crash occurred
 * @param xPSR xPSR register
 * @param Debug_Data_Length Length of Debug_Data field
 * @param Debug_Data Debug data
 * @retval None
 */
void aci_blue_crash_info_event(uint8_t Crash_Type,
                               uint32_t SP,
                               uint32_t R0,
                               uint32_t R1,
                               uint32_t R2,
                               uint32_t R3,
                               uint32_t R12,
                               uint32_t LR,
                               uint32_t PC,
                               uint32_t xPSR,
                               uint8_t Debug_Data_Length,
                               uint8_t Debug_Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_blue_crash_info_event_rp0 *rp0 = (aci_blue_crash_info_event_rp0 *) (buffer_out + 6);
  rp0->Crash_Type = Crash_Type;
  rp0->SP = SP;
  rp0->R0 = R0;
  rp0->R1 = R1;
  rp0->R2 = R2;
  rp0->R3 = R3;
  rp0->R12 = R12;
  rp0->LR = LR;
  rp0->PC = PC;
  rp0->xPSR = xPSR;
  rp0->Debug_Data_Length = Debug_Data_Length;
  Osal_MemCpy((void *) rp0->Debug_Data,(const void *) Debug_Data, Debug_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + Debug_Data_Length + 2);
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + Debug_Data_Length + 6, -1);
}

/* aci_hal_end_of_radio_activity_event */
/* Event len: 1 + 1 + 4 */
/**
 * @brief This event is generated when the device completes a radio activity and
 *        provide information when a new radio activity will be performed.
 *        Information provided includes type of radio activity and absolute time
 *        in system ticks when a new radio activity is schedule, if any.
 *        Application can use this information to schedule user activities
 *        synchronous to selected radio activities. A command @ref
 *        aci_hal_set_radio_activity_mask is provided to enable radio activity
 *        events of user interests, by default no events are enabled. User
 *        should take into account that enabling radio events in application
 *        with intense radio activity could lead to a fairly high rate of events
 *        generated. Application use cases includes synchronizing notification
 *        with connection interval, switching  antenna at the end of advertising
 *        or performing flash erase operation while radio is idle.
 * @param Last_State Completed radio events
 *        Values:
 *        - 0x00: Idle
 *        - 0x01: Advertising
 *        - 0x02: Connection event slave
 *        - 0x03: Scanning
 *        - 0x04: Connection request
 *        - 0x05: Connection event master
 *        - 0x06: TX test mode
 *        - 0x07: RX test mode
 * @param Next_State Incoming radio events
 *        Values:
 *        - 0x00: Idle
 *        - 0x01: Advertising
 *        - 0x02: Connection event slave
 *        - 0x03: Scanning
 *        - 0x04: Connection request
 *        - 0x05: Connection event master
 *        - 0x06: TX test mode
 *        - 0x07: RX test mode
 * @param Next_State_SysTime 32bit absolute current time expressed in internal
 *        time units.
 * @retval None
 */
void aci_hal_end_of_radio_activity_event(uint8_t Last_State,
                                         uint8_t Next_State,
                                         uint32_t Next_State_SysTime)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_hal_end_of_radio_activity_event_rp0 *rp0 = (aci_hal_end_of_radio_activity_event_rp0 *) (buffer_out + 6);
  rp0->Last_State = Last_State;
  rp0->Next_State = Next_State;
  rp0->Next_State_SysTime = Next_State_SysTime;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 1 + 4 + 2);
  buffer_out[4] = 0x04;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 1 + 1 + 4 + 6, -1);
}

/* aci_hal_scan_req_report_event */
/* Event len: 1 + 1 + 6 */
/**
 * @brief This event is reported to the application after a scan request is
 *        received and a scan reponse is scheduled to be transmitted.
 * @param RSSI N Size: 1 Octet (signed integer) Units: dBm
 *        Values:
 *        - -127 ... 20
 *        - 127: RSSI not available
 * @param Peer_Address_Type 0x00 Public Device Address 0x01 Random Device
 *        Address 0x02 Public Identity Address (Corresponds to Resolved Private
 *        Address) 0x03 Random (Static) Identity Address (Corresponds to
 *        Resolved Private Address)
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Public Identity Address
 *        - 0x03: Random (Static) Identity Address
 * @param Peer_Address Public Device Address or Random Device Address of the
 *        peer device
 * @retval None
 */
void aci_hal_scan_req_report_event(int8_t RSSI,
                                   uint8_t Peer_Address_Type,
                                   uint8_t Peer_Address[6])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_hal_scan_req_report_event_rp0 *rp0 = (aci_hal_scan_req_report_event_rp0 *) (buffer_out + 6);
  rp0->RSSI = RSSI;
  rp0->Peer_Address_Type = Peer_Address_Type;
  Osal_MemCpy((void *) rp0->Peer_Address,(const void *) Peer_Address, 6);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 1 + 6 + 2);
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 1 + 1 + 6 + 6, -1);
}

/* aci_hal_fw_error_event */
/* Event len: 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated to report firmware error informations.
 * @param FW_Error_Type Errore code identifying the type of error that has
 *        occurred.
 *        Values:
 *        - 0x01: HAL_FW_L2CAP_RECOMBINATION_ERROR
 *        - 0x02: HAL_FW_GATT_UNEXPECTED_RESPONSE_ERROR
 *        - 0x03: HAL_FW_GATT_SEQUENTIAL_PROTOCOL_ERROR
 *        - 0x04: HAL_FW_BONDING_DB_FULL_PAIRING_ERROR
 *        - 0x05: HAL_FW_BONDING_DB_FULL_GATTSERVICE_ERROR
 * @param Data_Length Length of Data in octets
 * @param Data The error event info. If FW_Error_Type is 0x01, 0x02 or 0x03,
 *        this parameter contains the connection handle where the abnormal
 *        condition has occurred.
 * @retval None
 */
void aci_hal_fw_error_event(uint8_t FW_Error_Type,
                            uint8_t Data_Length,
                            uint8_t Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_hal_fw_error_event_rp0 *rp0 = (aci_hal_fw_error_event_rp0 *) (buffer_out + 6);
  rp0->FW_Error_Type = FW_Error_Type;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 1 + Data_Length + 2);
  buffer_out[4] = 0x06;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 1 + 1 + Data_Length + 6, -1);
}

/* aci_hal_le_test_end_event */
/* Event len: 2 */
/**
 * @brief This event is generated when the amount of transmitted test packets
 *        specified with aci_hal_transmitter_test_packets() has been reached.
 * @param Number_Of_Packets The number of test packets actually transmitted.
 * @retval None
 */
void aci_hal_le_test_end_event(uint16_t Number_Of_Packets)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_hal_le_test_end_event_rp0 *rp0 = (aci_hal_le_test_end_event_rp0 *) (buffer_out + 6);
  rp0->Number_Of_Packets = Number_Of_Packets;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x00;
  send_event(buffer_out, 2 + 6, -1);
}

/* aci_gap_limited_discoverable_event */
/* Event len: 0 */
/**
 * @brief This event is generated by the controller when the limited
 *        discoverable mode ends due to timeout. The timeout is 180 seconds.
 * @retval None
 */
void aci_gap_limited_discoverable_event(void)
{
  uint8_t buffer_out[532];
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,0 + 2);
  buffer_out[4] = 0x00;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 0 + 6, 9);
}

/* aci_gap_pairing_complete_event */
/* Event len: 2 + 1 + 1 */
/**
 * @brief This event is generated when the pairing process has completed
 *        successfully or a pairing procedure timeout has occurred or the
 *        pairing has failed. This is to notify the application that we have
 *        paired with a remote device so that it can take further actions or to
 *        notify that a timeout has occurred so that the upper layer can decide
 *        to disconnect the link.
 * @param Connection_Handle Connection handle on which the pairing procedure
 *        completed
 * @param Status Pairing status. If 0x02, see Reason code.
 *        Values:
 *        - 0x00: Success
 *        - 0x01: Timeout
 *        - 0x02: Pairing Failed
 *        - 0x03: Encryption failed, LTK missing on local device
 *        - 0x04: Encryption failed, LTK missing on peer device
 *        - 0x05: Encryption not supported by remote device
 * @param Reason Pairing reason error code
 *        Values:
 *        - 0x00
 *        - 0x01: PASSKEY_ENTRY_FAILED
 *        - 0x02: OOB_NOT_AVAILABLE
 *        - 0x03: AUTH_REQ_CANNOT_BE_MET
 *        - 0x04: CONFIRM_VALUE_FAILED
 *        - 0x05: PAIRING_NOT_SUPPORTED
 *        - 0x06: INSUFF_ENCRYPTION_KEY_SIZE
 *        - 0x07: CMD_NOT_SUPPORTED
 *        - 0x08: UNSPECIFIED_REASON
 *        - 0x09: VERY_EARLY_NEXT_ATTEMPT
 *        - 0x0A: SM_INVALID_PARAMS
 *        - 0x0B: SMP_SC_DHKEY_CHECK_FAILED
 *        - 0x0C: SMP_SC_NUMCOMPARISON_FAILED
 * @retval None
 */
void aci_gap_pairing_complete_event(uint16_t Connection_Handle,
                                    uint8_t Status,
                                    uint8_t Reason)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gap_pairing_complete_event_rp0 *rp0 = (aci_gap_pairing_complete_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Status = Status;
  rp0->Reason = Reason;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 1 + 2);
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 2 + 1 + 1 + 6, 10);
}

/* aci_gap_pass_key_req_event */
/* Event len: 2 */
/**
 * @brief This event is generated by the Security manager to the application
 *        when a passkey is required for pairing. When this event is received,
 *        the application has to respond with the @ref aci_gap_pass_key_resp
 *        command.
 * @param Connection_Handle Connection handle for which the passkey has been
 *        requested.
 * @retval None
 */
void aci_gap_pass_key_req_event(uint16_t Connection_Handle)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gap_pass_key_req_event_rp0 *rp0 = (aci_gap_pass_key_req_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 2 + 6, 11);
}

/* aci_gap_slave_security_initiated_event */
/* Event len: 0 */
/**
 * @brief This event is generated when the slave security request is
 *        successfully sent to the master.
 * @retval None
 */
void aci_gap_slave_security_initiated_event(void)
{
  uint8_t buffer_out[532];
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,0 + 2);
  buffer_out[4] = 0x04;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 0 + 6, 13);
}

/* aci_gap_bond_lost_event */
/* Event len: 0 */
/**
 * @brief This event is generated on the slave when a
 *        ACI_GAP_SLAVE_SECURITY_REQUEST is called to reestablish the bond with
 *        a master but the master has lost the bond. When this event is
 *        received, the upper layer has to issue the ACI_GAP_ALLOW_REBOND
 *        command in order to allow the slave to continue the pairing process
 *        with the master. On the master this event is raised when
 *        ACI_GAP_SEND_PAIRING_REQUEST is called to reestablish a bond with a
 *        slave but the slave has lost the bond. In order to create a new bond
 *        the master has to launch ACI_GAP_SEND_PAIRING_REQUEST with
 *        force_rebond set to 1.
 * @retval None
 */
void aci_gap_bond_lost_event(void)
{
  uint8_t buffer_out[532];
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,0 + 2);
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 0 + 6, 14);
}

/* aci_gap_proc_complete_event */
/* Event len: 1 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is sent by the GAP to the upper layers when a procedure
 *        previously started has been terminated by the upper layer or has
 *        completed for any other reason
 * @param Procedure_Code Code identifying the procedure.
 *        Values:
 *        - 0x00: GAP_LIMITED_DISCOVERY_PROC
 *        - 0x01: GAP_GENERAL_DISCOVERY_PROC
 *        - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x05: GAP_OBSERVATION_PROC
 *        - 0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC
 *        - 0x07: GAP_NAME_DISCOVERY_PROC
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Data_Length Length of Data in octets
 * @param Data Procedure Specific Data: - For Name Discovery Procedure: the name
 *        of the peer device if the procedure completed successfully.
 * @retval None
 */
void aci_gap_proc_complete_event(uint8_t Procedure_Code,
                                 uint8_t Status,
                                 uint8_t Data_Length,
                                 uint8_t Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gap_proc_complete_event_rp0 *rp0 = (aci_gap_proc_complete_event_rp0 *) (buffer_out + 6);
  rp0->Procedure_Code = Procedure_Code;
  rp0->Status = Status;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,1 + 1 + 1 + Data_Length + 2);
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 1 + 1 + 1 + Data_Length + 6, 15);
}

/* aci_gap_addr_not_resolved_event */
/* Event len: 2 */
/**
 * @brief This event is sent only by a privacy enabled Peripheral. The event is
 *        sent to the upper layers when the peripheral is unsuccessful in
 *        resolving the resolvable address of the peer device after connecting
 *        to it.
 * @param Connection_Handle Connection handle for which the private address
 *        could not be resolved with any of the stored IRK's.
 * @retval None
 */
void aci_gap_addr_not_resolved_event(uint16_t Connection_Handle)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gap_addr_not_resolved_event_rp0 *rp0 = (aci_gap_addr_not_resolved_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x08;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 2 + 6, 16);
}

/* aci_gap_numeric_comparison_value_event */
/* Event len: 2 + 4 */
/**
 * @brief This event is sent only during SC v.4.2 Pairing, when Numeric
 *        Comparison Association model is selected, in order to show the Numeric
 *        Value generated, and to ask for Confirmation to the User. When this
 *        event is received, the application has to respond with the  @ref
 *        aci_gap_numeric_comparison_value_confirm_yesno command
 * @param Connection_Handle Connection handle related to the underlying Pairing
 * @param Numeric_Value
 * @retval None
 */
void aci_gap_numeric_comparison_value_event(uint16_t Connection_Handle,
                                            uint32_t Numeric_Value)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gap_numeric_comparison_value_event_rp0 *rp0 = (aci_gap_numeric_comparison_value_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Numeric_Value = Numeric_Value;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 4 + 2);
  buffer_out[4] = 0x09;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 2 + 4 + 6, 54);
}

/* aci_gap_keypress_notification_event */
/* Event len: 2 + 1 */
/**
 * @brief This event is sent only during SC v.4.2 Pairing, when Keypress
 *        Notifications are supported, in order to show the input type signalled
 *        by the peer device, having Keyboard only I/O capabilities. When this
 *        event is received, no action is required to the User.
 * @param Connection_Handle Connection handle related to the underlying Pairing
 * @param Notification_Type Type of Keypress input notified/signaled by peer
 *        device
 *        Values:
 *        - 0x00: PASSKEY_ENTRY_STARTED
 *        - 0x01: PASSKEY_DIGIT_ENTERED
 *        - 0x02: PASSKEY_DIGIT_ERASED
 *        - 0x03: PASSKEY_CLEARED
 *        - 0x04: PASSKEY_ENTRY_COMPLETED
 * @retval None
 */
void aci_gap_keypress_notification_event(uint16_t Connection_Handle,
                                         uint8_t Notification_Type)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gap_keypress_notification_event_rp0 *rp0 = (aci_gap_keypress_notification_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Notification_Type = Notification_Type;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2);
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0x04;
  send_event(buffer_out, 2 + 1 + 6, 55);
}

/* aci_l2cap_connection_update_resp_event */
/* Event len: 2 + 2 */
/**
 * @brief This event is generated when the master responds to the connection
 *        update request packet with a connection update response packet.
 * @param Connection_Handle Connection handle referring to the COS Channel where
 *        the Disconnection has been received.
 * @param Result
 * @retval None
 */
void aci_l2cap_connection_update_resp_event(uint16_t Connection_Handle,
                                            uint16_t Result)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_l2cap_connection_update_resp_event_rp0 *rp0 = (aci_l2cap_connection_update_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Result = Result;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2);
  buffer_out[4] = 0x00;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 2 + 6, 17);
}

/* aci_l2cap_proc_timeout_event */
/* Event len: 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated when the master does not respond to the
 *        connection update request packet with a connection update response
 *        packet or a command reject packet within 30 seconds.
 * @param Connection_Handle Handle of the connection related to this L2CAP
 *        procedure.
 * @param Data_Length Length of following data
 * @param Data
 * @retval None
 */
void aci_l2cap_proc_timeout_event(uint16_t Connection_Handle,
                                  uint8_t Data_Length,
                                  uint8_t Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_l2cap_proc_timeout_event_rp0 *rp0 = (aci_l2cap_proc_timeout_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + Data_Length + 2);
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 1 + Data_Length + 6, 18);
}

/* aci_l2cap_connection_update_req_event */
/* Event len: 2 + 1 + 2 + 2 + 2 + 2 + 2 */
/**
 * @brief The event is given by the L2CAP layer when a connection update request
 *        is received from the slave. The upper layer which receives this event
 *        has to respond by sending a @ref
 *        aci_l2cap_connection_parameter_update_resp command.
 * @param Connection_Handle Handle of the connection related to this L2CAP
 *        procedure.
 * @param Identifier This is the identifier which associates the request to the
 *        response.
 * @param L2CAP_Length Length of the L2CAP connection update request.
 * @param Interval_Min Minimum value for the connection event interval. This
 *        shall be less than or equal to Conn_Interval_Max. Time = N * 1.25
 *        msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Interval_Max Maximum value for the connection event interval. This
 *        shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25
 *        msec.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Slave_Latency Slave latency for the connection in number of connection
 *        events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Timeout_Multiplier Defines connection timeout parameter in the
 *        following manner: Timeout Multiplier * 10ms.
 *        Values:
 *        - 10 (100 ms)  ... 3200 (32000 ms) 
 * @retval None
 */
void aci_l2cap_connection_update_req_event(uint16_t Connection_Handle,
                                           uint8_t Identifier,
                                           uint16_t L2CAP_Length,
                                           uint16_t Interval_Min,
                                           uint16_t Interval_Max,
                                           uint16_t Slave_Latency,
                                           uint16_t Timeout_Multiplier)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_l2cap_connection_update_req_event_rp0 *rp0 = (aci_l2cap_connection_update_req_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Identifier = Identifier;
  rp0->L2CAP_Length = L2CAP_Length;
  rp0->Interval_Min = Interval_Min;
  rp0->Interval_Max = Interval_Max;
  rp0->Slave_Latency = Slave_Latency;
  rp0->Timeout_Multiplier = Timeout_Multiplier;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + 2 + 2 + 2 + 2 + 2);
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 1 + 2 + 2 + 2 + 2 + 2 + 6, 19);
}

int aci_l2cap_cfc_connection_event_preprocess(uint16_t Connection_Handle,
                                              uint8_t Event_Type,
                                              uint16_t Result,
                                              uint8_t Identifier,
                                              uint16_t SPSM,
                                              uint16_t CID,
                                              uint16_t Remote_CID,
                                              uint16_t Peer_MTU,
                                              uint16_t Peer_MPS,
                                              uint16_t Initial_Credits);
/* aci_l2cap_cfc_connection_event */
/* Event len: 2 + 1 + 2 + 1 + 2 + 2 + 2 + 2 + 2 + 2 */
/**
 * @brief Event generated when a request or a response is received from the peer
 *        to create an L2CAP channel.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Event_Type
 *        Values:
 *        - 0x00: L2CAP_CONN_REQ
 *        - 0x01: L2CAP_CONN_RESP
 * @param Result Result of the connection request if Event_Type is
 *        L2CAP_CONN_RESP. To be ignored if Event_Type is L2CAP_CONN_REQ.
 *        Values:
 *        - 0x0000: L2CAP_CONN_SUCCESSFUL
 *        - 0x0002: L2CAP_SPSM_NOT_SUPPORTED
 *        - 0x0004: L2CAP_NO_RESOURCE_AVAILABLE
 *        - 0x0005: L2CAP_INSUFFICIENT_AUTHENTICATION
 *        - 0x0006: L2CAP_INSUFFICIENT_AUTHORIZATION
 *        - 0x0007: L2CAP_INSUFFICIENT_ENCRYPTION_KEY_SIZE
 *        - 0x0008: L2CAP_INSUFFICIENT_ENCRYPTION
 *        - 0x0009: L2CAP_INVALID_SOURCE_CID
 *        - 0x000A: L2CAP_SOURCE_CID_ALREADY_ALLOCATED
 *        - 0x000B: L2CAP_UNACCEPTABLE_PARAMETERS
 * @param Identifier This is the identifier which associates the request to the
 *        response.
 * @param SPSM Simplified Protocol/Service Multiplexer
 *        Values:
 *        - 0x0001 ... 0x00FF
 * @param CID The local channel endpoint that identifies the L2CAP channel. To
 *        be ignored if Event_Type is L2CAP_CONN_REQ.
 * @param Remote_CID The channel endpoint on the remote device.
 * @param Peer_MTU The maximum SDU size (in octets) that the L2CAP layer entity
 *        sending the L2CAP_LE_CREDIT_BASED_CONNECTION_REQ can receive on this
 *        channel.
 *        Values:
 *        - 23 ... 65535
 * @param Peer_MPS The maximum PDU payload size (in octets) that the L2CAP layer
 *        entity sending the L2CAP_LE_CREDIT_BASED_CONNECTION_REQ is capable of
 *        receiving on this channel.
 *        Values:
 *        - 23 ... 65535
 * @param Initial_Credits The number of K-frames that the peer device can send
 *        to the L2CAP layer entity as soon as the L2CAP channel is established.
 * @retval None
 */
void aci_l2cap_cfc_connection_event(uint16_t Connection_Handle,
                                    uint8_t Event_Type,
                                    uint16_t Result,
                                    uint8_t Identifier,
                                    uint16_t SPSM,
                                    uint16_t CID,
                                    uint16_t Remote_CID,
                                    uint16_t Peer_MTU,
                                    uint16_t Peer_MPS,
                                    uint16_t Initial_Credits)
{
  uint8_t buffer_out[532];

  if(aci_l2cap_cfc_connection_event_preprocess(Connection_Handle, Event_Type, Result, Identifier, SPSM, CID, Remote_CID, Peer_MTU, Peer_MPS, Initial_Credits)) return;

  /* Output params */
  aci_l2cap_cfc_connection_event_rp0 *rp0 = (aci_l2cap_cfc_connection_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Event_Type = Event_Type;
  rp0->Result = Result;
  rp0->Identifier = Identifier;
  rp0->SPSM = SPSM;
  rp0->CID = CID;
  rp0->Remote_CID = Remote_CID;
  rp0->Peer_MTU = Peer_MTU;
  rp0->Peer_MPS = Peer_MPS;
  rp0->Initial_Credits = Initial_Credits;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 2);
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 1 + 2 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 6, -1);
}

int aci_l2cap_disconnection_complete_event_preprocess(uint16_t Connection_Handle,
                                                      uint16_t CID);
/* aci_l2cap_disconnection_complete_event */
/* Event len: 2 + 2 */
/**
 * @brief Event raised when an L2CAP channel using LE Credit Based Flow Control
 *        mode is terminated.
 * @param Connection_Handle Handle identifying the connection.
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @retval None
 */
void aci_l2cap_disconnection_complete_event(uint16_t Connection_Handle,
                                            uint16_t CID)
{
  uint8_t buffer_out[532];

  if(aci_l2cap_disconnection_complete_event_preprocess(Connection_Handle, CID)) return;

  /* Output params */
  aci_l2cap_disconnection_complete_event_rp0 *rp0 = (aci_l2cap_disconnection_complete_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->CID = CID;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2);
  buffer_out[4] = 0x04;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 2 + 6, -1);
}

/* aci_l2cap_flow_control_credit_event */
/* Event len: 2 + 2 + 2 + 2 */
/**
 * @brief Event raised when an L2CAP_FLOW_CONTROL_CREDIT_IND is received from
 *        the peer, which means that it is capable of receiving additional
 *        K-frames (for example after it has processed one or more K-frames) in
 *        LE Credit Based Flow Control.
 * @param Connection_Handle Handle identifying the connection.
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @param TX_Credits The number of additional k-frames that the peer's L2CAP
 *        layer entity can receive.
 * @param TX_Credit_Balance Remaining number of K-frames that local L2CAP layer
 *        entity can currently send to the peer.
 *        Values:
 *        - 1 ... 65535
 * @retval None
 */
void aci_l2cap_flow_control_credit_event(uint16_t Connection_Handle,
                                         uint16_t CID,
                                         uint16_t TX_Credits,
                                         uint16_t TX_Credit_Balance)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_l2cap_flow_control_credit_event_rp0 *rp0 = (aci_l2cap_flow_control_credit_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->CID = CID;
  rp0->TX_Credits = TX_Credits;
  rp0->TX_Credit_Balance = TX_Credit_Balance;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 2 + 2);
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 2 + 2 + 2 + 6, -1);
}

/* aci_l2cap_sdu_data_tx_nwk_event */
/* Event len: 2 + 2 + 2 + 2 */
/**
 * @brief Event raised when an SDU to be transmitted has been processed by the
 *        local L2CAP layer entity.
 * @param Connection_Handle Handle identifying the connection.
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @param SDU_Length
 * @param TX_Credit_Balance Remaining number of K-frames that local L2CAP layer
 *        entity can currently send to the peer.
 * @retval None
 */
void aci_l2cap_sdu_data_tx_nwk_event(uint16_t Connection_Handle,
                                     uint16_t CID,
                                     uint16_t SDU_Length,
                                     uint16_t TX_Credit_Balance)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_l2cap_sdu_data_tx_nwk_event_rp0 *rp0 = (aci_l2cap_sdu_data_tx_nwk_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->CID = CID;
  rp0->SDU_Length = SDU_Length;
  rp0->TX_Credit_Balance = TX_Credit_Balance;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 2 + 2);
  buffer_out[4] = 0x06;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 2 + 2 + 2 + 6, -1);
}

/* aci_l2cap_sdu_data_rx_nwk_event */
/* Event len: 2 + 2 + 2 + 2 + rp0->SDU_Length * (sizeof(uint8_t)) */
/**
 * @brief Event raised when an SDU has been received.
 * @param Connection_Handle Handle identifying the connection.
 * @param CID The local channel endpoint that identifies the L2CAP channel.
 * @param RX_Credit_Balance Remaining number of K-frames that local L2CAP layer
 *        entity can currently receive from the peer. If automatic management of
 *        credits is enabled, this number is automatically changed after the SDU
 *        is extracted.
 * @param SDU_Length
 * @param SDU_Data
 * @retval None
 */
void aci_l2cap_sdu_data_rx_nwk_event(uint16_t Connection_Handle,
                                     uint16_t CID,
                                     uint16_t RX_Credit_Balance,
                                     uint16_t SDU_Length,
                                     uint8_t SDU_Data[])
{
  uint8_t buffer_out[6+ sizeof(aci_l2cap_sdu_data_rx_nwk_event_rp0)-sizeof(((aci_l2cap_sdu_data_rx_nwk_event_rp0*)0)->SDU_Data)];
  /* Output params */
  aci_l2cap_sdu_data_rx_nwk_event_rp0 *rp0 = (aci_l2cap_sdu_data_rx_nwk_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->CID = CID;
  rp0->RX_Credit_Balance = RX_Credit_Balance;
  rp0->SDU_Length = SDU_Length;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 2 + SDU_Length + 2);
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x08;
  send_event_2buffers(buffer_out, 6 + sizeof(aci_l2cap_sdu_data_rx_nwk_event_rp0)-sizeof(((aci_l2cap_sdu_data_rx_nwk_event_rp0*)0)->SDU_Data), SDU_Data, SDU_Length, -1);
}

/* aci_l2cap_command_reject_event */
/* Event len: 2 + 1 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated when the master rejects a L2CAP request.
 * @param Connection_Handle Handle identifying the connection.
 * @param Identifier This is the identifier which associates the request to the
 *        response.
 * @param Reason Reason
 * @param Data_Length Length of following data
 * @param Data Data field associated with Reason
 * @retval None
 */
void aci_l2cap_command_reject_event(uint16_t Connection_Handle,
                                    uint8_t Identifier,
                                    uint16_t Reason,
                                    uint8_t Data_Length,
                                    uint8_t Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_l2cap_command_reject_event_rp0 *rp0 = (aci_l2cap_command_reject_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Identifier = Identifier;
  rp0->Reason = Reason;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + 1 + Data_Length + 2);
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0x08;
  send_event(buffer_out, 2 + 1 + 2 + 1 + Data_Length + 6, -2);
}

int aci_gatt_srv_attribute_modified_event_preprocess(uint16_t Connection_Handle,
                                                     uint16_t Attr_Handle,
                                                     uint16_t Attr_Data_Length,
                                                     uint8_t Attr_Data[]);
/* aci_gatt_srv_attribute_modified_event */
/* Event len: 2 + 2 + 2 + rp0->Attr_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated to the application by the GATT server when a
 *        client modifies any attribute on the server, as consequence of one of
 *        the following GATT procedures: - write without response - signed write
 *        without response - write characteristic value - write long
 *        characteristic value - reliable write.
 * @param Connection_Handle The connection handle which modified the attribute.
 * @param Attr_Handle Handle of the attribute that was modified.
 * @param Attr_Data_Length Length of Attr_Data in octets
 * @param Attr_Data The modified value
 * @retval None
 */
void aci_gatt_srv_attribute_modified_event(uint16_t Connection_Handle,
                                           uint16_t Attr_Handle,
                                           uint16_t Attr_Data_Length,
                                           uint8_t Attr_Data[])
{
  uint8_t buffer_out[532];

  if(aci_gatt_srv_attribute_modified_event_preprocess(Connection_Handle, Attr_Handle, Attr_Data_Length, Attr_Data)) return;

  /* Output params */
  aci_gatt_srv_attribute_modified_event_rp0 *rp0 = (aci_gatt_srv_attribute_modified_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Attr_Handle = Attr_Handle;
  rp0->Attr_Data_Length = Attr_Data_Length;
  Osal_MemCpy((void *) rp0->Attr_Data,(const void *) Attr_Data, Attr_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + Attr_Data_Length + 2);
  buffer_out[4] = 0x01;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 2 + Attr_Data_Length + 6, 20);
}

/* aci_gatt_proc_timeout_event */
/* Event len: 2 */
/**
 * @brief This event is generated by the client/server to the application on a
 *        GATT timeout (30 seconds). This is a critical event that should not
 *        happen during normal operating conditions. It is an indication of
 *        either a major disruption in the communication link or a mistake in
 *        the application which does not provide a reply to GATT procedures.
 *        After this event, the GATT channel is closed and no more GATT
 *        communication can be performed. The applications is exptected to issue
 *        an @ref aci_gap_terminate to disconnect from the peer device. It is
 *        important to leave an 100 ms blank window before sending the @ref
 *        aci_gap_terminate, since immediately after this event, system could
 *        save important information in non volatile memory.
 * @param Connection_Handle Connection handle on which the GATT procedure has
 *        timed out
 * @retval None
 */
void aci_gatt_proc_timeout_event(uint16_t Connection_Handle)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_proc_timeout_event_rp0 *rp0 = (aci_gatt_proc_timeout_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x02;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 6, 21);
}

/* aci_att_exchange_mtu_resp_event */
/* Event len: 2 + 2 */
/**
 * @brief This event is generated in response to an Exchange MTU request (local
 *        or from the peer). See aci_gatt_clt_exchange_config().
 * @param Connection_Handle Connection handle related to the response
 * @param Server_RX_MTU ATT_MTU value agreed between server and client
 * @retval None
 */
void aci_att_exchange_mtu_resp_event(uint16_t Connection_Handle,
                                     uint16_t Server_RX_MTU)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_exchange_mtu_resp_event_rp0 *rp0 = (aci_att_exchange_mtu_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Server_RX_MTU = Server_RX_MTU;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2);
  buffer_out[4] = 0x03;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 6, 22);
}

/* aci_att_clt_find_info_resp_event */
/* Event len: 2 + 1 + 2 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated in response to a Find Information Request
 *        during a discovery procedure for all the characteristic descriptors.
 *        See aci_gatt_clt_disc_all_char_desc() and Find Information Response in
 *        Bluetooth Core spec.
 * @param Connection_Handle Connection handle related to the response
 * @param Format Format of the hanndle-uuid pairs
 * @param Event_Data_Length Length of Handle_UUID_Pair in octets
 * @param Handle_UUID_Pair A sequence of handle-uuid pairs. if format=1, each
 *        pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each
 *        pair is:[2 octets for handle, 16 octets for UUIDs]
 * @retval None
 */
void aci_att_clt_find_info_resp_event(uint16_t Connection_Handle,
                                      uint8_t Format,
                                      uint16_t Event_Data_Length,
                                      uint8_t Handle_UUID_Pair[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_find_info_resp_event_rp0 *rp0 = (aci_att_clt_find_info_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Format = Format;
  rp0->Event_Data_Length = Event_Data_Length;
  Osal_MemCpy((void *) rp0->Handle_UUID_Pair,(const void *) Handle_UUID_Pair, Event_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + Event_Data_Length + 2);
  buffer_out[4] = 0x04;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + 2 + Event_Data_Length + 6, 23);
}

/* aci_att_clt_find_by_type_value_resp_event */
/* Event len: 2 + 1 + rp0->Num_of_Handle_Pair * (sizeof(packed_Attribute_Group_Handle_Pair_t)) */
/**
 * @brief This event is generated during a "discover service by UUID" procedure.
 *        See aci_gatt_clt_disc_primary_service_by_uuid().
 * @param Connection_Handle Connection handle related to the response
 * @param Num_of_Handle_Pair Number of attribute, group handle pairs
 * @param Attribute_Group_Handle_Pair See @ref Attribute_Group_Handle_Pair_t
 * @retval None
 */
void aci_att_clt_find_by_type_value_resp_event(uint16_t Connection_Handle,
                                               uint8_t Num_of_Handle_Pair,
                                               Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[])
{
  uint8_t buffer_out[532];
  int output_size = 0;
  /* Output params */
  aci_att_clt_find_by_type_value_resp_event_rp0 *rp0 = (aci_att_clt_find_by_type_value_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Num_of_Handle_Pair = Num_of_Handle_Pair;
  {
    int i;
    for (i = 0; i < Num_of_Handle_Pair; i++) {
      rp0->Attribute_Group_Handle_Pair[i].Found_Attribute_Handle = Attribute_Group_Handle_Pair[i].Found_Attribute_Handle;
      output_size += sizeof(uint16_t);
      rp0->Attribute_Group_Handle_Pair[i].Group_End_Handle = Attribute_Group_Handle_Pair[i].Group_End_Handle;
      output_size += sizeof(uint16_t);
    }
  }
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + output_size + 2);
  buffer_out[4] = 0x05;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + output_size + 6, 24);
}

/* aci_att_clt_read_by_type_resp_event */
/* Event len: 2 + 1 + 2 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated in response to a ATT_READ_BY_TYPE_REQ, during
 *        a "find included service" procedure or a "discover all
 *        characteristics" procedure. See aci_gatt_clt_find_included_services()
 *        and aci_gatt_clt_disc_all_char_of_service().
 * @param Connection_Handle Connection handle related to the response
 * @param Handle_Value_Pair_Length The size of each attribute handle-value pair
 * @param Data_Length Length of Handle_Value_Pair_Data in octets
 * @param Handle_Value_Pair_Data Attribute Data List as defined in Bluetooth
 *        Core v4.1 spec. A sequence of handle-value pairs: [2 octets for
 *        Attribute Handle, (Handle_Value_Pair_Length - 2 octets) for Attribute
 *        Value]
 * @retval None
 */
void aci_att_clt_read_by_type_resp_event(uint16_t Connection_Handle,
                                         uint8_t Handle_Value_Pair_Length,
                                         uint16_t Data_Length,
                                         uint8_t Handle_Value_Pair_Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_read_by_type_resp_event_rp0 *rp0 = (aci_att_clt_read_by_type_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Handle_Value_Pair_Length = Handle_Value_Pair_Length;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Handle_Value_Pair_Data,(const void *) Handle_Value_Pair_Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + Data_Length + 2);
  buffer_out[4] = 0x06;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + 2 + Data_Length + 6, 25);
}

/* aci_att_clt_read_resp_event */
/* Event len: 2 + 2 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated in response to a Read Request. See
 *        aci_gatt_clt_read().
 * @param Connection_Handle Connection handle related to the response
 * @param Event_Data_Length Length of following data
 * @param Attribute_Value The value of the attribute.
 * @retval None
 */
void aci_att_clt_read_resp_event(uint16_t Connection_Handle,
                                 uint16_t Event_Data_Length,
                                 uint8_t Attribute_Value[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_read_resp_event_rp0 *rp0 = (aci_att_clt_read_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Event_Data_Length = Event_Data_Length;
  Osal_MemCpy((void *) rp0->Attribute_Value,(const void *) Attribute_Value, Event_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + Event_Data_Length + 2);
  buffer_out[4] = 0x07;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + Event_Data_Length + 6, 26);
}

/* aci_att_clt_read_blob_resp_event */
/* Event len: 2 + 2 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event can be generated during a read long characteristic value
 *        procedure. See aci_gatt_clt_read_long().
 * @param Connection_Handle Connection handle related to the response
 * @param Event_Data_Length Length of following data
 * @param Attribute_Value Part of the attribute value.
 * @retval None
 */
void aci_att_clt_read_blob_resp_event(uint16_t Connection_Handle,
                                      uint16_t Event_Data_Length,
                                      uint8_t Attribute_Value[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_read_blob_resp_event_rp0 *rp0 = (aci_att_clt_read_blob_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Event_Data_Length = Event_Data_Length;
  Osal_MemCpy((void *) rp0->Attribute_Value,(const void *) Attribute_Value, Event_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + Event_Data_Length + 2);
  buffer_out[4] = 0x08;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + Event_Data_Length + 6, 27);
}

/* aci_att_clt_read_multiple_resp_event */
/* Event len: 2 + 2 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated in response to a Read Multiple Request. See
 *        aci_gatt_clt_read_multiple_char_value().
 * @param Connection_Handle Connection handle related to the response
 * @param Event_Data_Length Length of following data
 * @param Set_Of_Values A set of two or more values. A concatenation of
 *        attribute values for each of the attribute handles in the request in
 *        the order that they were requested.
 * @retval None
 */
void aci_att_clt_read_multiple_resp_event(uint16_t Connection_Handle,
                                          uint16_t Event_Data_Length,
                                          uint8_t Set_Of_Values[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_read_multiple_resp_event_rp0 *rp0 = (aci_att_clt_read_multiple_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Event_Data_Length = Event_Data_Length;
  Osal_MemCpy((void *) rp0->Set_Of_Values,(const void *) Set_Of_Values, Event_Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + Event_Data_Length + 2);
  buffer_out[4] = 0x09;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + Event_Data_Length + 6, 28);
}

/* aci_att_clt_read_by_group_type_resp_event */
/* Event len: 2 + 1 + 2 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated in response to a Read By Group Type Request,
 *        during a "discover all primary services" procedure. See
 *        aci_gatt_clt_disc_all_primary_services().
 * @param Connection_Handle Connection handle related to the response
 * @param Attribute_Data_Length The size of each attribute data
 * @param Data_Length Length of Attribute_Data_List in octets
 * @param Attribute_Data_List Attribute Data List as defined in Bluetooth Core
 *        v4.1 spec. A sequence of attribute handle, end group handle, attribute
 *        value tuples: [2 octets for Attribute Handle, 2 octets End Group
 *        Handle, (Attribute_Data_Length - 4 octets) for Attribute Value]
 * @retval None
 */
void aci_att_clt_read_by_group_type_resp_event(uint16_t Connection_Handle,
                                               uint8_t Attribute_Data_Length,
                                               uint16_t Data_Length,
                                               uint8_t Attribute_Data_List[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_read_by_group_type_resp_event_rp0 *rp0 = (aci_att_clt_read_by_group_type_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Attribute_Data_Length = Attribute_Data_Length;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Attribute_Data_List,(const void *) Attribute_Data_List, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + Data_Length + 2);
  buffer_out[4] = 0x0a;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + 2 + Data_Length + 6, 29);
}

/* aci_att_clt_prepare_write_resp_event */
/* Event len: 2 + 2 + 2 + 2 + rp0->Part_Attribute_Value_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated in response to an ATT_PREPARE_WRITE_REQ during
 *        a write long characteristic value procedure. See
 *        aci_gatt_clt_write_long().
 * @param Connection_Handle Connection handle related to the response
 * @param Attribute_Handle The handle of the attribute to be written
 * @param Offset The offset of the first octet to be written.
 * @param Part_Attribute_Value_Length Length of Part_Attribute_Value in octets
 * @param Part_Attribute_Value The value of the attribute to be written
 * @retval None
 */
void aci_att_clt_prepare_write_resp_event(uint16_t Connection_Handle,
                                          uint16_t Attribute_Handle,
                                          uint16_t Offset,
                                          uint16_t Part_Attribute_Value_Length,
                                          uint8_t Part_Attribute_Value[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_prepare_write_resp_event_rp0 *rp0 = (aci_att_clt_prepare_write_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Attribute_Handle = Attribute_Handle;
  rp0->Offset = Offset;
  rp0->Part_Attribute_Value_Length = Part_Attribute_Value_Length;
  Osal_MemCpy((void *) rp0->Part_Attribute_Value,(const void *) Part_Attribute_Value, Part_Attribute_Value_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + 2 + Part_Attribute_Value_Length + 2);
  buffer_out[4] = 0x0c;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 2 + 2 + Part_Attribute_Value_Length + 6, 31);
}

/* aci_att_clt_exec_write_resp_event */
/* Event len: 2 */
/**
 * @brief This event is generated in response to an ATT Execute Write Request,
 *        during a write long characteristic value procedure. See
 *        aci_gatt_clt_write_long().
 * @param Connection_Handle Connection handle related to the response
 * @retval None
 */
void aci_att_clt_exec_write_resp_event(uint16_t Connection_Handle)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_clt_exec_write_resp_event_rp0 *rp0 = (aci_att_clt_exec_write_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x0d;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 6, 32);
}

/* aci_gatt_clt_indication_event */
/* Event len: 2 + 2 + 2 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated when an indication is received from the
 *        server.
 * @param Connection_Handle Connection handle related to the response
 * @param Attribute_Handle The handle of the attribute
 * @param Attribute_Value_Length Length of Attribute_Value in octets
 * @param Attribute_Value The current value of the attribute
 * @retval None
 */
void aci_gatt_clt_indication_event(uint16_t Connection_Handle,
                                   uint16_t Attribute_Handle,
                                   uint16_t Attribute_Value_Length,
                                   uint8_t Attribute_Value[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_clt_indication_event_rp0 *rp0 = (aci_gatt_clt_indication_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Attribute_Handle = Attribute_Handle;
  rp0->Attribute_Value_Length = Attribute_Value_Length;
  Osal_MemCpy((void *) rp0->Attribute_Value,(const void *) Attribute_Value, Attribute_Value_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + Attribute_Value_Length + 2);
  buffer_out[4] = 0x0e;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 2 + Attribute_Value_Length + 6, 33);
}

int aci_gatt_clt_notification_event_preprocess(uint16_t Connection_Handle,
                                               uint16_t Attribute_Handle,
                                               uint16_t Attribute_Value_Length,
                                               uint8_t Attribute_Value[]);
/* aci_gatt_clt_notification_event */
/* Event len: 2 + 2 + 2 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated when a notification is received from the
 *        server.
 * @param Connection_Handle Connection handle related to the response
 * @param Attribute_Handle The handle of the attribute
 * @param Attribute_Value_Length Length of Attribute_Value in octets
 * @param Attribute_Value The current value of the attribute
 * @retval None
 */
void aci_gatt_clt_notification_event(uint16_t Connection_Handle,
                                     uint16_t Attribute_Handle,
                                     uint16_t Attribute_Value_Length,
                                     uint8_t Attribute_Value[])
{
  uint8_t buffer_out[532];

  if(aci_gatt_clt_notification_event_preprocess(Connection_Handle, Attribute_Handle, Attribute_Value_Length, Attribute_Value)) return;

  /* Output params */
  aci_gatt_clt_notification_event_rp0 *rp0 = (aci_gatt_clt_notification_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Attribute_Handle = Attribute_Handle;
  rp0->Attribute_Value_Length = Attribute_Value_Length;
  Osal_MemCpy((void *) rp0->Attribute_Value,(const void *) Attribute_Value, Attribute_Value_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2 + Attribute_Value_Length + 2);
  buffer_out[4] = 0x0f;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 2 + Attribute_Value_Length + 6, 34);
}

int aci_gatt_clt_proc_complete_event_preprocess(uint16_t Connection_Handle,
                                                uint8_t Error_Code);
/* aci_gatt_clt_proc_complete_event */
/* Event len: 2 + 1 */
/**
 * @brief This event is generated when a GATT client procedure completes either
 *        with error or successfully.
 * @param Connection_Handle Connection handle related to the response
 * @param Error_Code For standard error codes see Bluetooth specification, Vol.
 *        2, part D. For proprietary error code refer to Error codes section.
 * @retval None
 */
void aci_gatt_clt_proc_complete_event(uint16_t Connection_Handle,
                                      uint8_t Error_Code)
{
  uint8_t buffer_out[532];

  if(aci_gatt_clt_proc_complete_event_preprocess(Connection_Handle, Error_Code)) return;

  /* Output params */
  aci_gatt_clt_proc_complete_event_rp0 *rp0 = (aci_gatt_clt_proc_complete_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Error_Code = Error_Code;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2);
  buffer_out[4] = 0x10;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + 6, 35);
}

/* aci_gatt_clt_error_resp_event */
/* Event len: 2 + 1 + 2 + 1 */
/**
 * @brief This event is generated when an Error Response is received from the
 *        server. The error response can be given by the server at the end of
 *        one of the GATT discovery procedures. This does not mean that the
 *        procedure ended with an error, but this error event is part of the
 *        procedure itself.
 * @param Connection_Handle Connection handle related to the response
 * @param Req_Opcode The request that generated this error response
 * @param Attribute_Handle The attribute handle that generated this error
 *        response
 * @param Error_Code The reason why the request has generated an error response
 *        (ATT error codes)
 *        Values:
 *        - 0x01: Invalid handle
 *        - 0x02: Read not permitted
 *        - 0x03: Write not permitted
 *        - 0x04: Invalid PDU
 *        - 0x05: Insufficient authentication
 *        - 0x06: Request not supported
 *        - 0x07: Invalid offset
 *        - 0x08: Insufficient authorization
 *        - 0x09: Prepare queue full
 *        - 0x0A: Attribute not found
 *        - 0x0B: Attribute not long
 *        - 0x0C: Insufficient encryption key size
 *        - 0x0D: Invalid attribute value length
 *        - 0x0E: Unlikely error
 *        - 0x0F: Insufficient encryption
 *        - 0x10: Unsupported group type
 *        - 0x11: Insufficient resources
 * @retval None
 */
void aci_gatt_clt_error_resp_event(uint16_t Connection_Handle,
                                   uint8_t Req_Opcode,
                                   uint16_t Attribute_Handle,
                                   uint8_t Error_Code)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_clt_error_resp_event_rp0 *rp0 = (aci_gatt_clt_error_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Req_Opcode = Req_Opcode;
  rp0->Attribute_Handle = Attribute_Handle;
  rp0->Error_Code = Error_Code;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2 + 1 + 2);
  buffer_out[4] = 0x11;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + 2 + 1 + 6, 36);
}

/* aci_gatt_clt_disc_read_char_by_uuid_resp_event */
/* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
/**
 * @brief This event can be generated during a "Discover Characteristics By
 *        UUID" procedure or a "Read using Characteristic UUID" procedure.
 *        During a "Discover Characteristics By UUID" procedure, Attribute_Value
 *        is a characteristic declaration as defined in Bluetooth Core spec
 *        (vol.3, Part G, ch. 3.3.1), i.e. it is composed by: Characteristic
 *        Properties (1 octet), Characteristic Value Handle (2 octets) and
 *        Characteristic UUID (2 or 16 octets). During a "Read using
 *        Characteristic UUID" procedure, Attribute_Value is the value of the
 *        characteristic.
 * @param Connection_Handle Connection handle related to the response
 * @param Attribute_Handle The handle of the attribute
 * @param Attribute_Value_Length Length of Attribute_Value in octets
 * @param Attribute_Value The attribute value will be a characteristic
 *        declaration as defined in Bluetooth Core spec (vol.3, Part G, ch.
 *        3.3.1), when a "Discover Characteristics By UUID" has been started. It
 *        will be the value of the Characteristic if a "Read using
 *        Characteristic UUID" has been performed.
 * @retval None
 */
void aci_gatt_clt_disc_read_char_by_uuid_resp_event(uint16_t Connection_Handle,
                                                    uint16_t Attribute_Handle,
                                                    uint8_t Attribute_Value_Length,
                                                    uint8_t Attribute_Value[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0 *rp0 = (aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Attribute_Handle = Attribute_Handle;
  rp0->Attribute_Value_Length = Attribute_Value_Length;
  Osal_MemCpy((void *) rp0->Attribute_Value,(const void *) Attribute_Value, Attribute_Value_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 1 + Attribute_Value_Length + 2);
  buffer_out[4] = 0x12;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 1 + Attribute_Value_Length + 6, 37);
}

int aci_gatt_tx_pool_available_event_preprocess(uint16_t Connection_Handle,
                                                uint16_t Available_Buffers);
/* aci_gatt_tx_pool_available_event */
/* Event len: 2 + 2 */
/**
 * @brief Each time BLE FW stack raises the error code @ref
 *        ble_status_insufficient_resources, aci_gatt_tx_pool_available_event()
 *        is generated as soon as the available buffer size  is greater than
 *        maximum ATT MTU.
 * @param Connection_Handle Connection handle related to the request
 * @param Available_Buffers Not used.
 * @retval None
 */
void aci_gatt_tx_pool_available_event(uint16_t Connection_Handle,
                                      uint16_t Available_Buffers)
{
  uint8_t buffer_out[532];

  if(aci_gatt_tx_pool_available_event_preprocess(Connection_Handle, Available_Buffers)) return;

  /* Output params */
  aci_gatt_tx_pool_available_event_rp0 *rp0 = (aci_gatt_tx_pool_available_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Available_Buffers = Available_Buffers;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 2);
  buffer_out[4] = 0x16;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 6, 41);
}

/* aci_gatt_srv_confirmation_event */
/* Event len: 2 */
/**
 * @brief This event is generated when the client has sent the confirmation to a
 *        previously sent indication.
 * @param Connection_Handle Connection handle related to the event.
 * @retval None
 */
void aci_gatt_srv_confirmation_event(uint16_t Connection_Handle)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_srv_confirmation_event_rp0 *rp0 = (aci_gatt_srv_confirmation_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2);
  buffer_out[4] = 0x17;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 6, 42);
}

/* aci_att_srv_exec_write_req_event */
/* Event len: 2 + 1 */
/**
 * @brief This event is generated when an execute write request is received from
 *        the peer. This happens when the client wants to write a long attribute
 *        (i.e. an attribute with a size greater than ATT_MTU -3) or more than
 *        one attribute in a single operation. The aci_gatt_srv_exec_write_resp
 *        command must be sent to give a response to the peer.
 * @param Connection_Handle Handle identifying the connection where the execute
 *        write operation has been received.
 * @param Flags If 1, peer wants to execute all the queued writes. If 0, all
 *        queued writes must be discarded.
 *        Values:
 *        - 0x00: FLUSH
 *        - 0x01: EXECUTE
 * @retval None
 */
void aci_att_srv_exec_write_req_event(uint16_t Connection_Handle,
                                      uint8_t Flags)
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_att_srv_exec_write_req_event_rp0 *rp0 = (aci_att_srv_exec_write_req_event_rp0 *) (buffer_out + 6);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Flags = Flags;
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 1 + 2);
  buffer_out[4] = 0x1c;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 1 + 6, 43);
}

/* aci_gatt_srv_authorize_nwk_event */
/* Event len: 2 + 2 + 1 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief This event is generated if authorization is needed to access the
 *        attribute value. aci_gatt_srv_authorize_resp_nwk command must be sent
 *        in response to this event.
 * @param Conn_Handle Connection handle to be used to identify the connection
 *        with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Attr_Handle
 * @param Operation_Type
 *        Values:
 *        - 0x00: Read
 *        - 0x10: Write Request
 *        - 0x11: Write Command or Signed Write Command
 *        - 0x12: Prepare Write Request
 * @param Attr_Val_Offset Offset from which the value needs to be read or write
 *        Values:
 *        - 0 ... 511
 * @param Data_Length Length of Data field
 * @param Data The data that the client has requested to write
 * @retval None
 */
void aci_gatt_srv_authorize_nwk_event(uint16_t Conn_Handle,
                                      uint16_t Attr_Handle,
                                      uint8_t Operation_Type,
                                      uint16_t Attr_Val_Offset,
                                      uint8_t Data_Length,
                                      uint8_t Data[])
{
  uint8_t buffer_out[532];
  /* Output params */
  aci_gatt_srv_authorize_nwk_event_rp0 *rp0 = (aci_gatt_srv_authorize_nwk_event_rp0 *) (buffer_out + 6);
  rp0->Conn_Handle = Conn_Handle;
  rp0->Attr_Handle = Attr_Handle;
  rp0->Operation_Type = Operation_Type;
  rp0->Attr_Val_Offset = Attr_Val_Offset;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x82;
  buffer_out[1] = 0xFF;
  HOST_TO_LE_16(buffer_out+2,2 + 2 + 1 + 2 + 1 + Data_Length + 2);
  buffer_out[4] = 0x1d;
  buffer_out[5] = 0x0c;
  send_event(buffer_out, 2 + 2 + 1 + 2 + 1 + Data_Length + 6, 44);
}

/* hci_le_connection_complete_event */
/* Event len: 1 + 2 + 1 + 1 + 6 + 2 + 2 + 2 + 1 */
/**
 * @brief The LE Connection Complete event indicates to both of the Hosts
 *        forming the connection that a new connection has been created. Upon
 *        the creation of the connection a Connection_Handle shall be assigned
 *        by the Controller, and passed to the Host in this event. If the
 *        connection establishment fails this event shall be provided to the
 *        Host that had issued the LE_Create_Connection command. This event
 *        indicates to the Host which issued a LE_Create_Connection command and
 *        received a Command Status event if the connection establishment failed
 *        or was successful. The Master_Clock_Accuracy parameter is only valid
 *        for a slave. On a master, this parameter shall be set to 0x00.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle to be used to identify the
 *        connection with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Role Role of the local device in the connection.
 *        Values:
 *        - 0x00: Master
 *        - 0x01: Slave
 * @param Peer_Address_Type The address type of the peer device.
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 * @param Peer_Address Public Device Address or Random Device Address of the
 *        peer device
 * @param Conn_Interval Connection interval used on this connection. Time = N *
 *        1.25 msec
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Conn_Latency Slave latency for the connection in number of connection
 *        events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @param Master_Clock_Accuracy Master clock accuracy. Only valid for a slave.
 *        Values:
 *        - 0x00: 500 ppm
 *        - 0x01: 250 ppm
 *        - 0x02: 150 ppm
 *        - 0x03: 100 ppm
 *        - 0x04: 75 ppm
 *        - 0x05: 50 ppm
 *        - 0x06: 30 ppm
 *        - 0x07: 20 ppm
 * @retval None
 */
void hci_le_connection_complete_event(uint8_t Status,
                                      uint16_t Connection_Handle,
                                      uint8_t Role,
                                      uint8_t Peer_Address_Type,
                                      uint8_t Peer_Address[6],
                                      uint16_t Conn_Interval,
                                      uint16_t Conn_Latency,
                                      uint16_t Supervision_Timeout,
                                      uint8_t Master_Clock_Accuracy)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_connection_complete_event_rp0 *rp0 = (hci_le_connection_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Role = Role;
  rp0->Peer_Address_Type = Peer_Address_Type;
  Osal_MemCpy((void *) rp0->Peer_Address,(const void *) Peer_Address, 6);
  rp0->Conn_Interval = Conn_Interval;
  rp0->Conn_Latency = Conn_Latency;
  rp0->Supervision_Timeout = Supervision_Timeout;
  rp0->Master_Clock_Accuracy = Master_Clock_Accuracy;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 1 + 1 + 6 + 2 + 2 + 2 + 1 + 1;
  buffer_out[3] = 0x01;
  send_event(buffer_out, buffer_out[2] + 3, 44);
}

/* hci_le_advertising_report_event */
/* Event len: 1 + rp0->Num_Reports * (sizeof(packed_Advertising_Report_t)) */
/**
 * @brief The LE Advertising Report event indicates that a Bluetooth device or
 *        multiple Bluetooth devices have responded to an active scan or
 *        received some information during a passive scan. The Controller may
 *        queue these advertising reports and send information from multiple
 *        devices in one LE Advertising Report event.
 * @param Num_Reports Number of responses in this event.
 *        Values:
 *        - 0x01
 * @param Advertising_Report See @ref Advertising_Report_t
 * @retval None
 */
void hci_le_advertising_report_event(uint8_t Num_Reports,
                                     Advertising_Report_t Advertising_Report[])
{
  uint8_t buffer_out[258];
  int output_size = 0;
  /* Output params */
  hci_le_advertising_report_event_rp0 *rp0 = (hci_le_advertising_report_event_rp0 *) (buffer_out + 4);
  rp0->Num_Reports = Num_Reports;
  {
    int i;
    for (i = 0; i < Num_Reports; i++) {
      hci_le_advertising_report_event_rp0 *rp0_tmp = (hci_le_advertising_report_event_rp0 *) (((uint8_t *) rp0) + output_size);
      rp0_tmp->Advertising_Report[0].Event_Type = Advertising_Report[i].Event_Type;
      output_size += sizeof(uint8_t);
      rp0_tmp->Advertising_Report[0].Address_Type = Advertising_Report[i].Address_Type;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0_tmp->Advertising_Report[0].Address, (const void *) Advertising_Report[i].Address, 6);
      output_size += 6;
      rp0_tmp->Advertising_Report[0].Data_Length = Advertising_Report[i].Data_Length;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0_tmp->Advertising_Report[0].Data, (const void *) Advertising_Report[i].Data, Advertising_Report[i].Data_Length);
      output_size += Advertising_Report[i].Data_Length;
      Osal_MemCpy((void *) &rp0_tmp->Advertising_Report[0].Data[Advertising_Report[i].Data_Length], (const void *) &Advertising_Report[i].RSSI, 1);
      output_size += 1;
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + output_size + 1;
  buffer_out[3] = 0x02;
  send_event(buffer_out, buffer_out[2] + 3, 45);
}

/* hci_le_connection_update_complete_event */
/* Event len: 1 + 2 + 2 + 2 + 2 */
/**
 * @brief The LE Connection Update Complete event is used to indicate that the
 *        Controller process to update the connection has completed. On a slave,
 *        if no connection parameters are updated, then this event shall not be
 *        issued. On a master, this event shall be issued if the
 *        Connection_Update command was sent.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle to be used to identify the
 *        connection with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Conn_Interval Connection interval used on this connection. Time = N *
 *        1.25 msec
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Conn_Latency Slave latency for the connection in number of connection
 *        events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @retval None
 */
void hci_le_connection_update_complete_event(uint8_t Status,
                                             uint16_t Connection_Handle,
                                             uint16_t Conn_Interval,
                                             uint16_t Conn_Latency,
                                             uint16_t Supervision_Timeout)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_connection_update_complete_event_rp0 *rp0 = (hci_le_connection_update_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Conn_Interval = Conn_Interval;
  rp0->Conn_Latency = Conn_Latency;
  rp0->Supervision_Timeout = Supervision_Timeout;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 2 + 2 + 2 + 1;
  buffer_out[3] = 0x03;
  send_event(buffer_out, buffer_out[2] + 3, 46);
}

/* hci_le_read_remote_used_features_complete_event */
/* Event len: 1 + 2 + 8 */
/**
 * @brief The LE Read Remote Used Features Complete event is used to indicate
 *        the completion of the process of the Controller obtaining the used
 *        features of the remote Bluetooth device specified by the
 *        Connection_Handle event parameter.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle to be used to identify the
 *        connection with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param LE_Features Bit Mask List of used LE features. For details see LE Link
 *        Layer specification.
 * @retval None
 */
void hci_le_read_remote_used_features_complete_event(uint8_t Status,
                                                     uint16_t Connection_Handle,
                                                     uint8_t LE_Features[8])
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_read_remote_used_features_complete_event_rp0 *rp0 = (hci_le_read_remote_used_features_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  Osal_MemCpy((void *) rp0->LE_Features,(const void *) LE_Features, 8);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 8 + 1;
  buffer_out[3] = 0x04;
  send_event(buffer_out, buffer_out[2] + 3, 47);
}

/* hci_le_long_term_key_request_event */
/* Event len: 2 + 8 + 2 */
/**
 * @brief The LE Long Term Key Request event indicates that the master device is
 *        attempting to encrypt or re-encrypt the link and is requesting the
 *        Long Term Key from the Host. (See [Vol 6] Part B, Section 5.1.3).
 * @param Connection_Handle Connection handle to be used to identify the
 *        connection with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Random_Number 64-bit random number
 * @param Encrypted_Diversifier 16-bit encrypted diversifier
 * @retval None
 */
void hci_le_long_term_key_request_event(uint16_t Connection_Handle,
                                        uint8_t Random_Number[8],
                                        uint16_t Encrypted_Diversifier)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_long_term_key_request_event_rp0 *rp0 = (hci_le_long_term_key_request_event_rp0 *) (buffer_out + 4);
  rp0->Connection_Handle = Connection_Handle;
  Osal_MemCpy((void *) rp0->Random_Number,(const void *) Random_Number, 8);
  rp0->Encrypted_Diversifier = Encrypted_Diversifier;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 8 + 2 + 1;
  buffer_out[3] = 0x05;
  send_event(buffer_out, buffer_out[2] + 3, 48);
}

/* hci_le_data_length_change_event */
/* Event len: 2 + 2 + 2 + 2 + 2 */
/**
 * @brief The LE Data Length Change event notifies the Host of a change to
 *        either the maximum Payload length or the maximum transmission time of
 *        Data Channel PDUs in either direction. The values reported are the
 *        maximum that will actually be used on the connection following the
 *        change.
 * @param Connection_Handle Connection_Handle to be used to identify a
 *        connection.
 * @param MaxTxOctets The maximum number of payload octets in a Link Layer Data
 *        Channel PDU that the local Controller will send on this connection
 *        (connEffectiveMaxTxOctets defined in [Vol 6] Part B, Section 4.5.10).
 *        Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for
 *        future use)
 * @param MaxTxTime The maximum time that the local Controller will take to send
 *        a Link Layer Data Channel PDU on this connection (connEffectiveMaxTx-
 *        Time defined in [Vol 6] Part B, Section 4.5.10). Range 0x0148-0x0848
 *        (0x0000 - 0x0127 and 0x0849 - 0xFFFF Reserved for future use)
 * @param MaxRxOctets The maximum number of payload octets in a Link Layer Data
 *        Channel PDU that the local controller expects to receive on this
 *        connection (connEfectiveMaxRxOctets defined in [Vol 6] Part B, Section
 *        4.5.10). Range 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF
 *        Reserved for future use)
 * @param MaxRxTime The maximum time that the local Controller expects to take
 *        to receive a Link Layer Data Channel PDU on this connection
 *        (connEffectiveMax-RxTime defined in [Vol 6] Part B, Section 4.5.10).
 *        Range 0x0148-0x0848 (0x0000 - 0x0127 and 0x0849 - 0xFFFF Reserved for
 *        future use)
 * @retval None
 */
void hci_le_data_length_change_event(uint16_t Connection_Handle,
                                     uint16_t MaxTxOctets,
                                     uint16_t MaxTxTime,
                                     uint16_t MaxRxOctets,
                                     uint16_t MaxRxTime)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_data_length_change_event_rp0 *rp0 = (hci_le_data_length_change_event_rp0 *) (buffer_out + 4);
  rp0->Connection_Handle = Connection_Handle;
  rp0->MaxTxOctets = MaxTxOctets;
  rp0->MaxTxTime = MaxTxTime;
  rp0->MaxRxOctets = MaxRxOctets;
  rp0->MaxRxTime = MaxRxTime;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 2 + 2 + 2 + 2 + 1;
  buffer_out[3] = 0x07;
  send_event(buffer_out, buffer_out[2] + 3, 49);
}

/* hci_le_read_local_p256_public_key_complete_event */
/* Event len: 1 + 64 */
/**
 * @brief This event is generated when local P-256 key generation is complete.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Local_P256_Public_Key Local P-256 public key.
 * @retval None
 */
void hci_le_read_local_p256_public_key_complete_event(uint8_t Status,
                                                      uint8_t Local_P256_Public_Key[64])
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_read_local_p256_public_key_complete_event_rp0 *rp0 = (hci_le_read_local_p256_public_key_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  Osal_MemCpy((void *) rp0->Local_P256_Public_Key,(const void *) Local_P256_Public_Key, 64);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 64 + 1;
  buffer_out[3] = 0x08;
  send_event(buffer_out, buffer_out[2] + 3, 50);
}

/* hci_le_generate_dhkey_complete_event */
/* Event len: 1 + 32 */
/**
 * @brief This event indicates that LE Diffie Hellman key generation has been
 *        completed by the Controller.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param DHKey Diffie Hellman Key
 * @retval None
 */
void hci_le_generate_dhkey_complete_event(uint8_t Status,
                                          uint8_t DHKey[32])
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_generate_dhkey_complete_event_rp0 *rp0 = (hci_le_generate_dhkey_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  Osal_MemCpy((void *) rp0->DHKey,(const void *) DHKey, 32);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 32 + 1;
  buffer_out[3] = 0x09;
  send_event(buffer_out, buffer_out[2] + 3, 51);
}

/* hci_le_enhanced_connection_complete_event */
/* Event len: 1 + 2 + 1 + 1 + 6 + 6 + 6 + 2 + 2 + 2 + 1 */
/**
 * @brief The LE Enhanced Connection Complete event indicates to both of the
 *        Hosts forming the connection that a new connection has been created.
 *        Upon the creation of the connection a Connection_Handle shall be
 *        assigned by the Controller, and passed to the Host in this event. If
 *        the connection establishment fails, this event shall be provided to
 *        the Host that had issued the LE_Create_Connection command. If this
 *        event is unmasked and LE Connection Complete event is unmasked, only
 *        the LE Enhanced Connection Complete event is sent when a new
 *        connection has been completed. This event indicates to the Host that
 *        issued a LE_Create_Connection command and received a Command Status
 *        event if the connection establishment failed or was successful. The
 *        Master_Clock_Accuracy parameter is only valid for a slave. On a
 *        master, this parameter shall be set to 0x00.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle to be used to identify the
 *        connection with the peer device.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Role Role of the local device in the connection.
 *        Values:
 *        - 0x00: Master
 *        - 0x01: Slave
 * @param Peer_Address_Type 0x00 Public Device Address 0x01 Random Device
 *        Address 0x02 Public Identity Address (Corresponds to Resolved Private
 *        Address) 0x03 Random (Static) Identity Address (Corresponds to
 *        Resolved Private Address)
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Public Identity Address
 *        - 0x03: Random (Static) Identity Address
 * @param Peer_Address Public Device Address, Random Device Address, Public
 *        Identity Address or Random (static) Identity Address of the device to
 *        be connected.
 * @param Local_Resolvable_Private_Address Resolvable Private Address being used
 *        by the local device for this connection. This is only valid when the
 *        Own_Address_Type is set to 0x02 or 0x03. For other Own_Address_Type
 *        values, the Controller shall return all zeros.
 * @param Peer_Resolvable_Private_Address Resolvable Private Address being used
 *        by the peer device for this connection. This is only valid for
 *        Peer_Address_Type 0x02 and 0x03. For other Peer_Address_Type values,
 *        the Controller shall return all zeros.
 * @param Conn_Interval Connection interval used on this connection. Time = N *
 *        1.25 msec
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms) 
 * @param Conn_Latency Slave latency for the connection in number of connection
 *        events.
 *        Values:
 *        - 0x0000 ... 0x01F3
 * @param Supervision_Timeout Supervision timeout for the LE Link. It shall be a
 *        multiple of 10 ms and larger than (1 + connSlaveLatency) *
 *        connInterval * 2. Time = N * 10 msec.
 *        Values:
 *        - 0x000A (100 ms)  ... 0x0C80 (32000 ms) 
 * @param Master_Clock_Accuracy Master clock accuracy. Only valid for a slave.
 *        Values:
 *        - 0x00: 500 ppm
 *        - 0x01: 250 ppm
 *        - 0x02: 150 ppm
 *        - 0x03: 100 ppm
 *        - 0x04: 75 ppm
 *        - 0x05: 50 ppm
 *        - 0x06: 30 ppm
 *        - 0x07: 20 ppm
 * @retval None
 */
void hci_le_enhanced_connection_complete_event(uint8_t Status,
                                               uint16_t Connection_Handle,
                                               uint8_t Role,
                                               uint8_t Peer_Address_Type,
                                               uint8_t Peer_Address[6],
                                               uint8_t Local_Resolvable_Private_Address[6],
                                               uint8_t Peer_Resolvable_Private_Address[6],
                                               uint16_t Conn_Interval,
                                               uint16_t Conn_Latency,
                                               uint16_t Supervision_Timeout,
                                               uint8_t Master_Clock_Accuracy)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_enhanced_connection_complete_event_rp0 *rp0 = (hci_le_enhanced_connection_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Role = Role;
  rp0->Peer_Address_Type = Peer_Address_Type;
  Osal_MemCpy((void *) rp0->Peer_Address,(const void *) Peer_Address, 6);
  Osal_MemCpy((void *) rp0->Local_Resolvable_Private_Address,(const void *) Local_Resolvable_Private_Address, 6);
  Osal_MemCpy((void *) rp0->Peer_Resolvable_Private_Address,(const void *) Peer_Resolvable_Private_Address, 6);
  rp0->Conn_Interval = Conn_Interval;
  rp0->Conn_Latency = Conn_Latency;
  rp0->Supervision_Timeout = Supervision_Timeout;
  rp0->Master_Clock_Accuracy = Master_Clock_Accuracy;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 1 + 1 + 6 + 6 + 6 + 2 + 2 + 2 + 1 + 1;
  buffer_out[3] = 0x0a;
  send_event(buffer_out, buffer_out[2] + 3, 52);
}

/* hci_le_direct_advertising_report_event */
/* Event len: 1 + rp0->Num_Reports * (sizeof(packed_Direct_Advertising_Report_t)) */
/**
 * @brief The LE Direct Advertising Report event indicates that directed
 *        advertisements have been received where the advertiser is using a
 *        resolvable private address for the InitA field in the ADV_DIRECT_IND
 *        PDU and the Scanning_Filter_Policy is equal to 0x02 or 0x03, see
 *        HCI_LE_Set_Scan_Parameters. Direct_Address_Type and Direct_Addres is
 *        the address the directed advertisements are being directed to.
 *        Address_Type and Address is the address of the advertiser sending the
 *        directed advertisements.
 * @param Num_Reports Number of responses in this event.
 *        Values:
 *        - 0x01
 * @param Direct_Advertising_Report See @ref Direct_Advertising_Report_t
 * @retval None
 */
void hci_le_direct_advertising_report_event(uint8_t Num_Reports,
                                            Direct_Advertising_Report_t Direct_Advertising_Report[])
{
  uint8_t buffer_out[258];
  int output_size = 0;
  /* Output params */
  hci_le_direct_advertising_report_event_rp0 *rp0 = (hci_le_direct_advertising_report_event_rp0 *) (buffer_out + 4);
  rp0->Num_Reports = Num_Reports;
  {
    int i;
    for (i = 0; i < Num_Reports; i++) {
      rp0->Direct_Advertising_Report[i].Event_Type = Direct_Advertising_Report[i].Event_Type;
      output_size += sizeof(uint8_t);
      rp0->Direct_Advertising_Report[i].Address_Type = Direct_Advertising_Report[i].Address_Type;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0->Direct_Advertising_Report[i].Address, (const void *) Direct_Advertising_Report[i].Address, 6);
      output_size += 6;
      rp0->Direct_Advertising_Report[i].Direct_Address_Type = Direct_Advertising_Report[i].Direct_Address_Type;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0->Direct_Advertising_Report[i].Direct_Address, (const void *) Direct_Advertising_Report[i].Direct_Address, 6);
      output_size += 6;
      rp0->Direct_Advertising_Report[i].RSSI = Direct_Advertising_Report[i].RSSI;
      output_size += sizeof(int8_t);
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + output_size + 1;
  buffer_out[3] = 0x0b;
  send_event(buffer_out, buffer_out[2] + 3, 53);
}

/* hci_le_phy_update_complete_event */
/* Event len: 1 + 2 + 1 + 1 */
/**
 * @brief The LE PHY Update Complete Event is used to indicate that the
 *        Controller has changed the transmitter PHY or receiver PHY in use. If
 *        the Controller changes the transmitter PHY, the receiver PHY, or both
 *        PHYs, this event shall be issued. If an LE_Set_PHY command was sent
 *        and the Controller determines that neither PHY will change as a
 *        result, it issues this event immediately.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection_Handle to be used to identify a
 *        connection.
 * @param TX_PHY The transmitter PHY for the connection
 *        Values:
 *        - 0x01: The transmitter PHY for the connection is LE 1M
 *        - 0x02: The transmitter PHY for the connection is LE 2M
 *        - 0x03: The transmitter PHY for the connection is LE Coded
 * @param RX_PHY The receiver PHY for the connection
 *        Values:
 *        - 0x01: The receiver PHY for the connection is LE 1M
 *        - 0x02: The receiver PHY for the connection is LE 2M
 *        - 0x03: The receiver PHY for the connection is LE Coded
 * @retval None
 */
void hci_le_phy_update_complete_event(uint8_t Status,
                                      uint16_t Connection_Handle,
                                      uint8_t TX_PHY,
                                      uint8_t RX_PHY)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_phy_update_complete_event_rp0 *rp0 = (hci_le_phy_update_complete_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->TX_PHY = TX_PHY;
  rp0->RX_PHY = RX_PHY;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 1 + 1 + 1;
  buffer_out[3] = 0x0c;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_extended_advertising_report_event */
/* Event len: 1 + rp0->Num_Reports * (sizeof(packed_Extended_Advertising_Report_t)) */
/**
 * @brief The LE Extended Advertising Report event indicates that one or more
 *        Bluetooth devices have responded to an active scan or have broadcast
 *        advertisements that were received during a passive scan. The
 *        Controller may coalesce multiple advertising reports from the same or
 *        different advertisers into a single LE Extended Advertising Report
 *        event, provided all the parameters from all the advertising reports
 *        fit in a single HCI event. This event shall only be generated if
 *        scanning was enabled using the LE Set Extended Scan Enable command. It
 *        reports advertising events using either legacy or extended advertising
 *        PDUs. The Controller may split the data from a single advertisement
 *        (whether one PDU or several) into several reports. If so, each report
 *        except the last shall have an Event_Type with a data status field of
 *        "incomplete, more data to come", while the last shall have the value
 *        "complete"; the Address_Type, Address, Advertising_SID, Primary_PHY,
 *        and Secondary_PHY fields shall be the same in all the reports. When a
 *        scan response is received, bits 0-2 and 4 of the event type shall
 *        indicate the properties of the original advertising event. An
 *        Event_Type with a data status field of "incomplete, data truncated"
 *        indicates that the Controller attempted to receive an AUX_CHAIN_IND
 *        PDU but was not successful.
 * @param Num_Reports Number of separate reports in the event
 *        Values:
 *        - 0x01 ... 0x0A
 * @param Extended_Advertising_Report See @ref Extended_Advertising_Report_t
 * @retval None
 */
void hci_le_extended_advertising_report_event(uint8_t Num_Reports,
                                              Extended_Advertising_Report_t Extended_Advertising_Report[])
{
  uint8_t buffer_out[258];
  int output_size = 0;
  /* Output params */
  hci_le_extended_advertising_report_event_rp0 *rp0 = (hci_le_extended_advertising_report_event_rp0 *) (buffer_out + 4);
  rp0->Num_Reports = Num_Reports;
  {
    int i;
    for (i = 0; i < Num_Reports; i++) {
      hci_le_extended_advertising_report_event_rp0 *rp0_tmp = (hci_le_extended_advertising_report_event_rp0 *) (((uint8_t *) rp0) + output_size);
      rp0_tmp->Extended_Advertising_Report[0].Event_Type = Extended_Advertising_Report[i].Event_Type;
      output_size += sizeof(uint16_t);
      rp0_tmp->Extended_Advertising_Report[0].Address_Type = Extended_Advertising_Report[i].Address_Type;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0_tmp->Extended_Advertising_Report[0].Address, (const void *) Extended_Advertising_Report[i].Address, 6);
      output_size += 6;
      rp0_tmp->Extended_Advertising_Report[0].Primary_PHY = Extended_Advertising_Report[i].Primary_PHY;
      output_size += sizeof(uint8_t);
      rp0_tmp->Extended_Advertising_Report[0].Secondary_PHY = Extended_Advertising_Report[i].Secondary_PHY;
      output_size += sizeof(uint8_t);
      rp0_tmp->Extended_Advertising_Report[0].Advertising_SID = Extended_Advertising_Report[i].Advertising_SID;
      output_size += sizeof(uint8_t);
      rp0_tmp->Extended_Advertising_Report[0].TX_Power = Extended_Advertising_Report[i].TX_Power;
      output_size += sizeof(int8_t);
      rp0_tmp->Extended_Advertising_Report[0].RSSI = Extended_Advertising_Report[i].RSSI;
      output_size += sizeof(int8_t);
      rp0_tmp->Extended_Advertising_Report[0].Periodic_Advertising_Interval = Extended_Advertising_Report[i].Periodic_Advertising_Interval;
      output_size += sizeof(uint16_t);
      rp0_tmp->Extended_Advertising_Report[0].Direct_Address_Type = Extended_Advertising_Report[i].Direct_Address_Type;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0_tmp->Extended_Advertising_Report[0].Direct_Address, (const void *) Extended_Advertising_Report[i].Direct_Address, 6);
      output_size += 6;
      rp0_tmp->Extended_Advertising_Report[0].Data_Length = Extended_Advertising_Report[i].Data_Length;
      output_size += sizeof(uint8_t);
      Osal_MemCpy((void *) &rp0_tmp->Extended_Advertising_Report[0].Data, (const void *) Extended_Advertising_Report[i].Data, Extended_Advertising_Report[i].Data_Length);
      output_size += Extended_Advertising_Report[i].Data_Length;
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + output_size + 1;
  buffer_out[3] = 0x0d;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_periodic_advertising_sync_established_event */
/* Event len: 1 + 2 + 1 + 1 + 6 + 1 + 2 + 1 */
/**
 * @brief The LE Periodic Advertising Report event indicates that the Controller
 *        has received a Periodic Advertising packet. The Sync_Handle parameter
 *        indicates the identifier for the periodic advertisements specified by
 *        the Advertising SID subfield of the ADI field in the ADV_EXT_IND PDU.
 *        The Controller may split the data from a single periodic advertisement
 *        (whether one PDU or several) into several reports. If so, each report
 *        except the last shall have a Data_Status of "incomplete, more data to
 *        come", while the last shall have the value "complete". A Data_Status
 *        of "incomplete, data truncated" indicates that the Controller
 *        attempted to receive an AUX_CHAIN_IND PDU but was not successful. The
 *        Unused parameter shall be set to 0xFF by the Controller and ignored by
 *        the Host.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Sync_Handle Sync handle that identifies the synchronization
 *        information about the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Advertising_SID Advertising SID subfield in the ADI field of the PDU
 *        Values:
 *        - 0x00 ... 0x0F: Value of the Advertising SID subfield in the ADI field of the PDU
 *        - 0x10 ... 0xFF: Reserved for future use
 * @param Advertiser_Address_Type Advertising Adress Type
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 *        - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 *        - 0x03: Random (static) Identity Address (corresponds to Resolved Private
Address)
 *        - 0x04 ... 0xFF: Reserved for future use
 * @param Advertiser_Address Public Device Address, Random Device Address,
 *        Public Identity Address, or Random (static) Identity Address of the
 *        advertiser
 * @param Advertiser_PHY Advertiser PHY
 *        Values:
 *        - 0x01: Advertiser PHY is LE 1M
 *        - 0x02: Advertiser PHY is LE 2M
 *        - 0x03: Advertiser PHY is LE Coded
 *        - 0x04 ... 0xFF: Reserved for future use
 * @param Periodic_Advertising_Interval Periodic Advertising Interval Time = N *
 *        1.25 ms Time Range: 7.5 ms to 81.91875 s
 *        Values:
 *        - 0x0006 ... 0xFFFF: Periodic Advertising Interval
 * @param Advertiser_Clock_Accuracy Advertiser Clock Accuracy
 *        Values:
 *        - 0x00: 500 ppm
 *        - 0x01: 250 ppm
 *        - 0x02: 150 ppm
 *        - 0x03: 100 ppm
 *        - 0x04: 75 ppm
 *        - 0x05: 50 ppm
 *        - 0x06: 30 ppm
 *        - 0x07: 20 ppm
 *        - 0x08 ... 0xFF: Reserved for future use
 * @retval None
 */
void hci_le_periodic_advertising_sync_established_event(uint8_t Status,
                                                        uint16_t Sync_Handle,
                                                        uint8_t Advertising_SID,
                                                        uint8_t Advertiser_Address_Type,
                                                        uint8_t Advertiser_Address[6],
                                                        uint8_t Advertiser_PHY,
                                                        uint16_t Periodic_Advertising_Interval,
                                                        uint8_t Advertiser_Clock_Accuracy)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_periodic_advertising_sync_established_event_rp0 *rp0 = (hci_le_periodic_advertising_sync_established_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Sync_Handle = Sync_Handle;
  rp0->Advertising_SID = Advertising_SID;
  rp0->Advertiser_Address_Type = Advertiser_Address_Type;
  Osal_MemCpy((void *) rp0->Advertiser_Address,(const void *) Advertiser_Address, 6);
  rp0->Advertiser_PHY = Advertiser_PHY;
  rp0->Periodic_Advertising_Interval = Periodic_Advertising_Interval;
  rp0->Advertiser_Clock_Accuracy = Advertiser_Clock_Accuracy;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 1 + 1 + 6 + 1 + 2 + 1 + 1;
  buffer_out[3] = 0x0e;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_periodic_advertising_report_event */
/* Event len: 2 + 1 + 1 + 1 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
 * @brief The LE Periodic Advertising Report event indicates that the Controller
 *        has received a Periodic Advertising packet. The Sync_Handle parameter
 *        indicates the identifier for the periodic advertisements specified by
 *        the Advertising SID subfield of the ADI field in the ADV_EXT_IND PDU.
 *        The Controller may split the data from a single periodic advertisement
 *        (whether one PDU or several) into several reports. If so, each report
 *        except the last shall have a Data_Status of "incomplete, more data to
 *        come", while the last shall have the value "complete". A Data_Status
 *        of "incomplete, data truncated" indicates that the Controller
 *        attempted to receive an AUX_CHAIN_IND PDU but was not successful. The
 *        Unused parameter shall be set to 0xFF by the Controller and ignored by
 *        the Host.
 * @param Sync_Handle Sync handle that identifies the synchronization
 *        information about the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param TX_Power TX Power. Units: dBm
 *        Values:
 *        - -127 ... 126
 *        - 127: NA
 * @param RSSI RSSI value Units: dBm
 *        Values:
 *        - -127 ... 20: RSSI value
 *        - 127: RSSI is not available
 * @param CTE_Type
 *        Values:
 *        - 0x00: AoA Constant Tone Extension
 *        - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 *        - 0xFF: No Constant Tone Extension
 * @param Data_Status Data Status
 *        Values:
 *        - 0x00: Data complete
 *        - 0x01: Data incomplete, more data to come
 *        - 0x02: Data incomplete, data truncated, no more to come
 *        - 0x03 ... 0xFF: Reserved for future use
 * @param Data_Length Length of the Data field
 *        Values:
 *        - 0 ... 247: Length of the Data field
 *        - 248 ... 255: Reserved for future use
 * @param Data Data received from a Periodic Advertising packet
 * @retval None
 */
void hci_le_periodic_advertising_report_event(uint16_t Sync_Handle,
                                              int8_t TX_Power,
                                              int8_t RSSI,
                                              uint8_t CTE_Type,
                                              uint8_t Data_Status,
                                              uint8_t Data_Length,
                                              uint8_t Data[])
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_periodic_advertising_report_event_rp0 *rp0 = (hci_le_periodic_advertising_report_event_rp0 *) (buffer_out + 4);
  rp0->Sync_Handle = Sync_Handle;
  rp0->TX_Power = TX_Power;
  rp0->RSSI = RSSI;
  rp0->CTE_Type = CTE_Type;
  rp0->Data_Status = Data_Status;
  rp0->Data_Length = Data_Length;
  Osal_MemCpy((void *) rp0->Data,(const void *) Data, Data_Length);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 1 + 1 + 1 + 1 + 1 + Data_Length + 1;
  buffer_out[3] = 0x0f;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_periodic_advertising_sync_lost_event */
/* Event len: 2 */
/**
 * @brief The LE Periodic Advertising Sync Lost event indicates that the
 *        Controller has not received a Periodic Advertising packet identified
 *        by Sync_Handle within the timeout period.
 * @param Sync_Handle Sync handle that identifies the synchronization
 *        information about the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
void hci_le_periodic_advertising_sync_lost_event(uint16_t Sync_Handle)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_periodic_advertising_sync_lost_event_rp0 *rp0 = (hci_le_periodic_advertising_sync_lost_event_rp0 *) (buffer_out + 4);
  rp0->Sync_Handle = Sync_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 1;
  buffer_out[3] = 0x10;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_scan_timeout_event */
/* Event len: 0 */
/**
 * @brief The LE Scan Timeout event indicates that scanning has ended because
 *        the duration has expired. This event shall only be generated if
 *        scanning was enabled using the LE Set Extended Scan Enable command.
 * @retval None
 */
void hci_le_scan_timeout_event(void)
{
  uint8_t buffer_out[258];
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 0 + 1;
  buffer_out[3] = 0x11;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_advertising_set_terminated_event */
/* Event len: 1 + 1 + 2 + 1 */
/**
 * @brief The LE Advertising Set Terminated event indicates that the Controller
 *        has terminated advertising in the advertising sets specified by the
 *        Advertising_Handle parameter. This event shall be generated every time
 *        connectable advertising in an advertising set results in a connection
 *        being created. This event shall only be generated if advertising was
 *        enabled using the LE Set Extended Advertising Enable command. The
 *        Connection_Handle parameter is only valid when advertising ends
 *        because a connection was created. If the
 *        Max_Extended_Advertising_Events parameter in the
 *        LE_Set_Extended_Advertising_Enable command was non-zero, the
 *        Num_Completed_Extended_Advertising_Events parameter shall be set to
 *        the number of completed extended advertising events the Controller had
 *        transmitted when either the duration elapsed or the maximum number of
 *        extended advertising events was reached; otherwise it shall be set to
 *        zero. If advertising has terminated as a result of the advertising
 *        duration elapsing, the Status parameter shall be set to the error code
 *        Advertising Timeout (0x3C). If advertising has terminated because the
 *        Max_Extended_Advertising_Events was reached, the Status parameter
 *        shall be set to the error code Limit Reached (0x43).
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Advertising_Handle Advertising handle in which advertising has ended
 *        Values:
 *        - 0x00 ... 0xEF: Advertising_Handle in which advertising has ended
 *        - 0xF0 ... 0xFF: Reserved for future use
 * @param Connection_Handle Connection_Handle to be used to identify a
 *        connection.
 * @param Num_Completed_Extended_Advertising_Events Number of completed extended
 *        advertising events transmitted by the Controller
 * @retval None
 */
void hci_le_advertising_set_terminated_event(uint8_t Status,
                                             uint8_t Advertising_Handle,
                                             uint16_t Connection_Handle,
                                             uint8_t Num_Completed_Extended_Advertising_Events)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_advertising_set_terminated_event_rp0 *rp0 = (hci_le_advertising_set_terminated_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Advertising_Handle = Advertising_Handle;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Num_Completed_Extended_Advertising_Events = Num_Completed_Extended_Advertising_Events;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 1 + 2 + 1 + 1;
  buffer_out[3] = 0x12;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_scan_request_received_event */
/* Event len: 1 + 1 + 6 */
/**
 * @brief The LE Scan Request Received event indicates that a SCAN_REQ PDU or an
 *        AUX_SCAN_REQ PDU has been received by the advertiser. The request
 *        contains a device address from a scanner that is allowed by the
 *        advertising filter policy. The advertising set is identified by
 *        Advertising_Handle. This event shall only be generated if advertising
 *        was enabled using the LE Set Extended Advertising Enable command. The
 *        Scanner_Address_Type and Scanner_Address indicates the type of the
 *        address and the address of the scanner device.
 * @param Advertising_Handle It is used to identify an advertising set
 *        Values:
 *        - 0x00 ... 0xEF: Used to identify an advertising set
 *        - 0xF0 ... 0xFF: Reserved for future use
 * @param Scanner_Address_Type Scanner address  type
 *        Values:
 *        - 0x00: Public Device Address
 *        - 0x01: Random Device Address
 *        - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 *        - 0x03: Random (static) Identity Address (corresponds to Resolved Private
Address)
 *        - 0x04 ... 0xFF: Reserved for future use
 * @param Scanner_Address Public Device Address, Random Device Address, Public
 *        Identity Address or Random (static) Identity Address of the
 *        advertising device
 * @retval None
 */
void hci_le_scan_request_received_event(uint8_t Advertising_Handle,
                                        uint8_t Scanner_Address_Type,
                                        uint8_t Scanner_Address[6])
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_scan_request_received_event_rp0 *rp0 = (hci_le_scan_request_received_event_rp0 *) (buffer_out + 4);
  rp0->Advertising_Handle = Advertising_Handle;
  rp0->Scanner_Address_Type = Scanner_Address_Type;
  Osal_MemCpy((void *) rp0->Scanner_Address,(const void *) Scanner_Address, 6);
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 1 + 6 + 1;
  buffer_out[3] = 0x13;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_channel_selection_algorithm_event */
/* Event len: 2 + 1 */
/**
 * @brief The LE Channel Selection Algorithm Event indicates which channel
 *        selection algorithm is used on a data channel connection (see [Vol 6]
 *        Part B, Section 4.5.8).
 * @param Connection_Handle Connection_Handle to be used to identify a
 *        connection.
 * @param Channel_Selection_Algorithm Channel selection algorithm to be  used on
 *        a data channel connection
 *        Values:
 *        - 0x00: LE Channel Selection Algorithm #1 is used
 *        - 0x01: LE Channel Selection Algorithm #2 is used
 *        - 0x02 ... 0xFF: Reserved for future use
 * @retval None
 */
void hci_le_channel_selection_algorithm_event(uint16_t Connection_Handle,
                                              uint8_t Channel_Selection_Algorithm)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_channel_selection_algorithm_event_rp0 *rp0 = (hci_le_channel_selection_algorithm_event_rp0 *) (buffer_out + 4);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Channel_Selection_Algorithm = Channel_Selection_Algorithm;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 1 + 1;
  buffer_out[3] = 0x14;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_connectionless_iq_report_event */
/* Event len: 2 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 1 + rp0->Sample_Count * (sizeof(packed_Samples_t)) */
/**
 * @brief The HCI_LE_Connectionless_IQ_Report event is used by the Controller to
 *        report IQ information from the Constant Tone Extension of a received
 *        advertising packet forming part of the periodic advertising train
 *        identified by Sync_Handle and to report IQ information from the
 *        Constant Tone Extension of a received Test Mode packet (see Section
 *        7.8.28). The index of the channel on which the packet was received,
 *        the RSSI of the packet (excluding the Constant Tone Extension), the ID
 *        of the antenna on which this was measured, the type of Constant Tone
 *        Extension, the value of paEventCounter, and the IQ samples of the
 *        Constant Tone Extension of the advertisement are reported in the
 *        corresponding parameters. For any given sample, either both or neither
 *        of I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations
 *        parameter specifies the sampling rate used by the Controller. The
 *        Packet_Status parameter indicates whether the received packet had a
 *        valid CRC and, if not, whether the Controller has determined the
 *        position and size of the Constant Tone Extension using the Length and
 *        CTETime fields. Note: A Controller is not required to generate this
 *        event for packets that have a bad CRC. The Constant Tone Extension
 *        format is defined in [Vol 6] Part B, Section 2.5.1. If the PDU
 *        contains AdvData, then the HCI_LE_Periodic_Advertising_Report event
 *        shall be generated before this event. The Controller is not required
 *        to generate this event for a Constant Tone Extension with a type that
 *        it does not support. This event is also used by the Controller to
 *        report that it has insufficient resources to report IQ samples for all
 *        received Constant Tone Extensions and has failed to sample at least
 *        once. In this case Packet_Status shall be set to 0xFF and Sample_Count
 *        to 0x00.
 * @param Sync_Handle Sync_Handle identifying the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 *        - 0x0FFF: TEST_SYNC_HANDLE
 * @param Channel_Index 0x25-0x27 can be used only for packets generated during
 *        test modes.
 *        Values:
 *        - 0x00 ... 0x27: The index of the channel on which the packet was received.
 * @param RSSI RSSI of the packet. Units: 0.1 dBm.
 *        Values:
 *        - -1270 ... 200
 * @param RSSI_Antenna_ID Antenna ID
 * @param CTE_Type Type of Constant Tone Extension.
 *        Values:
 *        - 0x00: AoA_CTE
 *        - 0x01: AoD_CTE_1us
 *        - 0x02: AoD_CTE_2us
 * @param Slot_Durations Sampling rate used by the Controller.
 *        Values:
 *        - 0x01: CTE_SLOT_1us
 *        - 0x02: CTE_SLOT_2us
 * @param Packet_Status It indicates whether the received packet had a valid CRC
 *        and, if not, whether the Controller has determined the position and
 *        size of the Constant Tone Extension using the Length and CTETime
 *        fields. 0x00 - CRC was correct;  0x01 - CRC was incorrect and the
 *        Length and CTETime fields of the packet were used to determine
 *        sampling points;  0x02 - CRC was incorrect but the Controller has
 *        determined the position and length of the Constant Tone Extension in
 *        some other way;  0xFF - Insufficient resources to sample
 *        (Channel_Index, CTE_Type, and Slot_Durations invalid).
 *        Values:
 *        - 0x00: CRC_OK
 *        - 0x01: CRC_ERROR_1
 *        - 0x02: CRC_ERROR_2
 *        - 0xFF: NO_SAMPLES
 * @param Periodic_Event_Counter The value of paEventCounter (see [Vol 6] Part
 *        B, Section 4.4.2.1) for the reported AUX_SYNC_IND PDU
 * @param Sample_Count Total number of sample pairs (there shall be the same
 *        number of I samples and Q samples). Note: This number is dependent on
 *        the switch and sample slot durations used.
 *        Values:
 *        - 0x00
 *        - 0x09 ... 0x52
 * @param Samples See @ref Samples_t
 * @retval None
 */
void hci_le_connectionless_iq_report_event(uint16_t Sync_Handle,
                                           uint8_t Channel_Index,
                                           int16_t RSSI,
                                           uint8_t RSSI_Antenna_ID,
                                           uint8_t CTE_Type,
                                           uint8_t Slot_Durations,
                                           uint8_t Packet_Status,
                                           uint16_t Periodic_Event_Counter,
                                           uint8_t Sample_Count,
                                           Samples_t Samples[])
{
  uint8_t buffer_out[258];
  int output_size = 0;
  /* Output params */
  hci_le_connectionless_iq_report_event_rp0 *rp0 = (hci_le_connectionless_iq_report_event_rp0 *) (buffer_out + 4);
  rp0->Sync_Handle = Sync_Handle;
  rp0->Channel_Index = Channel_Index;
  rp0->RSSI = RSSI;
  rp0->RSSI_Antenna_ID = RSSI_Antenna_ID;
  rp0->CTE_Type = CTE_Type;
  rp0->Slot_Durations = Slot_Durations;
  rp0->Packet_Status = Packet_Status;
  rp0->Periodic_Event_Counter = Periodic_Event_Counter;
  rp0->Sample_Count = Sample_Count;
  {
    int i;
    for (i = 0; i < Sample_Count; i++) {
      rp0->Samples[i].I_Sample = Samples[i].I_Sample;
      output_size += sizeof(int8_t);
      rp0->Samples[i].Q_Sample = Samples[i].Q_Sample;
      output_size += sizeof(int8_t);
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 1 + output_size + 1;
  buffer_out[3] = 0x15;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_connection_iq_report_event */
/* Event len: 2 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 1 + rp0->Sample_Count * (sizeof(packed_Samples_t)) */
/**
 * @brief The HCI_LE_Connection_IQ_Report event is used by the Controller to
 *        report the IQ samples from the Constant Tone Extension of a received
 *        packet (see [Vol 6] Part B, Section 2.4.2.26). The Connection_Handle
 *        parameter identifies the connection that corresponds to the reported
 *        information. The receiver PHY, the index of the data channel, the RSSI
 *        value of the packet (excluding the Constant Tone Extension), the ID of
 *        the antenna on which this was measured, the type of Constant Tone
 *        Extension, the value of connEventCounter, and the IQ samples of the
 *        Constant Tone Extension of the received packet are reported in the
 *        corresponding parameters. For any given sample, either both or neither
 *        of I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations
 *        parameter specifies the sampling rate used by the Controller. The
 *        Packet_Status parameter indicates whether the received packet had a
 *        valid CRC and, if not, whether the Controller has determined the
 *        position and size of the Constant Tone Extension using the Length and
 *        CTETime fields. Note: A Controller is not required to generate this
 *        event for packets that have a bad CRC. This event is also used by the
 *        Controller to report that it has insufficient resources to report IQ
 *        samples for all received Constant Tone Extensions and has failed to
 *        sample at least once. In this case Packet_Status shall be set to 0xFF
 *        and Sample_Count to 0x00. The Constant Tone Extension format is
 *        defined in [Vol 6] Part B, Section 2.1.5.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param RX_PHY
 *        Values:
 *        - 0x01: The receiver PHY for the connection is LE 1M
 *        - 0x02: The receiver PHY for the connection is LE 2M
 * @param Data_Channel_Index
 *        Values:
 *        - 0x00 ... 0x24: The index of the data channel on which the Data Physical Channel PDU was received.
 * @param RSSI RSSI of the packet. Units: 0.1 dBm.
 *        Values:
 *        - -1270 ... 200
 * @param RSSI_Antenna_ID ID of the antenna on which the RSSI is measured
 * @param CTE_Type
 *        Values:
 *        - 0x00: AoA Constant Tone Extension
 *        - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 *        - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * @param Slot_Durations Sampling rate used by the Controller.
 *        Values:
 *        - 0x01: CTE_SLOT_1us
 *        - 0x02: CTE_SLOT_2us
 * @param Packet_Status
 *        Values:
 *        - 0x00: CRC was correct
 *        - 0x01: CRC was incorrect and the Length and CTETime fields of the packet were used to determine sampling points
 *        - 0x02: CRC was incorrect but the Controller has determined the position and length of the Constant Tone Extension in some other way
 *        - 0xFF: Insufficient resources to sample (Channel_Index, CTE_Type, and Slot_Durations invalid).
 * @param Connection_Event_Counter The value of connEventCounter (see [Vol 6]
 *        Part B, Section 4.5.1) for the reported PDU
 * @param Sample_Count Total number of sample pairs.
 *        Values:
 *        - 0x00
 *        - 0x09 ... 0x52
 * @param Samples See @ref Samples_t
 * @retval None
 */
void hci_le_connection_iq_report_event(uint16_t Connection_Handle,
                                       uint8_t RX_PHY,
                                       uint8_t Data_Channel_Index,
                                       int16_t RSSI,
                                       uint8_t RSSI_Antenna_ID,
                                       uint8_t CTE_Type,
                                       uint8_t Slot_Durations,
                                       uint8_t Packet_Status,
                                       uint16_t Connection_Event_Counter,
                                       uint8_t Sample_Count,
                                       Samples_t Samples[])
{
  uint8_t buffer_out[258];
  int output_size = 0;
  /* Output params */
  hci_le_connection_iq_report_event_rp0 *rp0 = (hci_le_connection_iq_report_event_rp0 *) (buffer_out + 4);
  rp0->Connection_Handle = Connection_Handle;
  rp0->RX_PHY = RX_PHY;
  rp0->Data_Channel_Index = Data_Channel_Index;
  rp0->RSSI = RSSI;
  rp0->RSSI_Antenna_ID = RSSI_Antenna_ID;
  rp0->CTE_Type = CTE_Type;
  rp0->Slot_Durations = Slot_Durations;
  rp0->Packet_Status = Packet_Status;
  rp0->Connection_Event_Counter = Connection_Event_Counter;
  rp0->Sample_Count = Sample_Count;
  {
    int i;
    for (i = 0; i < Sample_Count; i++) {
      rp0->Samples[i].I_Sample = Samples[i].I_Sample;
      output_size += sizeof(int8_t);
      rp0->Samples[i].Q_Sample = Samples[i].Q_Sample;
      output_size += sizeof(int8_t);
    }
  }
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 1 + output_size + 1;
  buffer_out[3] = 0x16;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_cte_request_failed_event */
/* Event len: 1 + 2 */
/**
 * @brief This event is used by the Controller to report an issue following a
 *        request to a peer device to reply with a packet containing an
 *        LL_CTE_RSP PDU and a Constant Tone Extension. It shall be generated if
 *        the packet containing the LL_CTE_RSP PDU sent in response did not
 *        contain a Constant Tone Extension or if the peer rejected the request.
 *        It shall not be generated if the packet containing the LL_CTE_RSP PDU
 *        had a CRC error or if the procedure response timeout timer (see [Vol
 *        6] Part B, Section 5.2) expired.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @retval None
 */
void hci_le_cte_request_failed_event(uint8_t Status,
                                     uint16_t Connection_Handle)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_cte_request_failed_event_rp0 *rp0 = (hci_le_cte_request_failed_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 1;
  buffer_out[3] = 0x17;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_periodic_advertising_sync_transfer_received_event */
/* Event len: 1 + 2 + 2 + 2 + 1 + 1 + 6 + 1 + 2 + 1 */
/**
 * @brief The HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is used
 *        by the Controller to report that it has received periodic advertising
 *        synchronization information from the device referred to by the
 *        Connection_Handle parameter and either successfully synchronized to
 *        the periodic advertising train or timed out while attempting to
 *        synchronize. The Status will be zero if it successfully synchronized
 *        and non-zero otherwise. The Service_Data value is provided by the Host
 *        of the device sending the information. The Sync_Handle identifies the
 *        periodic advertising in subsequent commands and events and shall be
 *        assigned by the Controller. The remaining parameters provide
 *        information about the periodic advertising (see Section 7.7.65.14). If
 *        Status is non-zero, all parameter values are valid except Sync_Handle,
 *        which the Host shall ignore. Note: If the Controller is already
 *        synchronized to the periodic advertising train described in the
 *        received information, no event will be generated.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Service_data A value provided by the peer device
 * @param Sync_Handle Sync handle that identifies the synchronization
 *        information about the periodic advertising train.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Advertising_SID
 *        Values:
 *        - 0x00 ... 0x0F: Value of the Advertising SID used to advertise the periodic advertising
 * @param Advertiser_Address_Type
 *        Values:
 *        - 0x00: Public Device Address or Public Identity Address
 *        - 0x01: Random Device Address or Random (static) Identity Address
 *        - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 *        - 0x03: Random (static) Identity Address (corresponds to Resolved Private Address)
 * @param Advertiser_Address Public Device Address, Random Device Address,
 *        Public Identity Address, or Random (static) Identity Address of the
 *        advertiser
 * @param Advertiser_PHY
 *        Values:
 *        - 0x01: Advertiser PHY is LE 1M
 *        - 0x02: Advertiser PHY is LE 2M
 *        - 0x03: Advertiser PHY is LE Coded
 * @param Periodic_Advertising_Interval Periodic advertising interval. Time = N
 *        * 1.25 ms; Time Range: 7.5ms to 81.91875 s.
 *        Values:
 *        - 0x0006 (7.50 ms)  ... 0xFFFF (NaN) : Periodic advertising interval
 * @param Advertiser_Clock_Accuracy Advertiser Clock Accuracy
 *        Values:
 *        - 0x00: 500 ppm
 *        - 0x01: 250 ppm
 *        - 0x02: 150 ppm
 *        - 0x03: 100 ppm
 *        - 0x04: 75 ppm
 *        - 0x05: 60 ppm
 *        - 0x06: 30 ppm
 *        - 0x07: 20 ppm
 * @retval None
 */
void hci_le_periodic_advertising_sync_transfer_received_event(uint8_t Status,
                                                              uint16_t Connection_Handle,
                                                              uint16_t Service_data,
                                                              uint16_t Sync_Handle,
                                                              uint8_t Advertising_SID,
                                                              uint8_t Advertiser_Address_Type,
                                                              uint8_t Advertiser_Address[6],
                                                              uint8_t Advertiser_PHY,
                                                              uint16_t Periodic_Advertising_Interval,
                                                              uint8_t Advertiser_Clock_Accuracy)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_periodic_advertising_sync_transfer_received_event_rp0 *rp0 = (hci_le_periodic_advertising_sync_transfer_received_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Service_data = Service_data;
  rp0->Sync_Handle = Sync_Handle;
  rp0->Advertising_SID = Advertising_SID;
  rp0->Advertiser_Address_Type = Advertiser_Address_Type;
  Osal_MemCpy((void *) rp0->Advertiser_Address,(const void *) Advertiser_Address, 6);
  rp0->Advertiser_PHY = Advertiser_PHY;
  rp0->Periodic_Advertising_Interval = Periodic_Advertising_Interval;
  rp0->Advertiser_Clock_Accuracy = Advertiser_Clock_Accuracy;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 2 + 2 + 1 + 1 + 6 + 1 + 2 + 1 + 1;
  buffer_out[3] = 0x18;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_path_loss_threshold_event */
/* Event len: 2 + 1 + 1 */
/**
 * @brief Report a path loss threshold crossing on the ACL connection identified
 *        by the Connection_Handle parameter.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Current_Path_Loss Current path loss (always zero or positive). Units:
 *        dB.
 *        Values:
 *        - 0 ... 254
 *        - 255: NA
 * @param Zone_Entered The Zone_Entered parameter indicates which zone was
 *        entered.
 *        Values:
 *        - 0x00: LOW_ZONE
 *        - 0x01: MIDDLE_ZONE
 *        - 0x02: HIGH_ZONE
 * @retval None
 */
void hci_le_path_loss_threshold_event(uint16_t Connection_Handle,
                                      uint8_t Current_Path_Loss,
                                      uint8_t Zone_Entered)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_path_loss_threshold_event_rp0 *rp0 = (hci_le_path_loss_threshold_event_rp0 *) (buffer_out + 4);
  rp0->Connection_Handle = Connection_Handle;
  rp0->Current_Path_Loss = Current_Path_Loss;
  rp0->Zone_Entered = Zone_Entered;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 2 + 1 + 1 + 1;
  buffer_out[3] = 0x20;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

/* hci_le_transmit_power_reporting_event */
/* Event len: 1 + 2 + 1 + 1 + 1 + 1 + 1 */
/**
 * @brief Report the transmit power level on the ACL connection identified by
 *        the Connection_Handle parameter.
 * @param Status For standard error codes see Bluetooth specification, Vol. 2,
 *        part D. For proprietary error code refer to Error codes section.
 * @param Connection_Handle Connection handle that identifies the connection.
 *        Values:
 *        - 0x0000 ... 0x0EFF
 * @param Reason The reason why the event was sent and the device whose transmit
 *        power level is being reported. - 0x00: Local transmit power changed -
 *        0x01: Remote transmit power changed - 0x02:
 *        HCI_LE_Read_Remote_Transmit_Power_Level command completed
 *        Values:
 *        - 0x00: LOCAL_TX_POWER_CHANGE
 *        - 0x01: REMOTE_TX_POWER_CHANGE
 *        - 0x02: READ_REMOTE_TX_POWER_COMPLETE
 * @param PHY PHY associated with the connection  (not necessarily the currently
 *        used one).
 *        Values:
 *        - 0x01: LE_1M_PHY
 *        - 0x02: LE_2M_PHY
 *        - 0x03: LE_CODED_PHY_S8
 *        - 0x04: LE_CODED_PHY_S2
 * @param Transmit_Power_Level The transmit power level for the PHY (dBm).
 *        Values:
 *        - -127 ... 20
 *        - 126: POWER_NOT_MANAGED
 *        - 127: POWER_NA
 * @param Transmit_Power_Level_Flag It indicates whether the transmit power
 *        level that is being reported has reached its minimum and/or maximum
 *        level. Transmit_Power_Level_Flag shall be ignored if the
 *        Transmit_Power_Level parameter is set to 0x7E or 0x7F.
 *        Flags:
 *        - 0x01: MIN_TX_POWER_BIT
 *        - 0x02: MAX_TX_POWER_BIT
 * @param Delta The Delta parameter is set to the change in power level for the
 *        transmitter being reported, whenever it changes its transmit power
 *        level. Delta shall be ignored if the Transmit_Power_Level parameter is
 *        set to 0x7E.
 *        Values:
 *        - 0 ... 126
 *        - 127: NA
 * @retval None
 */
void hci_le_transmit_power_reporting_event(uint8_t Status,
                                           uint16_t Connection_Handle,
                                           uint8_t Reason,
                                           uint8_t PHY,
                                           int8_t Transmit_Power_Level,
                                           uint8_t Transmit_Power_Level_Flag,
                                           int8_t Delta)
{
  uint8_t buffer_out[258];
  /* Output params */
  hci_le_transmit_power_reporting_event_rp0 *rp0 = (hci_le_transmit_power_reporting_event_rp0 *) (buffer_out + 4);
  rp0->Status = Status;
  rp0->Connection_Handle = Connection_Handle;
  rp0->Reason = Reason;
  rp0->PHY = PHY;
  rp0->Transmit_Power_Level = Transmit_Power_Level;
  rp0->Transmit_Power_Level_Flag = Transmit_Power_Level_Flag;
  rp0->Delta = Delta;
  buffer_out[0] = 0x04;
  buffer_out[1] = 0x3E;
  buffer_out[2] = 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1;
  buffer_out[3] = 0x21;
  send_event(buffer_out, buffer_out[2] + 3, -1);
}

