<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-LP/BlueNRG-LPS Peripherals LL drivers APIs: rf_driver_ll_timer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-LP/BlueNRG-LPS Peripherals LL drivers APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rf_driver_ll_timer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains all the functions prototypes for the TIMER firmware library.  
<a href="#details">More...</a></p>

<p><a href="rf__driver__ll__timer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_i_m_e_r___init_type.html">TIMER_InitType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure definition of TIMER initialization.  <a href="struct_t_i_m_e_r___init_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtimer__calibration__s.html">timer_calibration_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga643e0ac4c675cd7f9da054e79adb7681"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtimer__calibration__s.html">timer_calibration_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___types.html#ga643e0ac4c675cd7f9da054e79adb7681">TIMER_CalibrationType</a></td></tr>
<tr class="separator:ga643e0ac4c675cd7f9da054e79adb7681"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae60780e6f0877614eb0d304405bc0542"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r.html#gae60780e6f0877614eb0d304405bc0542">blue_unit_conversion</a> (uint32_t time, uint32_t period_freq, uint32_t thr)</td></tr>
<tr class="memdesc:gae60780e6f0877614eb0d304405bc0542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate MTU to STU and vice-versa. It is implemented using integer operation.  <a href="group___t_i_m_e_r.html#gae60780e6f0877614eb0d304405bc0542">More...</a><br /></td></tr>
<tr class="separator:gae60780e6f0877614eb0d304405bc0542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3128db178d3e2c131cd6e24954c7917a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga3128db178d3e2c131cd6e24954c7917a">TIMER_Init</a> (<a class="el" href="struct_t_i_m_e_r___init_type.html">TIMER_InitType</a> *TIMER_InitStruct)</td></tr>
<tr class="memdesc:ga3128db178d3e2c131cd6e24954c7917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the TIMER functionality.  <a href="group___t_i_m_e_r___exported___functions.html#ga3128db178d3e2c131cd6e24954c7917a">More...</a><br /></td></tr>
<tr class="separator:ga3128db178d3e2c131cd6e24954c7917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eeba98c495209667ba227aac604702a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga0eeba98c495209667ba227aac604702a">TIMER_Calibrate</a> (void)</td></tr>
<tr class="memdesc:ga0eeba98c495209667ba227aac604702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a low speed clock calibration and store results in the global context. It updates the XTAL startup time and the interpolator configuration. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration. This function is not re-entrant since it updates the context variable storing the system time.  <a href="group___t_i_m_e_r___exported___functions.html#ga0eeba98c495209667ba227aac604702a">More...</a><br /></td></tr>
<tr class="separator:ga0eeba98c495209667ba227aac604702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b629dcf17ba3268f9241e852464af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga25b629dcf17ba3268f9241e852464af2">TIMER_StartCalibration</a> (void)</td></tr>
<tr class="memdesc:ga25b629dcf17ba3268f9241e852464af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the calibration routine.  <a href="group___t_i_m_e_r___exported___functions.html#ga25b629dcf17ba3268f9241e852464af2">More...</a><br /></td></tr>
<tr class="separator:ga25b629dcf17ba3268f9241e852464af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">TIMER_IsCalibrationRunning</a> (void)</td></tr>
<tr class="memdesc:ga4a4c60a6b58d5991769bf761f08d8921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if a calibration is on going. It relies on the value of the interrupt status. Assumption is that no other modules are managing the interrupt status of the calibrator.  <a href="group___t_i_m_e_r___exported___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">More...</a><br /></td></tr>
<tr class="separator:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686818e5306f905db7e9fcab677bf104"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga686818e5306f905db7e9fcab677bf104">TIMER_IsCalibrationDataAvailable</a> (void)</td></tr>
<tr class="memdesc:ga686818e5306f905db7e9fcab677bf104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if new calibration data is available.  <a href="group___t_i_m_e_r___exported___functions.html#ga686818e5306f905db7e9fcab677bf104">More...</a><br /></td></tr>
<tr class="separator:ga686818e5306f905db7e9fcab677bf104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7318640f6f1210ce3404f0820af854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga7c7318640f6f1210ce3404f0820af854">TIMER_ClearCalibrationDataAvailableFlag</a> (void)</td></tr>
<tr class="memdesc:ga7c7318640f6f1210ce3404f0820af854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the calibration data available flag.  <a href="group___t_i_m_e_r___exported___functions.html#ga7c7318640f6f1210ce3404f0820af854">More...</a><br /></td></tr>
<tr class="separator:ga7c7318640f6f1210ce3404f0820af854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">TIMER_UpdateCalibrationData</a> (void)</td></tr>
<tr class="memdesc:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the result of the last calibration in the internal context. It updates the XTAL startup time. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration.  <a href="group___t_i_m_e_r___exported___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">More...</a><br /></td></tr>
<tr class="separator:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">TIMER_SetWakeupTime</a> (uint32_t delay, BOOL allow_sleep)</td></tr>
<tr class="memdesc:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register.  <a href="group___t_i_m_e_r___exported___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">More...</a><br /></td></tr>
<tr class="separator:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb04ea929bd32e73e870e98039c48c94"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gacb04ea929bd32e73e870e98039c48c94">TIMER_SetRadioHostWakeupTime</a> (uint32_t delay, BOOL *share)</td></tr>
<tr class="memdesc:gacb04ea929bd32e73e870e98039c48c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. If is it possible the wakeup timer is programmed too. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register.  <a href="group___t_i_m_e_r___exported___functions.html#gacb04ea929bd32e73e870e98039c48c94">More...</a><br /></td></tr>
<tr class="separator:gacb04ea929bd32e73e870e98039c48c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c67015d28baecc93e56488116eb91ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1c67015d28baecc93e56488116eb91ce">TIMER_GetCurrentCalibrationData</a> (<a class="el" href="group___t_i_m_e_r___exported___types.html#ga643e0ac4c675cd7f9da054e79adb7681">TIMER_CalibrationType</a> *data)</td></tr>
<tr class="memdesc:ga1c67015d28baecc93e56488116eb91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current calibration data.  <a href="group___t_i_m_e_r___exported___functions.html#ga1c67015d28baecc93e56488116eb91ce">More...</a><br /></td></tr>
<tr class="separator:ga1c67015d28baecc93e56488116eb91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574722f7b76274d991499c08529fa124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga574722f7b76274d991499c08529fa124">TIMER_SaveCalibrationInterval</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga574722f7b76274d991499c08529fa124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the calibration interval. This information is used to understand if an absolute time register wrap happens since the device startup configration.  <a href="group___t_i_m_e_r___exported___functions.html#ga574722f7b76274d991499c08529fa124">More...</a><br /></td></tr>
<tr class="separator:ga574722f7b76274d991499c08529fa124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gae4bc7d35d23ca42e36d630eb5afd38a2">TIMER_SysTimeToMachineTime</a> (int32_t time)</td></tr>
<tr class="memdesc:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MTU corresponding to the STU passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#gae4bc7d35d23ca42e36d630eb5afd38a2">More...</a><br /></td></tr>
<tr class="separator:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">TIMER_MachineTimeToSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga624dafba8076c3ceb2800303e75bf9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the STU corresponding to the MTU passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">More...</a><br /></td></tr>
<tr class="separator:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">TIMER_GetFutureSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga2a5d5795a186f997c752faa6e8b521c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">More...</a><br /></td></tr>
<tr class="separator:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4903e54c5a624002bebb0936083bd5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga6d4903e54c5a624002bebb0936083bd5">TIMER_GetCurrentSysTime</a> (void)</td></tr>
<tr class="memdesc:ga6d4903e54c5a624002bebb0936083bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current system time in system time unit (STU). This is a counter that grows since the power up of the system and it never wraps.  <a href="group___t_i_m_e_r___exported___functions.html#ga6d4903e54c5a624002bebb0936083bd5">More...</a><br /></td></tr>
<tr class="separator:ga6d4903e54c5a624002bebb0936083bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1675fc9629b47a676fea2fccd6680e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gade1675fc9629b47a676fea2fccd6680e">TIMER_SetRadioTimerValue</a> (uint32_t timeout, BOOL event_type, BOOL cal_req)</td></tr>
<tr class="memdesc:gade1675fc9629b47a676fea2fccd6680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs either the Wakeup timer or Timer1. Both timers are able to trigger the radio sequencer. Then, they are able to start a transmission or a reception according to the configured radio ram tables. Only the wakeup timer is able to let the device out from sleep. The wakeup timer is programmed if the anolag part has enough time to settle after the wakeup or not. The timeout passed as parameter represents the moment where the first bit must be transmitted or the receive window must be opened. Since the radio needs some time to setup, the final timeout programmed is compensated by certain time intervals according to the kind of operation (Tx or Rx), calibration request and programmed timer. The wakeup offset is compensated automatically by the hardware. The CPU wakes up at timeout minus wakeup_offset. if the wakeup timer is programmed, the BLE event triggers when the absolute time mathches the 28 MSB of the timeout. Otherwise the trigger event occurs considering all 32 bits.  <a href="group___t_i_m_e_r___exported___functions.html#gade1675fc9629b47a676fea2fccd6680e">More...</a><br /></td></tr>
<tr class="separator:gade1675fc9629b47a676fea2fccd6680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88243574d09e3b9d759930296f08d14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga88243574d09e3b9d759930296f08d14c">TIMER_SetRadioCloseTimeout</a> (void)</td></tr>
<tr class="memdesc:ga88243574d09e3b9d759930296f08d14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program the radio timer (a.k.a Timer1) as close as possible. The current time is sampled and increased by two. It means that the timer is going to trigger in a timer interval that goes from one to two machine time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga88243574d09e3b9d759930296f08d14c">More...</a><br /></td></tr>
<tr class="separator:ga88243574d09e3b9d759930296f08d14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">TIMER_GetAnchorPoint</a> (void)</td></tr>
<tr class="memdesc:ga93c87f2f82ef629a0b3665248b7505e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return timer capture register value in STU.  <a href="group___t_i_m_e_r___exported___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">More...</a><br /></td></tr>
<tr class="separator:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">TIMER_ClearRadioTimerValue</a> (void)</td></tr>
<tr class="memdesc:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Wakeup Timer and Timer1.  <a href="group___t_i_m_e_r___exported___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">More...</a><br /></td></tr>
<tr class="separator:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb93a6fc923bc6f2194494e1a679f452"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gafb93a6fc923bc6f2194494e1a679f452">TIMER_GetRadioTimerValue</a> (uint32_t *time)</td></tr>
<tr class="memdesc:gafb93a6fc923bc6f2194494e1a679f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the Radio timers and the last value programmed in the register.  <a href="group___t_i_m_e_r___exported___functions.html#gafb93a6fc923bc6f2194494e1a679f452">More...</a><br /></td></tr>
<tr class="separator:gafb93a6fc923bc6f2194494e1a679f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21717c03ae65000a44c509c5c085f7d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga21717c03ae65000a44c509c5c085f7d1">TIMER_ClearRadioTimer2</a> (void)</td></tr>
<tr class="memdesc:ga21717c03ae65000a44c509c5c085f7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Timer2.  <a href="group___t_i_m_e_r___exported___functions.html#ga21717c03ae65000a44c509c5c085f7d1">More...</a><br /></td></tr>
<tr class="separator:ga21717c03ae65000a44c509c5c085f7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">TIMER_GetPastSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">More...</a><br /></td></tr>
<tr class="separator:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2721cdb6797865137926b3d518d60b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1e2721cdb6797865137926b3d518d60b">TIMER_UsToSystime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1e2721cdb6797865137926b3d518d60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate time in microseconds into sys time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga1e2721cdb6797865137926b3d518d60b">More...</a><br /></td></tr>
<tr class="separator:ga1e2721cdb6797865137926b3d518d60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1606d739c79f37bab156a7dda5e27f69"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1606d739c79f37bab156a7dda5e27f69">TIMER_UsToMachinetime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1606d739c79f37bab156a7dda5e27f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate time in microseconds into machine time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga1606d739c79f37bab156a7dda5e27f69">More...</a><br /></td></tr>
<tr class="separator:ga1606d739c79f37bab156a7dda5e27f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4ee819594e0e6369ae440d44a27765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga5a4ee819594e0e6369ae440d44a27765">TIMER_Enable_CPU_WKUP</a> (void)</td></tr>
<tr class="memdesc:ga5a4ee819594e0e6369ae440d44a27765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CPU wakeup interrupt towards the CPU.  <a href="group___t_i_m_e_r___exported___functions.html#ga5a4ee819594e0e6369ae440d44a27765">More...</a><br /></td></tr>
<tr class="separator:ga5a4ee819594e0e6369ae440d44a27765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3f48e042f8663db271f2d2a88d9d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gaca3f48e042f8663db271f2d2a88d9d01">TIMER_Disable_CPU_WKUP</a> (void)</td></tr>
<tr class="memdesc:gaca3f48e042f8663db271f2d2a88d9d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable CPU wakeup interrupt towards the CPU.  <a href="group___t_i_m_e_r___exported___functions.html#gaca3f48e042f8663db271f2d2a88d9d01">More...</a><br /></td></tr>
<tr class="separator:gaca3f48e042f8663db271f2d2a88d9d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5e8f8f906d6566837d42c15874e33c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gaeb5e8f8f906d6566837d42c15874e33c">__TIMER_GetSysRfSetupTime</a> (void)</td></tr>
<tr class="memdesc:gaeb5e8f8f906d6566837d42c15874e33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last setup time in absolute units needed to the hardware for the last radio operation. Intended to be used only inside the timer module library.  <a href="group___t_i_m_e_r___exported___functions.html#gaeb5e8f8f906d6566837d42c15874e33c">More...</a><br /></td></tr>
<tr class="separator:gaeb5e8f8f906d6566837d42c15874e33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184432cee6c066fcc345e0b45bf9e6a5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga184432cee6c066fcc345e0b45bf9e6a5">TIMER_GetCurrentMachineTime</a> (void)</td></tr>
<tr class="memdesc:ga184432cee6c066fcc345e0b45bf9e6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current absolute time expressed in machine absolute time unit.  <a href="group___t_i_m_e_r___exported___functions.html#ga184432cee6c066fcc345e0b45bf9e6a5">More...</a><br /></td></tr>
<tr class="separator:ga184432cee6c066fcc345e0b45bf9e6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119180df4fe074f8fed8add98baacb25"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga119180df4fe074f8fed8add98baacb25">TIMER_SetHostTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga119180df4fe074f8fed8add98baacb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a host timeout in machine absolute time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga119180df4fe074f8fed8add98baacb25">More...</a><br /></td></tr>
<tr class="separator:ga119180df4fe074f8fed8add98baacb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037f385376f9c660be82470faeefc638"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga037f385376f9c660be82470faeefc638">TIMER_GetHostTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga037f385376f9c660be82470faeefc638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a host timeout in machine absolute time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga037f385376f9c660be82470faeefc638">More...</a><br /></td></tr>
<tr class="separator:ga037f385376f9c660be82470faeefc638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c904988e2391193ee024bda10f1c5a6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga2c904988e2391193ee024bda10f1c5a6">TIMER_SetTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga2c904988e2391193ee024bda10f1c5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a blue controller wakeup time in machine absolute time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga2c904988e2391193ee024bda10f1c5a6">More...</a><br /></td></tr>
<tr class="separator:ga2c904988e2391193ee024bda10f1c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b43ef2d0b20bdc9fd4d78c44cde353"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga77b43ef2d0b20bdc9fd4d78c44cde353">TIMER_GetTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga77b43ef2d0b20bdc9fd4d78c44cde353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a blue controller wakeup time in machine absolute time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga77b43ef2d0b20bdc9fd4d78c44cde353">More...</a><br /></td></tr>
<tr class="separator:ga77b43ef2d0b20bdc9fd4d78c44cde353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains all the functions prototypes for the TIMER firmware library. </p>
<dl class="section author"><dt>Author</dt><dd>RF Application Team </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT 2020 STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="rf__driver__ll__timer_8h_source.html">rf_driver_ll_timer.h</a>.</p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2022 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
