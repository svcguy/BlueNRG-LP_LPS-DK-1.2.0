<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-LP/BlueNRG-LPS Peripherals LL drivers APIs: TIMER Exported Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-LP/BlueNRG-LPS Peripherals LL drivers APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TIMER Exported Functions<div class="ingroups"><a class="el" href="group___r_f___d_r_i_v_e_r___l_l___driver.html">RF_DRIVER_LL_Driver</a> &raquo; <a class="el" href="group___t_i_m_e_r.html">TIMER</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3128db178d3e2c131cd6e24954c7917a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga3128db178d3e2c131cd6e24954c7917a">TIMER_Init</a> (<a class="el" href="struct_t_i_m_e_r___init_type.html">TIMER_InitType</a> *TIMER_InitStruct)</td></tr>
<tr class="memdesc:ga3128db178d3e2c131cd6e24954c7917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the TIMER functionality.  <a href="#ga3128db178d3e2c131cd6e24954c7917a">More...</a><br /></td></tr>
<tr class="separator:ga3128db178d3e2c131cd6e24954c7917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eeba98c495209667ba227aac604702a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga0eeba98c495209667ba227aac604702a">TIMER_Calibrate</a> (void)</td></tr>
<tr class="memdesc:ga0eeba98c495209667ba227aac604702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a low speed clock calibration and store results in the global context. It updates the XTAL startup time and the interpolator configuration. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration. This function is not re-entrant since it updates the context variable storing the system time.  <a href="#ga0eeba98c495209667ba227aac604702a">More...</a><br /></td></tr>
<tr class="separator:ga0eeba98c495209667ba227aac604702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b629dcf17ba3268f9241e852464af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga25b629dcf17ba3268f9241e852464af2">TIMER_StartCalibration</a> (void)</td></tr>
<tr class="memdesc:ga25b629dcf17ba3268f9241e852464af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the calibration routine.  <a href="#ga25b629dcf17ba3268f9241e852464af2">More...</a><br /></td></tr>
<tr class="separator:ga25b629dcf17ba3268f9241e852464af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">TIMER_IsCalibrationRunning</a> (void)</td></tr>
<tr class="memdesc:ga4a4c60a6b58d5991769bf761f08d8921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if a calibration is on going. It relies on the value of the interrupt status. Assumption is that no other modules are managing the interrupt status of the calibrator.  <a href="#ga4a4c60a6b58d5991769bf761f08d8921">More...</a><br /></td></tr>
<tr class="separator:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686818e5306f905db7e9fcab677bf104"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga686818e5306f905db7e9fcab677bf104">TIMER_IsCalibrationDataAvailable</a> (void)</td></tr>
<tr class="memdesc:ga686818e5306f905db7e9fcab677bf104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if new calibration data is available.  <a href="#ga686818e5306f905db7e9fcab677bf104">More...</a><br /></td></tr>
<tr class="separator:ga686818e5306f905db7e9fcab677bf104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7318640f6f1210ce3404f0820af854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga7c7318640f6f1210ce3404f0820af854">TIMER_ClearCalibrationDataAvailableFlag</a> (void)</td></tr>
<tr class="memdesc:ga7c7318640f6f1210ce3404f0820af854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the calibration data available flag.  <a href="#ga7c7318640f6f1210ce3404f0820af854">More...</a><br /></td></tr>
<tr class="separator:ga7c7318640f6f1210ce3404f0820af854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">TIMER_UpdateCalibrationData</a> (void)</td></tr>
<tr class="memdesc:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the result of the last calibration in the internal context. It updates the XTAL startup time. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration.  <a href="#ga526ecb65c6e3da467c9e2b75b3aa2be0">More...</a><br /></td></tr>
<tr class="separator:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">TIMER_SetWakeupTime</a> (uint32_t delay, BOOL allow_sleep)</td></tr>
<tr class="memdesc:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register.  <a href="#ga98d9ad2d334495f69f3c9920dd9576c5">More...</a><br /></td></tr>
<tr class="separator:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb04ea929bd32e73e870e98039c48c94"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gacb04ea929bd32e73e870e98039c48c94">TIMER_SetRadioHostWakeupTime</a> (uint32_t delay, BOOL *share)</td></tr>
<tr class="memdesc:gacb04ea929bd32e73e870e98039c48c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. If is it possible the wakeup timer is programmed too. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register.  <a href="#gacb04ea929bd32e73e870e98039c48c94">More...</a><br /></td></tr>
<tr class="separator:gacb04ea929bd32e73e870e98039c48c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c67015d28baecc93e56488116eb91ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1c67015d28baecc93e56488116eb91ce">TIMER_GetCurrentCalibrationData</a> (<a class="el" href="group___t_i_m_e_r___exported___types.html#ga643e0ac4c675cd7f9da054e79adb7681">TIMER_CalibrationType</a> *data)</td></tr>
<tr class="memdesc:ga1c67015d28baecc93e56488116eb91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current calibration data.  <a href="#ga1c67015d28baecc93e56488116eb91ce">More...</a><br /></td></tr>
<tr class="separator:ga1c67015d28baecc93e56488116eb91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574722f7b76274d991499c08529fa124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga574722f7b76274d991499c08529fa124">TIMER_SaveCalibrationInterval</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga574722f7b76274d991499c08529fa124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the calibration interval. This information is used to understand if an absolute time register wrap happens since the device startup configration.  <a href="#ga574722f7b76274d991499c08529fa124">More...</a><br /></td></tr>
<tr class="separator:ga574722f7b76274d991499c08529fa124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gae4bc7d35d23ca42e36d630eb5afd38a2">TIMER_SysTimeToMachineTime</a> (int32_t time)</td></tr>
<tr class="memdesc:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MTU corresponding to the STU passed as parameter.  <a href="#gae4bc7d35d23ca42e36d630eb5afd38a2">More...</a><br /></td></tr>
<tr class="separator:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">TIMER_MachineTimeToSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga624dafba8076c3ceb2800303e75bf9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the STU corresponding to the MTU passed as parameter.  <a href="#ga624dafba8076c3ceb2800303e75bf9c2">More...</a><br /></td></tr>
<tr class="separator:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">TIMER_GetFutureSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga2a5d5795a186f997c752faa6e8b521c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="#ga2a5d5795a186f997c752faa6e8b521c0">More...</a><br /></td></tr>
<tr class="separator:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4903e54c5a624002bebb0936083bd5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga6d4903e54c5a624002bebb0936083bd5">TIMER_GetCurrentSysTime</a> (void)</td></tr>
<tr class="memdesc:ga6d4903e54c5a624002bebb0936083bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current system time in system time unit (STU). This is a counter that grows since the power up of the system and it never wraps.  <a href="#ga6d4903e54c5a624002bebb0936083bd5">More...</a><br /></td></tr>
<tr class="separator:ga6d4903e54c5a624002bebb0936083bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1675fc9629b47a676fea2fccd6680e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gade1675fc9629b47a676fea2fccd6680e">TIMER_SetRadioTimerValue</a> (uint32_t timeout, BOOL event_type, BOOL cal_req)</td></tr>
<tr class="memdesc:gade1675fc9629b47a676fea2fccd6680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs either the Wakeup timer or Timer1. Both timers are able to trigger the radio sequencer. Then, they are able to start a transmission or a reception according to the configured radio ram tables. Only the wakeup timer is able to let the device out from sleep. The wakeup timer is programmed if the anolag part has enough time to settle after the wakeup or not. The timeout passed as parameter represents the moment where the first bit must be transmitted or the receive window must be opened. Since the radio needs some time to setup, the final timeout programmed is compensated by certain time intervals according to the kind of operation (Tx or Rx), calibration request and programmed timer. The wakeup offset is compensated automatically by the hardware. The CPU wakes up at timeout minus wakeup_offset. if the wakeup timer is programmed, the BLE event triggers when the absolute time mathches the 28 MSB of the timeout. Otherwise the trigger event occurs considering all 32 bits.  <a href="#gade1675fc9629b47a676fea2fccd6680e">More...</a><br /></td></tr>
<tr class="separator:gade1675fc9629b47a676fea2fccd6680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88243574d09e3b9d759930296f08d14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga88243574d09e3b9d759930296f08d14c">TIMER_SetRadioCloseTimeout</a> (void)</td></tr>
<tr class="memdesc:ga88243574d09e3b9d759930296f08d14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program the radio timer (a.k.a Timer1) as close as possible. The current time is sampled and increased by two. It means that the timer is going to trigger in a timer interval that goes from one to two machine time units.  <a href="#ga88243574d09e3b9d759930296f08d14c">More...</a><br /></td></tr>
<tr class="separator:ga88243574d09e3b9d759930296f08d14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">TIMER_GetAnchorPoint</a> (void)</td></tr>
<tr class="memdesc:ga93c87f2f82ef629a0b3665248b7505e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return timer capture register value in STU.  <a href="#ga93c87f2f82ef629a0b3665248b7505e3">More...</a><br /></td></tr>
<tr class="separator:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">TIMER_ClearRadioTimerValue</a> (void)</td></tr>
<tr class="memdesc:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Wakeup Timer and Timer1.  <a href="#ga59559fc0d99df367a45a91adb9bbb8cd">More...</a><br /></td></tr>
<tr class="separator:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb93a6fc923bc6f2194494e1a679f452"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gafb93a6fc923bc6f2194494e1a679f452">TIMER_GetRadioTimerValue</a> (uint32_t *time)</td></tr>
<tr class="memdesc:gafb93a6fc923bc6f2194494e1a679f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the Radio timers and the last value programmed in the register.  <a href="#gafb93a6fc923bc6f2194494e1a679f452">More...</a><br /></td></tr>
<tr class="separator:gafb93a6fc923bc6f2194494e1a679f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21717c03ae65000a44c509c5c085f7d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga21717c03ae65000a44c509c5c085f7d1">TIMER_ClearRadioTimer2</a> (void)</td></tr>
<tr class="memdesc:ga21717c03ae65000a44c509c5c085f7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Timer2.  <a href="#ga21717c03ae65000a44c509c5c085f7d1">More...</a><br /></td></tr>
<tr class="separator:ga21717c03ae65000a44c509c5c085f7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">TIMER_GetPastSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="#ga9605ce8f587241f028de3a4aa8a11a1c">More...</a><br /></td></tr>
<tr class="separator:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2721cdb6797865137926b3d518d60b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1e2721cdb6797865137926b3d518d60b">TIMER_UsToSystime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1e2721cdb6797865137926b3d518d60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate time in microseconds into sys time units.  <a href="#ga1e2721cdb6797865137926b3d518d60b">More...</a><br /></td></tr>
<tr class="separator:ga1e2721cdb6797865137926b3d518d60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1606d739c79f37bab156a7dda5e27f69"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1606d739c79f37bab156a7dda5e27f69">TIMER_UsToMachinetime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1606d739c79f37bab156a7dda5e27f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate time in microseconds into machine time units.  <a href="#ga1606d739c79f37bab156a7dda5e27f69">More...</a><br /></td></tr>
<tr class="separator:ga1606d739c79f37bab156a7dda5e27f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4ee819594e0e6369ae440d44a27765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga5a4ee819594e0e6369ae440d44a27765">TIMER_Enable_CPU_WKUP</a> (void)</td></tr>
<tr class="memdesc:ga5a4ee819594e0e6369ae440d44a27765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CPU wakeup interrupt towards the CPU.  <a href="#ga5a4ee819594e0e6369ae440d44a27765">More...</a><br /></td></tr>
<tr class="separator:ga5a4ee819594e0e6369ae440d44a27765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3f48e042f8663db271f2d2a88d9d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gaca3f48e042f8663db271f2d2a88d9d01">TIMER_Disable_CPU_WKUP</a> (void)</td></tr>
<tr class="memdesc:gaca3f48e042f8663db271f2d2a88d9d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable CPU wakeup interrupt towards the CPU.  <a href="#gaca3f48e042f8663db271f2d2a88d9d01">More...</a><br /></td></tr>
<tr class="separator:gaca3f48e042f8663db271f2d2a88d9d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5e8f8f906d6566837d42c15874e33c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gaeb5e8f8f906d6566837d42c15874e33c">__TIMER_GetSysRfSetupTime</a> (void)</td></tr>
<tr class="memdesc:gaeb5e8f8f906d6566837d42c15874e33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last setup time in absolute units needed to the hardware for the last radio operation. Intended to be used only inside the timer module library.  <a href="#gaeb5e8f8f906d6566837d42c15874e33c">More...</a><br /></td></tr>
<tr class="separator:gaeb5e8f8f906d6566837d42c15874e33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184432cee6c066fcc345e0b45bf9e6a5"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga184432cee6c066fcc345e0b45bf9e6a5">TIMER_GetCurrentMachineTime</a> (void)</td></tr>
<tr class="memdesc:ga184432cee6c066fcc345e0b45bf9e6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current absolute time expressed in machine absolute time unit.  <a href="#ga184432cee6c066fcc345e0b45bf9e6a5">More...</a><br /></td></tr>
<tr class="separator:ga184432cee6c066fcc345e0b45bf9e6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119180df4fe074f8fed8add98baacb25"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga119180df4fe074f8fed8add98baacb25">TIMER_SetHostTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga119180df4fe074f8fed8add98baacb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a host timeout in machine absolute time units.  <a href="#ga119180df4fe074f8fed8add98baacb25">More...</a><br /></td></tr>
<tr class="separator:ga119180df4fe074f8fed8add98baacb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037f385376f9c660be82470faeefc638"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga037f385376f9c660be82470faeefc638">TIMER_GetHostTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga037f385376f9c660be82470faeefc638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a host timeout in machine absolute time units.  <a href="#ga037f385376f9c660be82470faeefc638">More...</a><br /></td></tr>
<tr class="separator:ga037f385376f9c660be82470faeefc638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c904988e2391193ee024bda10f1c5a6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga2c904988e2391193ee024bda10f1c5a6">TIMER_SetTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga2c904988e2391193ee024bda10f1c5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a blue controller wakeup time in machine absolute time units.  <a href="#ga2c904988e2391193ee024bda10f1c5a6">More...</a><br /></td></tr>
<tr class="separator:ga2c904988e2391193ee024bda10f1c5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b43ef2d0b20bdc9fd4d78c44cde353"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga77b43ef2d0b20bdc9fd4d78c44cde353">TIMER_GetTimeoutReg</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga77b43ef2d0b20bdc9fd4d78c44cde353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a blue controller wakeup time in machine absolute time units.  <a href="#ga77b43ef2d0b20bdc9fd4d78c44cde353">More...</a><br /></td></tr>
<tr class="separator:ga77b43ef2d0b20bdc9fd4d78c44cde353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaeb5e8f8f906d6566837d42c15874e33c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t __TIMER_GetSysRfSetupTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last setup time in absolute units needed to the hardware for the last radio operation. Intended to be used only inside the timer module library. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00587">587</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0eeba98c495209667ba227aac604702a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_Calibrate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a low speed clock calibration and store results in the global context. It updates the XTAL startup time and the interpolator configuration. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration. This function is not re-entrant since it updates the context variable storing the system time. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00353">353</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c7318640f6f1210ce3404f0820af854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_ClearCalibrationDataAvailableFlag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the calibration data available flag. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00421">421</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga21717c03ae65000a44c509c5c085f7d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_ClearRadioTimer2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Timer2. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00533">533</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga59559fc0d99df367a45a91adb9bbb8cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_ClearRadioTimerValue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Wakeup Timer and Timer1. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00544">544</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaca3f48e042f8663db271f2d2a88d9d01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_Disable_CPU_WKUP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable CPU wakeup interrupt towards the CPU. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00782">782</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a4ee819594e0e6369ae440d44a27765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_Enable_CPU_WKUP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable CPU wakeup interrupt towards the CPU. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00772">772</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga93c87f2f82ef629a0b3665248b7505e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t TIMER_GetAnchorPoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return timer capture register value in STU. </p>
<dl class="section return"><dt>Returns</dt><dd>STU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00793">793</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c67015d28baecc93e56488116eb91ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_GetCurrentCalibrationData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_i_m_e_r___exported___types.html#ga643e0ac4c675cd7f9da054e79adb7681">TIMER_CalibrationType</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current calibration data. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00507">507</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga184432cee6c066fcc345e0b45bf9e6a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t TIMER_GetCurrentMachineTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current absolute time expressed in machine absolute time unit. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8h_source.html#l00395">395</a> of file <a class="el" href="rf__driver__ll__timer_8h_source.html">rf_driver_ll_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d4903e54c5a624002bebb0936083bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t TIMER_GetCurrentSysTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current system time in system time unit (STU). This is a counter that grows since the power up of the system and it never wraps. </p>
<dl class="section return"><dt>Returns</dt><dd>Current system time </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00472">472</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a5d5795a186f997c752faa6e8b521c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t TIMER_GetFutureSysTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the system time referred to the absolute machine time passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Absolute machine time in the future </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>User should guarantee that call to this function are performed in a non-interruptible context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>STU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00483">483</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga037f385376f9c660be82470faeefc638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t TIMER_GetHostTimeoutReg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a host timeout in machine absolute time units. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8h_source.html#l00405">405</a> of file <a class="el" href="rf__driver__ll__timer_8h_source.html">rf_driver_ll_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9605ce8f587241f028de3a4aa8a11a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t TIMER_GetPastSysTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the system time referred to the absolute machine time passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Absolute machine time in the past </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>User should guarantee that call to this function are performed in a non-interruptible context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>STU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00495">495</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafb93a6fc923bc6f2194494e1a679f452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TIMER_GetRadioTimerValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the Radio timers and the last value programmed in the register. </p>
<dl class="section note"><dt>Note</dt><dd>When Timer2 is on schedule, the time is expressed in microseconds, otherwise in absolute machine time units. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>pointer to value which is going to have time value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no timer has been programmed. </td></tr>
    <tr><td class="paramname">1</td><td>if Timer1 has been programmed. </td></tr>
    <tr><td class="paramname">2</td><td>if Timer2 has been programmed. </td></tr>
    <tr><td class="paramname">3</td><td>if Wakeup Timer has been programmed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00560">560</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga77b43ef2d0b20bdc9fd4d78c44cde353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t TIMER_GetTimeoutReg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a blue controller wakeup time in machine absolute time units. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8h_source.html#l00415">415</a> of file <a class="el" href="rf__driver__ll__timer_8h_source.html">rf_driver_ll_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3128db178d3e2c131cd6e24954c7917a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_i_m_e_r___init_type.html">TIMER_InitType</a> *&#160;</td>
          <td class="paramname"><em>TIMER_InitStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the TIMER functionality. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00301">301</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga686818e5306f905db7e9fcab677bf104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL TIMER_IsCalibrationDataAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if new calibration data is available. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if calibration data is available, FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Call the () API to clear the avaliability flag after the data read. </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00412">412</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a4c60a6b58d5991769bf761f08d8921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL TIMER_IsCalibrationRunning </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if a calibration is on going. It relies on the value of the interrupt status. Assumption is that no other modules are managing the interrupt status of the calibrator. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if calibration is running, FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00400">400</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga624dafba8076c3ceb2800303e75bf9c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_MachineTimeToSysTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the STU corresponding to the MTU passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>MTU amount to be converted in STU </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant since it updates the context variable storing the system time. It should be called only in user context and not in interrupt context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>STU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00817">817</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga574722f7b76274d991499c08529fa124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_SaveCalibrationInterval </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the calibration interval. This information is used to understand if an absolute time register wrap happens since the device startup configration. </p>
<p>Records the calibration interval. This information is used to understand if a absolute time wrap register happens since the device startup configration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Calibration interval (STU) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant since it updates the context variable storing the system time. It should be called only in user context and not in interrupt context. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00524">524</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga119180df4fe074f8fed8add98baacb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void TIMER_SetHostTimeoutReg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a host timeout in machine absolute time units. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8h_source.html#l00400">400</a> of file <a class="el" href="rf__driver__ll__timer_8h_source.html">rf_driver_ll_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga88243574d09e3b9d759930296f08d14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_SetRadioCloseTimeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program the radio timer (a.k.a Timer1) as close as possible. The current time is sampled and increased by two. It means that the timer is going to trigger in a timer interval that goes from one to two machine time units. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00761">761</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacb04ea929bd32e73e870e98039c48c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_SetRadioHostWakeupTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL *&#160;</td>
          <td class="paramname"><em>share</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. If is it possible the wakeup timer is programmed too. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Delay from the current time expressed in system time unit (STU). Range is 0 to maximum value of STU. The maximum value STU is dependent on the speed of the low speed oscillator. A value too small will force the timer to wrap, so it is reccommended to use at least 5-10 STU. </td></tr>
    <tr><td class="paramname">share</td><td>flag that indicates if the wakeup timer has to be programmed too. if other code commands the system to go to deep sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should be called with interrupts disabled to avoid programming the timer with a value in the past. </dd>
<dd>
To be considered only if HOST_WAKEUP_FIX_ENABLE is 1. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current time in MTU. </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00634">634</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gade1675fc9629b47a676fea2fccd6680e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t TIMER_SetRadioTimerValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>event_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>cal_req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs either the Wakeup timer or Timer1. Both timers are able to trigger the radio sequencer. Then, they are able to start a transmission or a reception according to the configured radio ram tables. Only the wakeup timer is able to let the device out from sleep. The wakeup timer is programmed if the anolag part has enough time to settle after the wakeup or not. The timeout passed as parameter represents the moment where the first bit must be transmitted or the receive window must be opened. Since the radio needs some time to setup, the final timeout programmed is compensated by certain time intervals according to the kind of operation (Tx or Rx), calibration request and programmed timer. The wakeup offset is compensated automatically by the hardware. The CPU wakes up at timeout minus wakeup_offset. if the wakeup timer is programmed, the BLE event triggers when the absolute time mathches the 28 MSB of the timeout. Otherwise the trigger event occurs considering all 32 bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>absolute starting time of the desired operation expressed in STU. If this absolute time is less then the current time, the timer will wrap. The maximum value STU is dependent on the speed of the low speed oscillator. </td></tr>
    <tr><td class="paramname">event_type</td><td>1 Tx event. 0 Rx event </td></tr>
    <tr><td class="paramname">cal_req</td><td>1 PLL calibartion is requested. 0 PLL calibartion is not requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should be called with interrupts disabled to avoid programming the timer with a value in the past </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if a correct timeout has been programmed in the timeout register </td></tr>
    <tr><td class="paramname">1</td><td>if a correct timeout cannot be programmed</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>absolute starting time of the desired operation expressed in STU. If this absolute time is less then the current time, the timer will wrap. The maximum value STU is dependent on the speed of the low speed oscillator. </td></tr>
    <tr><td class="paramname">event_type</td><td>1 Tx event. 0 Rx event </td></tr>
    <tr><td class="paramname">cal_req</td><td>1 pll calibration is requested. 0 pll calibration is not requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should be called with interrupts disabled to avoid programming the timer with a value in the past </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if a correct timeout has been programmed in the timeout register </td></tr>
    <tr><td class="paramname">1</td><td>if a correct timeout cannot be programmed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00683">683</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c904988e2391193ee024bda10f1c5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void TIMER_SetTimeoutReg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a blue controller wakeup time in machine absolute time units. </p>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8h_source.html#l00410">410</a> of file <a class="el" href="rf__driver__ll__timer_8h_source.html">rf_driver_ll_timer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga98d9ad2d334495f69f3c9920dd9576c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_SetWakeupTime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>allow_sleep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Delay from the current time expressed in system time unit (STU). Range is 0 to maximum value of STU. The maximum value STU is dependent on the speed of the low speed oscillator. A value too small will force the timer to wrap, so it is reccommended to use at least 5-10 STU. </td></tr>
    <tr><td class="paramname">allow_sleep</td><td>Setting it to zero will prevent hardware to go to deep sleep, if other code commands the system to go to deep sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should be called with interrupts disabled to avoid programming the timer with a value in the past </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current time in MTU. </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00605">605</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga25b629dcf17ba3268f9241e852464af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_StartCalibration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the calibration routine. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00388">388</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae4bc7d35d23ca42e36d630eb5afd38a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_SysTimeToMachineTime </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the MTU corresponding to the STU passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>STU amount to be converted in MTU </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant since it updates the context variable storing the system time. It should be called only in user context and not in interrupt context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>MTU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00805">805</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga526ecb65c6e3da467c9e2b75b3aa2be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TIMER_UpdateCalibrationData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records the result of the last calibration in the internal context. It updates the XTAL startup time. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not re-entrant since it updates the context variable storing the system time. It should be called only in user context and not in interrupt context. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00435">435</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1606d739c79f37bab156a7dda5e27f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_UsToMachinetime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate time in microseconds into machine time units. </p>
<dl class="section return"><dt>Returns</dt><dd>STU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00835">835</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e2721cdb6797865137926b3d518d60b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t TIMER_UsToSystime </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate time in microseconds into sys time units. </p>
<dl class="section return"><dt>Returns</dt><dd>STU value </dd></dl>

<p>Definition at line <a class="el" href="rf__driver__ll__timer_8c_source.html#l00826">826</a> of file <a class="el" href="rf__driver__ll__timer_8c_source.html">rf_driver_ll_timer.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2022 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
