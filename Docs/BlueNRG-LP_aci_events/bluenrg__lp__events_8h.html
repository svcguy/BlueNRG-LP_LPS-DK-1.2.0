<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-BLE Stack Library APIs, events callbacks &amp; application framework: C:/GIT_vobs/bluenrglp-sdk/Middlewares/ST/Bluetooth_LE/inc/bluenrg_lp_events.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="STcustom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-BLE Stack Library APIs, events callbacks &amp; application framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0ef013aab68a7502f6b7c1d484d85bd6.html">Middlewares</a></li><li class="navelem"><a class="el" href="dir_1ad7b503f206431c444b3d2f6d492083.html">ST</a></li><li class="navelem"><a class="el" href="dir_da75705656b56beda367ff7728100b5b.html">Bluetooth_LE</a></li><li class="navelem"><a class="el" href="dir_37922c7fc6613c18028bb58b4708e6cf.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg_lp_events.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for Bluetooth Low Energy stack events callbacks Autogenerated files, do not edit!!  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ble__status_8h_source.html">ble_status.h</a>&quot;</code><br />
</div>
<p><a href="bluenrg__lp__events_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_handle___packets___pair___entry__t__s.html">Handle_Packets_Pair_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_advertising___report__t__s.html">Advertising_Report_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_direct___advertising___report__t__s.html">Direct_Advertising_Report_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_extended___advertising___report__t__s.html">Extended_Advertising_Report_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_samples__t__s.html">Samples_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_attribute___group___handle___pair__t__s.html">Attribute_Group_Handle_Pair_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga19e315b18dca48a4c6549df0a22aa83e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_handle___packets___pair___entry__t__s.html">Handle_Packets_Pair_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga19e315b18dca48a4c6549df0a22aa83e">Handle_Packets_Pair_Entry_t</a></td></tr>
<tr class="separator:ga19e315b18dca48a4c6549df0a22aa83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bbd1aa8e2e33caa47ef92ab59a6dca"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_advertising___report__t__s.html">Advertising_Report_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gae9bbd1aa8e2e33caa47ef92ab59a6dca">Advertising_Report_t</a></td></tr>
<tr class="separator:gae9bbd1aa8e2e33caa47ef92ab59a6dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b54c0dfdf31f5f75e72b68f0ce120f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_direct___advertising___report__t__s.html">Direct_Advertising_Report_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gae2b54c0dfdf31f5f75e72b68f0ce120f">Direct_Advertising_Report_t</a></td></tr>
<tr class="separator:gae2b54c0dfdf31f5f75e72b68f0ce120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd5664780a21b6c57c50c4d121bfa6c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_extended___advertising___report__t__s.html">Extended_Advertising_Report_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga4fd5664780a21b6c57c50c4d121bfa6c">Extended_Advertising_Report_t</a></td></tr>
<tr class="separator:ga4fd5664780a21b6c57c50c4d121bfa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7cf2514b3bacd2b5c4f75e28a324168"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_samples__t__s.html">Samples_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gac7cf2514b3bacd2b5c4f75e28a324168">Samples_t</a></td></tr>
<tr class="separator:gac7cf2514b3bacd2b5c4f75e28a324168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa18cda6ab01e75304a6d81ceec854c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_attribute___group___handle___pair__t__s.html">Attribute_Group_Handle_Pair_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9aa18cda6ab01e75304a6d81ceec854c">Attribute_Group_Handle_Pair_t</a></td></tr>
<tr class="separator:ga9aa18cda6ab01e75304a6d81ceec854c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga28dfb4e4d94437eac75340723ba42628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:ga28dfb4e4d94437eac75340723ba42628"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Disconnection Complete event occurs when a connection is terminated. The status parameter indicates if the disconnection was successful or not. The reason parameter indicates the reason for the disconnection if the disconnection was successful. If the disconnection was not successful, the value of the reason parameter can be ignored by the Host. For example, this can be the case if the Host has issued the Disconnect command and there was a parameter error, or the command was not presently allowed, or a Connection_Handle that didn't correspond to a connection was given.  <a href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">More...</a><br /></td></tr>
<tr class="separator:ga28dfb4e4d94437eac75340723ba42628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2c10a0d46f106912bf7637f7b43db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga7d2c10a0d46f106912bf7637f7b43db4">hci_encryption_change_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t Encryption_Enabled)</td></tr>
<tr class="memdesc:ga7d2c10a0d46f106912bf7637f7b43db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Encryption Change event is used to indicate that the change of the encryption mode has been completed. The Connection_Handle will be a Connection_Handle for an ACL connection. The Encryption_Enabled event parameter specifies the new Encryption_Enabled parameter for the Connection_Handle specified by the Connection_Handle event parameter. This event will occur on both devices to notify the Hosts when Encryption has changed for the specified Connection_Handle between two devices. Note: This event shall not be generated if encryption is paused or resumed; during a role switch, for example. The meaning of the Encryption_Enabled parameter depends on whether the Host has indicated support for Secure Connections in the Secure_Connections_Host_Support parameter. When Secure_Connections_Host_Support is 'disabled' or the Connection_Handle refers to an LE link, the Controller shall only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.8)  <a href="group___h_c_i__events.html#ga7d2c10a0d46f106912bf7637f7b43db4">More...</a><br /></td></tr>
<tr class="separator:ga7d2c10a0d46f106912bf7637f7b43db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b5d3d15561367deb624e8a8c5369b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#gaf7b5d3d15561367deb624e8a8c5369b0">hci_read_remote_version_information_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t Version, uint16_t Manufacturer_Name, uint16_t Subversion)</td></tr>
<tr class="memdesc:gaf7b5d3d15561367deb624e8a8c5369b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Read Remote Version Information Complete event is used to indicate the completion of the process obtaining the version information of the remote Controller specified by the Connection_Handle event parameter. The Connection_Handle shall be for an ACL connection. The Version event parameter defines the specification version of the LE Controller. The Manufacturer_Name event parameter indicates the manufacturer of the remote Controller. The Subversion event parameter is controlled by the manufacturer and is implementation dependent. The Subversion event parameter defines the various revisions that each version of the Bluetooth hardware will go through as design processes change and errors are fixed. This allows the software to determine what Bluetooth hardware is being used and, if necessary, to work around various bugs in the hardware. When the Connection_Handle is associated with an LE-U logical link, the Version event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name event parameter shall be the CompId parameter, and the Subversion event parameter shall be the SubVersNr parameter. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12)  <a href="group___h_c_i__events.html#gaf7b5d3d15561367deb624e8a8c5369b0">More...</a><br /></td></tr>
<tr class="separator:gaf7b5d3d15561367deb624e8a8c5369b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece7033575eb4f06316516d9a761c2cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#gaece7033575eb4f06316516d9a761c2cb">hci_hardware_error_event</a> (uint8_t Hardware_Code)</td></tr>
<tr class="memdesc:gaece7033575eb4f06316516d9a761c2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller.  <a href="group___h_c_i__events.html#gaece7033575eb4f06316516d9a761c2cb">More...</a><br /></td></tr>
<tr class="separator:gaece7033575eb4f06316516d9a761c2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831aece8182f0f129cfba5ad245247a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga831aece8182f0f129cfba5ad245247a6">hci_number_of_completed_packets_event</a> (uint8_t Number_of_Handles, <a class="el" href="group___h_c_i__events.html#ga19e315b18dca48a4c6549df0a22aa83e">Handle_Packets_Pair_Entry_t</a> Handle_Packets_Pair_Entry[])</td></tr>
<tr class="memdesc:ga831aece8182f0f129cfba5ad245247a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Number Of Completed Packets event is used by the Controller to indicate to the Host how many HCI Data Packets have been completed (transmitted or flushed) for each Connection_Handle since the previous Number Of Completed Packets event was sent to the Host. This means that the corresponding buffer space has been freed in the Controller. Based on this information, and the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_- Data_Packets return parameter of the Read_Buffer_Size command, the Host can determine for which Connection_Handles the following HCI Data Packets should be sent to the Controller. The Number Of Completed Packets event must not be sent before the corresponding Connection Complete event. While the Controller has HCI data packets in its buffer, it must keep sending the Number Of Completed Packets event to the Host at least periodically, until it finally reports that all the pending ACL Data Packets have been transmitted or flushed.  <a href="group___h_c_i__events.html#ga831aece8182f0f129cfba5ad245247a6">More...</a><br /></td></tr>
<tr class="separator:ga831aece8182f0f129cfba5ad245247a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcdab4a606f1de376d8ef366add985e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#gabcdab4a606f1de376d8ef366add985e0">hci_data_buffer_overflow_event</a> (uint8_t Link_Type)</td></tr>
<tr class="memdesc:gabcdab4a606f1de376d8ef366add985e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">'This event is used to indicate that the Controller's data buffers have been overflowed. This can occur if the Host has sent more packets than allowed. The Link_Type parameter is used to indicate that the overflow was caused by ACL data.  <a href="group___h_c_i__events.html#gabcdab4a606f1de376d8ef366add985e0">More...</a><br /></td></tr>
<tr class="separator:gabcdab4a606f1de376d8ef366add985e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7454ce305b0487d94be8194b1bde4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga5a7454ce305b0487d94be8194b1bde4d">hci_encryption_key_refresh_complete_event</a> (uint8_t Status, uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga5a7454ce305b0487d94be8194b1bde4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">'The Encryption Key Refresh Complete event is used to indicate to the Host that the encryption key was refreshed on the given Connection_Handle any time encryption is paused and then resumed. If the Encryption Key Refresh Complete event was generated due to an encryption pause and resume operation embedded within a change connection link key procedure, the Encryption Key Refresh Complete event shall be sent prior to the Change Connection Link Key Complete event. If the Encryption Key Refresh Complete event was generated due to an encryption pause and resume operation embedded within a role switch procedure, the Encryption Key Refresh Complete event shall be sent prior to the Role Change event.  <a href="group___h_c_i__events.html#ga5a7454ce305b0487d94be8194b1bde4d">More...</a><br /></td></tr>
<tr class="separator:ga5a7454ce305b0487d94be8194b1bde4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a1b8c924e1e6a7648faeeb6a53c4e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga20a1b8c924e1e6a7648faeeb6a53c4e4">hci_authenticated_payload_timeout_expired_event</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga20a1b8c924e1e6a7648faeeb6a53c4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_Authenticated_Payload_Timeout_Expired event is used to indicate that a packet containing a valid MIC on the Connection_Handle was not received within the authenticatedPayloadTO. Note: A Host may choose to disconnect the link when this occurs.  <a href="group___h_c_i__events.html#ga20a1b8c924e1e6a7648faeeb6a53c4e4">More...</a><br /></td></tr>
<tr class="separator:ga20a1b8c924e1e6a7648faeeb6a53c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c1225de2f440ed8a35a8760d1109c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i__events.html#ga24c1225de2f440ed8a35a8760d1109c1">hci_rx_acl_data_event</a> (uint16_t Connection_Handle, uint8_t PB_Flag, uint8_t BC_Flag, uint16_t Data_Length, uint8_t *PDU_Data)</td></tr>
<tr class="memdesc:ga24c1225de2f440ed8a35a8760d1109c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">API used to receive HCI ACL Data Packets to exchange data between the Host and Controller.  <a href="group___h_c_i__events.html#ga24c1225de2f440ed8a35a8760d1109c1">More...</a><br /></td></tr>
<tr class="separator:ga24c1225de2f440ed8a35a8760d1109c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca8160d0515ff237c4c8f4db8e45c77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gaca8160d0515ff237c4c8f4db8e45c77a">hci_le_connection_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t Role, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint16_t Conn_Interval, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint8_t Master_Clock_Accuracy)</td></tr>
<tr class="memdesc:gaca8160d0515ff237c4c8f4db8e45c77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails this event shall be provided to the Host that had issued the LE_Create_Connection command. This event indicates to the Host which issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful. The Master_Clock_Accuracy parameter is only valid for a slave. On a master, this parameter shall be set to 0x00.  <a href="group___h_c_i___l_e__meta__events.html#gaca8160d0515ff237c4c8f4db8e45c77a">More...</a><br /></td></tr>
<tr class="separator:gaca8160d0515ff237c4c8f4db8e45c77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c3c6ecbaf3113c2161d825e9e03941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a> (uint8_t Num_Reports, <a class="el" href="group___h_c_i___l_e__meta__events.html#gae9bbd1aa8e2e33caa47ef92ab59a6dca">Advertising_Report_t</a> Advertising_Report[])</td></tr>
<tr class="memdesc:ga07c3c6ecbaf3113c2161d825e9e03941"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Advertising Report event indicates that a Bluetooth device or multiple Bluetooth devices have responded to an active scan or received some information during a passive scan. The Controller may queue these advertising reports and send information from multiple devices in one LE Advertising Report event.  <a href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">More...</a><br /></td></tr>
<tr class="separator:ga07c3c6ecbaf3113c2161d825e9e03941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b3b0abeb955daefb6b3a860d11e0e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga40b3b0abeb955daefb6b3a860d11e0e9">hci_le_connection_update_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint16_t Conn_Interval, uint16_t Conn_Latency, uint16_t Supervision_Timeout)</td></tr>
<tr class="memdesc:ga40b3b0abeb955daefb6b3a860d11e0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Connection Update Complete event is used to indicate that the Controller process to update the connection has completed. On a slave, if no connection parameters are updated, then this event shall not be issued. On a master, this event shall be issued if the Connection_Update command was sent.  <a href="group___h_c_i___l_e__meta__events.html#ga40b3b0abeb955daefb6b3a860d11e0e9">More...</a><br /></td></tr>
<tr class="separator:ga40b3b0abeb955daefb6b3a860d11e0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6586fb4ec5e69768dbc4e01cfd03ebac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga6586fb4ec5e69768dbc4e01cfd03ebac">hci_le_read_remote_used_features_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t LE_Features[8])</td></tr>
<tr class="memdesc:ga6586fb4ec5e69768dbc4e01cfd03ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Read Remote Used Features Complete event is used to indicate the completion of the process of the Controller obtaining the used features of the remote Bluetooth device specified by the Connection_Handle event parameter.  <a href="group___h_c_i___l_e__meta__events.html#ga6586fb4ec5e69768dbc4e01cfd03ebac">More...</a><br /></td></tr>
<tr class="separator:ga6586fb4ec5e69768dbc4e01cfd03ebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c93dd9d0b4f8d03632622b148eae10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga64c93dd9d0b4f8d03632622b148eae10">hci_le_long_term_key_request_event</a> (uint16_t Connection_Handle, uint8_t Random_Number[8], uint16_t Encrypted_Diversifier)</td></tr>
<tr class="memdesc:ga64c93dd9d0b4f8d03632622b148eae10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Long Term Key Request event indicates that the master device is attempting to encrypt or re-encrypt the link and is requesting the Long Term Key from the Host. (See [Vol 6] Part B, Section 5.1.3).  <a href="group___h_c_i___l_e__meta__events.html#ga64c93dd9d0b4f8d03632622b148eae10">More...</a><br /></td></tr>
<tr class="separator:ga64c93dd9d0b4f8d03632622b148eae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e36c19332ed4c31060865782b243cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga60e36c19332ed4c31060865782b243cd">hci_le_data_length_change_event</a> (uint16_t Connection_Handle, uint16_t MaxTxOctets, uint16_t MaxTxTime, uint16_t MaxRxOctets, uint16_t MaxRxTime)</td></tr>
<tr class="memdesc:ga60e36c19332ed4c31060865782b243cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Data Length Change event notifies the Host of a change to either the maximum Payload length or the maximum transmission time of Data Channel PDUs in either direction. The values reported are the maximum that will actually be used on the connection following the change.  <a href="group___h_c_i___l_e__meta__events.html#ga60e36c19332ed4c31060865782b243cd">More...</a><br /></td></tr>
<tr class="separator:ga60e36c19332ed4c31060865782b243cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae118c9dc2586ade9ad6d396a0249990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gaae118c9dc2586ade9ad6d396a0249990">hci_le_read_local_p256_public_key_complete_event</a> (uint8_t Status, uint8_t Local_P256_Public_Key[64])</td></tr>
<tr class="memdesc:gaae118c9dc2586ade9ad6d396a0249990"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when local P-256 key generation is complete.  <a href="group___h_c_i___l_e__meta__events.html#gaae118c9dc2586ade9ad6d396a0249990">More...</a><br /></td></tr>
<tr class="separator:gaae118c9dc2586ade9ad6d396a0249990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23da26083fc7c2dd69750efe0e5a902f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga23da26083fc7c2dd69750efe0e5a902f">hci_le_generate_dhkey_complete_event</a> (uint8_t Status, uint8_t DHKey[32])</td></tr>
<tr class="memdesc:ga23da26083fc7c2dd69750efe0e5a902f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event indicates that LE Diffie Hellman key generation has been completed by the Controller.  <a href="group___h_c_i___l_e__meta__events.html#ga23da26083fc7c2dd69750efe0e5a902f">More...</a><br /></td></tr>
<tr class="separator:ga23da26083fc7c2dd69750efe0e5a902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc2695b92fb2afcdbd3941d91aa4cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gafbc2695b92fb2afcdbd3941d91aa4cf2">hci_le_enhanced_connection_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t Role, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Local_Resolvable_Private_Address[6], uint8_t Peer_Resolvable_Private_Address[6], uint16_t Conn_Interval, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint8_t Master_Clock_Accuracy)</td></tr>
<tr class="memdesc:gafbc2695b92fb2afcdbd3941d91aa4cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Enhanced Connection Complete event indicates to both of the Hosts forming the connection that a new connection has been created. Upon the creation of the connection a Connection_Handle shall be assigned by the Controller, and passed to the Host in this event. If the connection establishment fails, this event shall be provided to the Host that had issued the LE_Create_Connection command. If this event is unmasked and LE Connection Complete event is unmasked, only the LE Enhanced Connection Complete event is sent when a new connection has been completed. This event indicates to the Host that issued a LE_Create_Connection command and received a Command Status event if the connection establishment failed or was successful. The Master_Clock_Accuracy parameter is only valid for a slave. On a master, this parameter shall be set to 0x00.  <a href="group___h_c_i___l_e__meta__events.html#gafbc2695b92fb2afcdbd3941d91aa4cf2">More...</a><br /></td></tr>
<tr class="separator:gafbc2695b92fb2afcdbd3941d91aa4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3e5676bddb8861cfe630221b47ac55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga9d3e5676bddb8861cfe630221b47ac55">hci_le_direct_advertising_report_event</a> (uint8_t Num_Reports, <a class="el" href="group___h_c_i___l_e__meta__events.html#gae2b54c0dfdf31f5f75e72b68f0ce120f">Direct_Advertising_Report_t</a> Direct_Advertising_Report[])</td></tr>
<tr class="memdesc:ga9d3e5676bddb8861cfe630221b47ac55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Direct Advertising Report event indicates that directed advertisements have been received where the advertiser is using a resolvable private address for the InitA field in the ADV_DIRECT_IND PDU and the Scanning_Filter_Policy is equal to 0x02 or 0x03, see HCI_LE_Set_Scan_Parameters. Direct_Address_Type and Direct_Addres is the address the directed advertisements are being directed to. Address_Type and Address is the address of the advertiser sending the directed advertisements.  <a href="group___h_c_i___l_e__meta__events.html#ga9d3e5676bddb8861cfe630221b47ac55">More...</a><br /></td></tr>
<tr class="separator:ga9d3e5676bddb8861cfe630221b47ac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f776d7e3f457177a60382839024e674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga0f776d7e3f457177a60382839024e674">hci_le_phy_update_complete_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t TX_PHY, uint8_t RX_PHY)</td></tr>
<tr class="memdesc:ga0f776d7e3f457177a60382839024e674"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE PHY Update Complete Event is used to indicate that the Controller has changed the transmitter PHY or receiver PHY in use. If the Controller changes the transmitter PHY, the receiver PHY, or both PHYs, this event shall be issued. If an LE_Set_PHY command was sent and the Controller determines that neither PHY will change as a result, it issues this event immediately.  <a href="group___h_c_i___l_e__meta__events.html#ga0f776d7e3f457177a60382839024e674">More...</a><br /></td></tr>
<tr class="separator:ga0f776d7e3f457177a60382839024e674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa560bffeddff4afa666da896cfc243ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gaa560bffeddff4afa666da896cfc243ee">hci_le_extended_advertising_report_event</a> (uint8_t Num_Reports, <a class="el" href="group___h_c_i___l_e__meta__events.html#ga4fd5664780a21b6c57c50c4d121bfa6c">Extended_Advertising_Report_t</a> Extended_Advertising_Report[])</td></tr>
<tr class="memdesc:gaa560bffeddff4afa666da896cfc243ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Extended Advertising Report event indicates that one or more Bluetooth devices have responded to an active scan or have broadcast advertisements that were received during a passive scan. The Controller may coalesce multiple advertising reports from the same or different advertisers into a single LE Extended Advertising Report event, provided all the parameters from all the advertising reports fit in a single HCI event. This event shall only be generated if scanning was enabled using the LE Set Extended Scan Enable command. It reports advertising events using either legacy or extended advertising PDUs. The Controller may split the data from a single advertisement (whether one PDU or several) into several reports. If so, each report except the last shall have an Event_Type with a data status field of "incomplete, more data to come", while the last shall have the value "complete"; the Address_Type, Address, Advertising_SID, Primary_PHY, and Secondary_PHY fields shall be the same in all the reports. When a scan response is received, bits 0-2 and 4 of the event type shall indicate the properties of the original advertising event. An Event_Type with a data status field of "incomplete, data truncated" indicates that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not successful.  <a href="group___h_c_i___l_e__meta__events.html#gaa560bffeddff4afa666da896cfc243ee">More...</a><br /></td></tr>
<tr class="separator:gaa560bffeddff4afa666da896cfc243ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2739efed777e502545bd7ba3c1c515a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga2739efed777e502545bd7ba3c1c515a9">hci_le_periodic_advertising_sync_established_event</a> (uint8_t Status, uint16_t Sync_Handle, uint8_t Advertising_SID, uint8_t Advertiser_Address_Type, uint8_t Advertiser_Address[6], uint8_t Advertiser_PHY, uint16_t Periodic_Advertising_Interval, uint8_t Advertiser_Clock_Accuracy)</td></tr>
<tr class="memdesc:ga2739efed777e502545bd7ba3c1c515a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Periodic Advertising Report event indicates that the Controller has received a Periodic Advertising packet. The Sync_Handle parameter indicates the identifier for the periodic advertisements specified by the Advertising SID subfield of the ADI field in the ADV_EXT_IND PDU. The Controller may split the data from a single periodic advertisement (whether one PDU or several) into several reports. If so, each report except the last shall have a Data_Status of "incomplete, more data to
          come", while the last shall have the value "complete". A Data_Status of "incomplete, data truncated" indicates that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not successful. The Unused parameter shall be set to 0xFF by the Controller and ignored by the Host.  <a href="group___h_c_i___l_e__meta__events.html#ga2739efed777e502545bd7ba3c1c515a9">More...</a><br /></td></tr>
<tr class="separator:ga2739efed777e502545bd7ba3c1c515a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc904445d6eea32dbd8626b25b72e5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga0dc904445d6eea32dbd8626b25b72e5e">hci_le_periodic_advertising_report_event</a> (uint16_t Sync_Handle, int8_t TX_Power, int8_t RSSI, uint8_t CTE_Type, uint8_t Data_Status, uint8_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga0dc904445d6eea32dbd8626b25b72e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Periodic Advertising Report event indicates that the Controller has received a Periodic Advertising packet. The Sync_Handle parameter indicates the identifier for the periodic advertisements specified by the Advertising SID subfield of the ADI field in the ADV_EXT_IND PDU. The Controller may split the data from a single periodic advertisement (whether one PDU or several) into several reports. If so, each report except the last shall have a Data_Status of "incomplete, more data to
       come", while the last shall have the value "complete". A Data_Status of "incomplete, data truncated" indicates that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not successful. The Unused parameter shall be set to 0xFF by the Controller and ignored by the Host.  <a href="group___h_c_i___l_e__meta__events.html#ga0dc904445d6eea32dbd8626b25b72e5e">More...</a><br /></td></tr>
<tr class="separator:ga0dc904445d6eea32dbd8626b25b72e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5639d0dad30d8655b05d25377dec0525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga5639d0dad30d8655b05d25377dec0525">hci_le_periodic_advertising_sync_lost_event</a> (uint16_t Sync_Handle)</td></tr>
<tr class="memdesc:ga5639d0dad30d8655b05d25377dec0525"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Periodic Advertising Sync Lost event indicates that the Controller has not received a Periodic Advertising packet identified by Sync_Handle within the timeout period.  <a href="group___h_c_i___l_e__meta__events.html#ga5639d0dad30d8655b05d25377dec0525">More...</a><br /></td></tr>
<tr class="separator:ga5639d0dad30d8655b05d25377dec0525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360464af1a2de09fa1304943804a665c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga360464af1a2de09fa1304943804a665c">hci_le_scan_timeout_event</a> (void)</td></tr>
<tr class="memdesc:ga360464af1a2de09fa1304943804a665c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Scan Timeout event indicates that scanning has ended because the duration has expired. This event shall only be generated if scanning was enabled using the LE Set Extended Scan Enable command.  <a href="group___h_c_i___l_e__meta__events.html#ga360464af1a2de09fa1304943804a665c">More...</a><br /></td></tr>
<tr class="separator:ga360464af1a2de09fa1304943804a665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9163c84ec30e7afbc439be2e23385c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga9163c84ec30e7afbc439be2e23385c34">hci_le_advertising_set_terminated_event</a> (uint8_t Status, uint8_t Advertising_Handle, uint16_t Connection_Handle, uint8_t Num_Completed_Extended_Advertising_Events)</td></tr>
<tr class="memdesc:ga9163c84ec30e7afbc439be2e23385c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Advertising Set Terminated event indicates that the Controller has terminated advertising in the advertising sets specified by the Advertising_Handle parameter. This event shall be generated every time connectable advertising in an advertising set results in a connection being created. This event shall only be generated if advertising was enabled using the LE Set Extended Advertising Enable command. The Connection_Handle parameter is only valid when advertising ends because a connection was created. If the Max_Extended_Advertising_Events parameter in the LE_Set_Extended_Advertising_Enable command was non-zero, the Num_Completed_Extended_Advertising_Events parameter shall be set to the number of completed extended advertising events the Controller had transmitted when either the duration elapsed or the maximum number of extended advertising events was reached; otherwise it shall be set to zero. If advertising has terminated as a result of the advertising duration elapsing, the Status parameter shall be set to the error code Advertising Timeout (0x3C). If advertising has terminated because the Max_Extended_Advertising_Events was reached, the Status parameter shall be set to the error code Limit Reached (0x43).  <a href="group___h_c_i___l_e__meta__events.html#ga9163c84ec30e7afbc439be2e23385c34">More...</a><br /></td></tr>
<tr class="separator:ga9163c84ec30e7afbc439be2e23385c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f27f2f1b76115e1537d68cf5fea400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga06f27f2f1b76115e1537d68cf5fea400">hci_le_scan_request_received_event</a> (uint8_t Advertising_Handle, uint8_t Scanner_Address_Type, uint8_t Scanner_Address[6])</td></tr>
<tr class="memdesc:ga06f27f2f1b76115e1537d68cf5fea400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Scan Request Received event indicates that a SCAN_REQ PDU or an AUX_SCAN_REQ PDU has been received by the advertiser. The request contains a device address from a scanner that is allowed by the advertising filter policy. The advertising set is identified by Advertising_Handle. This event shall only be generated if advertising was enabled using the LE Set Extended Advertising Enable command. The Scanner_Address_Type and Scanner_Address indicates the type of the address and the address of the scanner device.  <a href="group___h_c_i___l_e__meta__events.html#ga06f27f2f1b76115e1537d68cf5fea400">More...</a><br /></td></tr>
<tr class="separator:ga06f27f2f1b76115e1537d68cf5fea400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf18c6654cb027d056665eb1c894b61b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gaf18c6654cb027d056665eb1c894b61b6">hci_le_channel_selection_algorithm_event</a> (uint16_t Connection_Handle, uint8_t Channel_Selection_Algorithm)</td></tr>
<tr class="memdesc:gaf18c6654cb027d056665eb1c894b61b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE Channel Selection Algorithm Event indicates which channel selection algorithm is used on a data channel connection (see [Vol 6] Part B, Section 4.5.8).  <a href="group___h_c_i___l_e__meta__events.html#gaf18c6654cb027d056665eb1c894b61b6">More...</a><br /></td></tr>
<tr class="separator:gaf18c6654cb027d056665eb1c894b61b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61467d06e48a47bacb65e2d7f7b7cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gaf61467d06e48a47bacb65e2d7f7b7cf6">hci_le_connectionless_iq_report_event</a> (uint16_t Sync_Handle, uint8_t Channel_Index, int16_t RSSI, uint8_t RSSI_Antenna_ID, uint8_t CTE_Type, uint8_t Slot_Durations, uint8_t Packet_Status, uint16_t Periodic_Event_Counter, uint8_t Sample_Count, <a class="el" href="group___h_c_i___l_e__meta__events.html#gac7cf2514b3bacd2b5c4f75e28a324168">Samples_t</a> Samples[])</td></tr>
<tr class="memdesc:gaf61467d06e48a47bacb65e2d7f7b7cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Connectionless_IQ_Report event is used by the Controller to report IQ information from the Constant Tone Extension of a received advertising packet forming part of the periodic advertising train identified by Sync_Handle and to report IQ information from the Constant Tone Extension of a received Test Mode packet (see Section 7.8.28). The index of the channel on which the packet was received, the RSSI of the packet (excluding the Constant Tone Extension), the ID of the antenna on which this was measured, the type of Constant Tone Extension, the value of paEventCounter, and the IQ samples of the Constant Tone Extension of the advertisement are reported in the corresponding parameters. For any given sample, either both or neither of I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations parameter specifies the sampling rate used by the Controller. The Packet_Status parameter indicates whether the received packet had a valid CRC and, if not, whether the Controller has determined the position and size of the Constant Tone Extension using the Length and CTETime fields. Note: A Controller is not required to generate this event for packets that have a bad CRC. The Constant Tone Extension format is defined in [Vol 6] Part B, Section 2.5.1. If the PDU contains AdvData, then the HCI_LE_Periodic_Advertising_Report event shall be generated before this event. The Controller is not required to generate this event for a Constant Tone Extension with a type that it does not support. This event is also used by the Controller to report that it has insufficient resources to report IQ samples for all received Constant Tone Extensions and has failed to sample at least once. In this case Packet_Status shall be set to 0xFF and Sample_Count to 0x00.  <a href="group___h_c_i___l_e__meta__events.html#gaf61467d06e48a47bacb65e2d7f7b7cf6">More...</a><br /></td></tr>
<tr class="separator:gaf61467d06e48a47bacb65e2d7f7b7cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b0d7768e3399a2d918813341b63172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga47b0d7768e3399a2d918813341b63172">hci_le_connection_iq_report_event</a> (uint16_t Connection_Handle, uint8_t RX_PHY, uint8_t Data_Channel_Index, int16_t RSSI, uint8_t RSSI_Antenna_ID, uint8_t CTE_Type, uint8_t Slot_Durations, uint8_t Packet_Status, uint16_t Connection_Event_Counter, uint8_t Sample_Count, <a class="el" href="group___h_c_i___l_e__meta__events.html#gac7cf2514b3bacd2b5c4f75e28a324168">Samples_t</a> Samples[])</td></tr>
<tr class="memdesc:ga47b0d7768e3399a2d918813341b63172"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Connection_IQ_Report event is used by the Controller to report the IQ samples from the Constant Tone Extension of a received packet (see [Vol 6] Part B, Section 2.4.2.26). The Connection_Handle parameter identifies the connection that corresponds to the reported information. The receiver PHY, the index of the data channel, the RSSI value of the packet (excluding the Constant Tone Extension), the ID of the antenna on which this was measured, the type of Constant Tone Extension, the value of connEventCounter, and the IQ samples of the Constant Tone Extension of the received packet are reported in the corresponding parameters. For any given sample, either both or neither of I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations parameter specifies the sampling rate used by the Controller. The Packet_Status parameter indicates whether the received packet had a valid CRC and, if not, whether the Controller has determined the position and size of the Constant Tone Extension using the Length and CTETime fields. Note: A Controller is not required to generate this event for packets that have a bad CRC. This event is also used by the Controller to report that it has insufficient resources to report IQ samples for all received Constant Tone Extensions and has failed to sample at least once. In this case Packet_Status shall be set to 0xFF and Sample_Count to 0x00. The Constant Tone Extension format is defined in [Vol 6] Part B, Section 2.1.5.  <a href="group___h_c_i___l_e__meta__events.html#ga47b0d7768e3399a2d918813341b63172">More...</a><br /></td></tr>
<tr class="separator:ga47b0d7768e3399a2d918813341b63172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb27102c2a339e78c8826c207f03622b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gafb27102c2a339e78c8826c207f03622b">hci_le_cte_request_failed_event</a> (uint8_t Status, uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gafb27102c2a339e78c8826c207f03622b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is used by the Controller to report an issue following a request to a peer device to reply with a packet containing an LL_CTE_RSP PDU and a Constant Tone Extension. It shall be generated if the packet containing the LL_CTE_RSP PDU sent in response did not contain a Constant Tone Extension or if the peer rejected the request. It shall not be generated if the packet containing the LL_CTE_RSP PDU had a CRC error or if the procedure response timeout timer (see [Vol 6] Part B, Section 5.2) expired.  <a href="group___h_c_i___l_e__meta__events.html#gafb27102c2a339e78c8826c207f03622b">More...</a><br /></td></tr>
<tr class="separator:gafb27102c2a339e78c8826c207f03622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae350f06bea92f1eb6abb4bc7320ed9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#gaeae350f06bea92f1eb6abb4bc7320ed9">hci_le_periodic_advertising_sync_transfer_received_event</a> (uint8_t Status, uint16_t Connection_Handle, uint16_t Service_data, uint16_t Sync_Handle, uint8_t Advertising_SID, uint8_t Advertiser_Address_Type, uint8_t Advertiser_Address[6], uint8_t Advertiser_PHY, uint16_t Periodic_Advertising_Interval, uint8_t Advertiser_Clock_Accuracy)</td></tr>
<tr class="memdesc:gaeae350f06bea92f1eb6abb4bc7320ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is used by the Controller to report that it has received periodic advertising synchronization information from the device referred to by the Connection_Handle parameter and either successfully synchronized to the periodic advertising train or timed out while attempting to synchronize. The Status will be zero if it successfully synchronized and non-zero otherwise. The Service_Data value is provided by the Host of the device sending the information. The Sync_Handle identifies the periodic advertising in subsequent commands and events and shall be assigned by the Controller. The remaining parameters provide information about the periodic advertising (see Section 7.7.65.14). If Status is non-zero, all parameter values are valid except Sync_Handle, which the Host shall ignore. Note: If the Controller is already synchronized to the periodic advertising train described in the received information, no event will be generated.  <a href="group___h_c_i___l_e__meta__events.html#gaeae350f06bea92f1eb6abb4bc7320ed9">More...</a><br /></td></tr>
<tr class="separator:gaeae350f06bea92f1eb6abb4bc7320ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849fc4ae95b9f4628799914f724b0842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga849fc4ae95b9f4628799914f724b0842">hci_le_path_loss_threshold_event</a> (uint16_t Connection_Handle, uint8_t Current_Path_Loss, uint8_t Zone_Entered)</td></tr>
<tr class="memdesc:ga849fc4ae95b9f4628799914f724b0842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a path loss threshold crossing on the ACL connection identified by the Connection_Handle parameter.  <a href="group___h_c_i___l_e__meta__events.html#ga849fc4ae95b9f4628799914f724b0842">More...</a><br /></td></tr>
<tr class="separator:ga849fc4ae95b9f4628799914f724b0842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029736e0bacead2e3ed08a4afa364c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___l_e__meta__events.html#ga029736e0bacead2e3ed08a4afa364c81">hci_le_transmit_power_reporting_event</a> (uint8_t Status, uint16_t Connection_Handle, uint8_t Reason, uint8_t PHY, int8_t Transmit_Power_Level, uint8_t Transmit_Power_Level_Flag, int8_t Delta)</td></tr>
<tr class="memdesc:ga029736e0bacead2e3ed08a4afa364c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the transmit power level on the ACL connection identified by the Connection_Handle parameter.  <a href="group___h_c_i___l_e__meta__events.html#ga029736e0bacead2e3ed08a4afa364c81">More...</a><br /></td></tr>
<tr class="separator:ga029736e0bacead2e3ed08a4afa364c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2959f4046febc21171af4788a40da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#ga2b2959f4046febc21171af4788a40da0">aci_gap_limited_discoverable_event</a> (void)</td></tr>
<tr class="memdesc:ga2b2959f4046febc21171af4788a40da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the controller when the limited discoverable mode ends due to timeout. The timeout is 180 seconds.  <a href="group___a_c_i___g_a_p__events.html#ga2b2959f4046febc21171af4788a40da0">More...</a><br /></td></tr>
<tr class="separator:ga2b2959f4046febc21171af4788a40da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc74352ad6c26c693df1390109c55923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#gadc74352ad6c26c693df1390109c55923">aci_gap_pairing_complete_event</a> (uint16_t Connection_Handle, uint8_t Status, uint8_t Reason)</td></tr>
<tr class="memdesc:gadc74352ad6c26c693df1390109c55923"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the pairing process has completed successfully or a pairing procedure timeout has occurred or the pairing has failed. This is to notify the application that we have paired with a remote device so that it can take further actions or to notify that a timeout has occurred so that the upper layer can decide to disconnect the link.  <a href="group___a_c_i___g_a_p__events.html#gadc74352ad6c26c693df1390109c55923">More...</a><br /></td></tr>
<tr class="separator:gadc74352ad6c26c693df1390109c55923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4820d33fd0fa8fec40c725b78b02c913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#ga4820d33fd0fa8fec40c725b78b02c913">aci_gap_pass_key_req_event</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga4820d33fd0fa8fec40c725b78b02c913"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the Security manager to the application when a passkey is required for pairing. When this event is received, the application has to respond with the <a class="el" href="group___g_a_p___commands.html#gab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> command.  <a href="group___a_c_i___g_a_p__events.html#ga4820d33fd0fa8fec40c725b78b02c913">More...</a><br /></td></tr>
<tr class="separator:ga4820d33fd0fa8fec40c725b78b02c913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40710dcae07d4590f4c5e9c187c1769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#gaf40710dcae07d4590f4c5e9c187c1769">aci_gap_slave_security_initiated_event</a> (void)</td></tr>
<tr class="memdesc:gaf40710dcae07d4590f4c5e9c187c1769"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the slave security request is successfully sent to the master.  <a href="group___a_c_i___g_a_p__events.html#gaf40710dcae07d4590f4c5e9c187c1769">More...</a><br /></td></tr>
<tr class="separator:gaf40710dcae07d4590f4c5e9c187c1769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b045193ab337198a804b874c1308cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#ga08b045193ab337198a804b874c1308cf">aci_gap_bond_lost_event</a> (void)</td></tr>
<tr class="memdesc:ga08b045193ab337198a804b874c1308cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated on the slave when a ACI_GAP_SLAVE_SECURITY_REQUEST is called to reestablish the bond with a master but the master has lost the bond. When this event is received, the upper layer has to issue the ACI_GAP_ALLOW_REBOND command in order to allow the slave to continue the pairing process with the master. On the master this event is raised when ACI_GAP_SEND_PAIRING_REQUEST is called to reestablish a bond with a slave but the slave has lost the bond. In order to create a new bond the master has to launch ACI_GAP_SEND_PAIRING_REQUEST with force_rebond set to 1.  <a href="group___a_c_i___g_a_p__events.html#ga08b045193ab337198a804b874c1308cf">More...</a><br /></td></tr>
<tr class="separator:ga08b045193ab337198a804b874c1308cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab257c9a8c675a353a9c14c587f81342d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> (uint8_t Procedure_Code, uint8_t Status, uint8_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:gab257c9a8c675a353a9c14c587f81342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent by the GAP to the upper layers when a procedure previously started has been terminated by the upper layer or has completed for any other reason.  <a href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">More...</a><br /></td></tr>
<tr class="separator:gab257c9a8c675a353a9c14c587f81342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b179b067596d77795ee3dc4b4db5ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#ga59b179b067596d77795ee3dc4b4db5ce">aci_gap_addr_not_resolved_event</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga59b179b067596d77795ee3dc4b4db5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent only by a privacy enabled Peripheral. The event is sent to the upper layers when the peripheral is unsuccessful in resolving the resolvable address of the peer device after connecting to it.  <a href="group___a_c_i___g_a_p__events.html#ga59b179b067596d77795ee3dc4b4db5ce">More...</a><br /></td></tr>
<tr class="separator:ga59b179b067596d77795ee3dc4b4db5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3cc437384f4b0226a1849a3d84d975c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#gaa3cc437384f4b0226a1849a3d84d975c">aci_gap_numeric_comparison_value_event</a> (uint16_t Connection_Handle, uint32_t Numeric_Value)</td></tr>
<tr class="memdesc:gaa3cc437384f4b0226a1849a3d84d975c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent only during SC v.4.2 Pairing, when Numeric Comparison Association model is selected, in order to show the Numeric Value generated, and to ask for Confirmation to the User. When this event is received, the application has to respond with the <a class="el" href="group___g_a_p___commands.html#ga53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> command.  <a href="group___a_c_i___g_a_p__events.html#gaa3cc437384f4b0226a1849a3d84d975c">More...</a><br /></td></tr>
<tr class="separator:gaa3cc437384f4b0226a1849a3d84d975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0e27042f7e1b696ce804e6b6a10caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_p__events.html#gabd0e27042f7e1b696ce804e6b6a10caf">aci_gap_keypress_notification_event</a> (uint16_t Connection_Handle, uint8_t Notification_Type)</td></tr>
<tr class="memdesc:gabd0e27042f7e1b696ce804e6b6a10caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is sent only during SC v.4.2 Pairing, when Keypress Notifications are supported, in order to show the input type signalled by the peer device, having Keyboard only I/O capabilities. When this event is received, no action is required to the User.  <a href="group___a_c_i___g_a_p__events.html#gabd0e27042f7e1b696ce804e6b6a10caf">More...</a><br /></td></tr>
<tr class="separator:gabd0e27042f7e1b696ce804e6b6a10caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a86421e4aa9a04059210f050b3aeb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga56a86421e4aa9a04059210f050b3aeb0">aci_gatt_srv_attribute_modified_event</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Attr_Data_Length, uint8_t Attr_Data[])</td></tr>
<tr class="memdesc:ga56a86421e4aa9a04059210f050b3aeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated to the application by the GATT server when a client modifies any attribute on the server, as consequence of one of the following GATT procedures: - write without response - signed write without response - write characteristic value - write long characteristic value - reliable write.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga56a86421e4aa9a04059210f050b3aeb0">More...</a><br /></td></tr>
<tr class="separator:ga56a86421e4aa9a04059210f050b3aeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb482bfe60fc6bcf22db18aea991e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaaeb482bfe60fc6bcf22db18aea991e53">aci_gatt_proc_timeout_event</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gaaeb482bfe60fc6bcf22db18aea991e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated by the client/server to the application on a GATT timeout (30 seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The applications is exptected to issue an <a class="el" href="group___g_a_p___commands.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> to disconnect from the peer device. It is important to leave an 100 ms blank window before sending the <a class="el" href="group___g_a_p___commands.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a>, since immediately after this event, system could save important information in non volatile memory.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaaeb482bfe60fc6bcf22db18aea991e53">More...</a><br /></td></tr>
<tr class="separator:gaaeb482bfe60fc6bcf22db18aea991e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fff3f7c776e7b6e51a4c85a08e48a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga5fff3f7c776e7b6e51a4c85a08e48a8a">aci_att_exchange_mtu_resp_event</a> (uint16_t Connection_Handle, uint16_t Server_RX_MTU)</td></tr>
<tr class="memdesc:ga5fff3f7c776e7b6e51a4c85a08e48a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to an Exchange MTU request (local or from the peer). See <a class="el" href="group___g_a_t_t___commands.html#ga3089d94aa7df2578d0f5e6f4a136be3e" title="Performs an ATT MTU exchange procedure. When the ATT MTU exchange procedure is completed, a aci_att_exchange_mtu_resp_event event is generated. A aci_gatt_clt_proc_complete_event event is also generated to indicate the end of the procedure. ">aci_gatt_clt_exchange_config()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga5fff3f7c776e7b6e51a4c85a08e48a8a">More...</a><br /></td></tr>
<tr class="separator:ga5fff3f7c776e7b6e51a4c85a08e48a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5d56dc87aa93183124d75d5d4a3c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gadc5d56dc87aa93183124d75d5d4a3c20">aci_att_clt_find_info_resp_event</a> (uint16_t Connection_Handle, uint8_t Format, uint16_t Event_Data_Length, uint8_t Handle_UUID_Pair[])</td></tr>
<tr class="memdesc:gadc5d56dc87aa93183124d75d5d4a3c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Find Information Request during a discovery procedure for all the characteristic descriptors. See <a class="el" href="group___g_a_t_t___commands.html#ga532b91236639d7dd20cf7c076a1ec78d" title="Starts the procedure to discover all characteristic descriptors on the server. When the procedure is ...">aci_gatt_clt_disc_all_char_desc()</a> and Find Information Response in Bluetooth Core spec.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gadc5d56dc87aa93183124d75d5d4a3c20">More...</a><br /></td></tr>
<tr class="separator:gadc5d56dc87aa93183124d75d5d4a3c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d1614a3401a8edc568250f3ff6565f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac5d1614a3401a8edc568250f3ff6565f">aci_att_clt_find_by_type_value_resp_event</a> (uint16_t Connection_Handle, uint8_t Num_of_Handle_Pair, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9aa18cda6ab01e75304a6d81ceec854c">Attribute_Group_Handle_Pair_t</a> Attribute_Group_Handle_Pair[])</td></tr>
<tr class="memdesc:gac5d1614a3401a8edc568250f3ff6565f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated during a "discover service by UUID" procedure. See <a class="el" href="group___g_a_t_t___commands.html#ga1ee3b3b581fdbe2a8d42882cbdc4d71e" title="Starts the procedure to discover the primary services of the specified UUID on the server...">aci_gatt_clt_disc_primary_service_by_uuid()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac5d1614a3401a8edc568250f3ff6565f">More...</a><br /></td></tr>
<tr class="separator:gac5d1614a3401a8edc568250f3ff6565f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24f264438529afea1a9225c99efa3b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga24f264438529afea1a9225c99efa3b1b">aci_att_clt_read_by_type_resp_event</a> (uint16_t Connection_Handle, uint8_t Handle_Value_Pair_Length, uint16_t Data_Length, uint8_t Handle_Value_Pair_Data[])</td></tr>
<tr class="memdesc:ga24f264438529afea1a9225c99efa3b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a ATT_READ_BY_TYPE_REQ, during a "find included service" procedure or a "discover all
       characteristics" procedure. See <a class="el" href="group___g_a_t_t___commands.html#gaef0778922d442a455145eb13e3ead915" title="Starts the procedure to find all included services. The responses of the procedure are given through ...">aci_gatt_clt_find_included_services()</a> and <a class="el" href="group___g_a_t_t___commands.html#ga407ce9dbeab2e3e430ca4f4c9a40270b" title="Starts the procedure to discover all the characteristics of a given service. When the procedure is co...">aci_gatt_clt_disc_all_char_of_service()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga24f264438529afea1a9225c99efa3b1b">More...</a><br /></td></tr>
<tr class="separator:ga24f264438529afea1a9225c99efa3b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ecb59e8280e8f66bb60af6700dff2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga6ecb59e8280e8f66bb60af6700dff2bb">aci_att_clt_read_resp_event</a> (uint16_t Connection_Handle, uint16_t Event_Data_Length, uint8_t Attribute_Value[])</td></tr>
<tr class="memdesc:ga6ecb59e8280e8f66bb60af6700dff2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Read Request. See <a class="el" href="group___g_a_t_t___commands.html#gacfbfac57913e68df14fa7b717513fead" title="Starts the procedure to read an attribute value. When the procedure is completed, a aci_gatt_clt_proc...">aci_gatt_clt_read()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga6ecb59e8280e8f66bb60af6700dff2bb">More...</a><br /></td></tr>
<tr class="separator:ga6ecb59e8280e8f66bb60af6700dff2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d734cccb86cd3c9727e3a90688d209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gae2d734cccb86cd3c9727e3a90688d209">aci_att_clt_read_blob_resp_event</a> (uint16_t Connection_Handle, uint16_t Event_Data_Length, uint8_t Attribute_Value[])</td></tr>
<tr class="memdesc:gae2d734cccb86cd3c9727e3a90688d209"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event can be generated during a read long characteristic value procedure. See <a class="el" href="group___g_a_t_t___commands.html#gad2408fa0ea8eda1b7cd30cf062aa7af9" title="Starts the procedure to read a long attribute value. the procedure is completed, a aci_gatt_clt_proc_...">aci_gatt_clt_read_long()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gae2d734cccb86cd3c9727e3a90688d209">More...</a><br /></td></tr>
<tr class="separator:gae2d734cccb86cd3c9727e3a90688d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e70f2c6fef95652d8a7429826361be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa2e70f2c6fef95652d8a7429826361be">aci_att_clt_read_multiple_resp_event</a> (uint16_t Connection_Handle, uint16_t Event_Data_Length, uint8_t Set_Of_Values[])</td></tr>
<tr class="memdesc:gaa2e70f2c6fef95652d8a7429826361be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Read Multiple Request. See <a class="el" href="group___g_a_t_t___commands.html#ga8606d6c3071c496a7d9dffa81d189eb3" title="Starts a procedure to read multiple characteristic values from a server. This sub-procedure is used t...">aci_gatt_clt_read_multiple_char_value()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa2e70f2c6fef95652d8a7429826361be">More...</a><br /></td></tr>
<tr class="separator:gaa2e70f2c6fef95652d8a7429826361be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1992b789d5b80a6f7886824be711fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga8d1992b789d5b80a6f7886824be711fa">aci_att_clt_read_by_group_type_resp_event</a> (uint16_t Connection_Handle, uint8_t Attribute_Data_Length, uint16_t Data_Length, uint8_t Attribute_Data_List[])</td></tr>
<tr class="memdesc:ga8d1992b789d5b80a6f7886824be711fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to a Read By Group Type Request, during a "discover all primary services" procedure. See <a class="el" href="group___g_a_t_t___commands.html#ga4ffc0888eae26d9903a951948bd3e356" title="Starts the GATT client procedure to discover all primary services on the server. The responses of the...">aci_gatt_clt_disc_all_primary_services()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga8d1992b789d5b80a6f7886824be711fa">More...</a><br /></td></tr>
<tr class="separator:ga8d1992b789d5b80a6f7886824be711fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176b6a28ae1df4ee4c02cb1967631e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga176b6a28ae1df4ee4c02cb1967631e7d">aci_att_clt_prepare_write_resp_event</a> (uint16_t Connection_Handle, uint16_t Attribute_Handle, uint16_t Offset, uint16_t Part_Attribute_Value_Length, uint8_t Part_Attribute_Value[])</td></tr>
<tr class="memdesc:ga176b6a28ae1df4ee4c02cb1967631e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to an ATT_PREPARE_WRITE_REQ during a write long characteristic value procedure. See <a class="el" href="group___g_a_t_t___commands.html#gade442f01d53b88046d5eb888929422a1" title="This procedure is used to write an Attribute Value to a Server when the Client knows the Attribute Ha...">aci_gatt_clt_write_long()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga176b6a28ae1df4ee4c02cb1967631e7d">More...</a><br /></td></tr>
<tr class="separator:ga176b6a28ae1df4ee4c02cb1967631e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4842d0a68f0e0a0b39644b6480178ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac4842d0a68f0e0a0b39644b6480178ad">aci_att_clt_exec_write_resp_event</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gac4842d0a68f0e0a0b39644b6480178ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated in response to an ATT Execute Write Request, during a write long characteristic value procedure. See <a class="el" href="group___g_a_t_t___commands.html#gade442f01d53b88046d5eb888929422a1" title="This procedure is used to write an Attribute Value to a Server when the Client knows the Attribute Ha...">aci_gatt_clt_write_long()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac4842d0a68f0e0a0b39644b6480178ad">More...</a><br /></td></tr>
<tr class="separator:gac4842d0a68f0e0a0b39644b6480178ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03c176eaba41fdd852c3acad3acbcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaf03c176eaba41fdd852c3acad3acbcd1">aci_gatt_clt_indication_event</a> (uint16_t Connection_Handle, uint16_t Attribute_Handle, uint16_t Attribute_Value_Length, uint8_t Attribute_Value[])</td></tr>
<tr class="memdesc:gaf03c176eaba41fdd852c3acad3acbcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when an indication is received from the server.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaf03c176eaba41fdd852c3acad3acbcd1">More...</a><br /></td></tr>
<tr class="separator:gaf03c176eaba41fdd852c3acad3acbcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccaa26d2d93c1e7aca841ae2840fcae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gafccaa26d2d93c1e7aca841ae2840fcae">aci_gatt_clt_notification_event</a> (uint16_t Connection_Handle, uint16_t Attribute_Handle, uint16_t Attribute_Value_Length, uint8_t Attribute_Value[])</td></tr>
<tr class="memdesc:gafccaa26d2d93c1e7aca841ae2840fcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a notification is received from the server.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gafccaa26d2d93c1e7aca841ae2840fcae">More...</a><br /></td></tr>
<tr class="separator:gafccaa26d2d93c1e7aca841ae2840fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693f6d7f01c932eedf33caa475cc997a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> (uint16_t Connection_Handle, uint8_t Error_Code)</td></tr>
<tr class="memdesc:ga693f6d7f01c932eedf33caa475cc997a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a GATT client procedure completes either with error or successfully.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">More...</a><br /></td></tr>
<tr class="separator:ga693f6d7f01c932eedf33caa475cc997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c99a9419866dce7a4e94a762ee58c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1c99a9419866dce7a4e94a762ee58c22">aci_gatt_clt_error_resp_event</a> (uint16_t Connection_Handle, uint8_t Req_Opcode, uint16_t Attribute_Handle, uint8_t Error_Code)</td></tr>
<tr class="memdesc:ga1c99a9419866dce7a4e94a762ee58c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when an Error Response is received from the server. The error response can be given by the server at the end of one of the GATT discovery procedures. This does not mean that the procedure ended with an error, but this error event is part of the procedure itself.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1c99a9419866dce7a4e94a762ee58c22">More...</a><br /></td></tr>
<tr class="separator:ga1c99a9419866dce7a4e94a762ee58c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff2973006ce64d8f39be581e63ab46c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1ff2973006ce64d8f39be581e63ab46c">aci_gatt_clt_disc_read_char_by_uuid_resp_event</a> (uint16_t Connection_Handle, uint16_t Attribute_Handle, uint8_t Attribute_Value_Length, uint8_t Attribute_Value[])</td></tr>
<tr class="memdesc:ga1ff2973006ce64d8f39be581e63ab46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event can be generated during a "Discover Characteristics By
       UUID" procedure or a "Read using Characteristic UUID" procedure. During a "Discover Characteristics By UUID" procedure, Attribute_Value is a characteristic declaration as defined in Bluetooth Core spec (vol.3, Part G, ch. 3.3.1), i.e. it is composed by: Characteristic Properties (1 octet), Characteristic Value Handle (2 octets) and Characteristic UUID (2 or 16 octets). During a "Read using
       Characteristic UUID" procedure, Attribute_Value is the value of the characteristic.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1ff2973006ce64d8f39be581e63ab46c">More...</a><br /></td></tr>
<tr class="separator:ga1ff2973006ce64d8f39be581e63ab46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709cad02cfa0756751380fce49915688"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga709cad02cfa0756751380fce49915688">aci_gatt_tx_pool_available_event</a> (uint16_t Connection_Handle, uint16_t Available_Buffers)</td></tr>
<tr class="memdesc:ga709cad02cfa0756751380fce49915688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each time BLE FW stack raises the error code ble_status_insufficient_resources, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga709cad02cfa0756751380fce49915688" title="Each time BLE FW stack raises the error code ble_status_insufficient_resources, aci_gatt_tx_pool_avai...">aci_gatt_tx_pool_available_event()</a> is generated as soon as the available buffer size is greater than maximum ATT MTU.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga709cad02cfa0756751380fce49915688">More...</a><br /></td></tr>
<tr class="separator:ga709cad02cfa0756751380fce49915688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ffd81d9886695721dae7ec0af23dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gad1ffd81d9886695721dae7ec0af23dcc">aci_gatt_srv_confirmation_event</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gad1ffd81d9886695721dae7ec0af23dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the client has sent the confirmation to a previously sent indication.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#gad1ffd81d9886695721dae7ec0af23dcc">More...</a><br /></td></tr>
<tr class="separator:gad1ffd81d9886695721dae7ec0af23dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605aa417720a6d824eab04175a594d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga605aa417720a6d824eab04175a594d63">aci_gatt_srv_read_event</a> (uint16_t Connection_Handle, uint16_t Attribute_Handle, uint16_t Data_Offset)</td></tr>
<tr class="memdesc:ga605aa417720a6d824eab04175a594d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the BLE stack needs an attribute value to be returned to the peer, as a result of a remote read operation (Read By Type Request, Read Request, Read Blob Request, Read Multiple Request). After this event is received, <a class="el" href="group___g_a_t_t___commands.html#ga486a547dde23d36d6f316da221ebd8cc" title="Command to be given in response to aci_gatt_srv_read_event, aci_gatt_srv_write_event, aci_att_srv_prepare_write_req_event or aci_att_srv_exec_write_req_event. It ends the ATT transaction initiated by the remote client. ">aci_gatt_srv_resp()</a> must be used to send the response. This event is not generated if the read is requested on a characteristic or a descriptor which have an associated buffer handled by the stack (see ble_gatt_chr_def_t and ble_gatt_descr_def_t).  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga605aa417720a6d824eab04175a594d63">More...</a><br /></td></tr>
<tr class="separator:ga605aa417720a6d824eab04175a594d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bbf7481a91de286dd26ebeb26ac5801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1bbf7481a91de286dd26ebeb26ac5801">aci_gatt_srv_write_event</a> (uint16_t Connection_Handle, uint8_t Resp_Needed, uint16_t Attribute_Handle, uint16_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga1bbf7481a91de286dd26ebeb26ac5801"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the peer wants to write into a writable characteristic value or descriptor using a write request or command (Write Request, Write command, Signed Write command). If a response is needed, application must respond with an <a class="el" href="group___g_a_t_t___commands.html#ga486a547dde23d36d6f316da221ebd8cc" title="Command to be given in response to aci_gatt_srv_read_event, aci_gatt_srv_write_event, aci_att_srv_prepare_write_req_event or aci_att_srv_exec_write_req_event. It ends the ATT transaction initiated by the remote client. ">aci_gatt_srv_resp()</a>.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1bbf7481a91de286dd26ebeb26ac5801">More...</a><br /></td></tr>
<tr class="separator:ga1bbf7481a91de286dd26ebeb26ac5801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4745f97b9db51b216f148a26213a262a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4745f97b9db51b216f148a26213a262a">aci_att_srv_prepare_write_req_event</a> (uint16_t Connection_Handle, uint16_t Attribute_Handle, uint16_t Data_Offset, uint16_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga4745f97b9db51b216f148a26213a262a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when a prepare write request is received. Application should queue this request and execute or discard it only when a aci_att_srv_exec_write_req_event is received.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4745f97b9db51b216f148a26213a262a">More...</a><br /></td></tr>
<tr class="separator:ga4745f97b9db51b216f148a26213a262a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a26aca245c3ed736ba0138472756737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga6a26aca245c3ed736ba0138472756737">aci_att_srv_exec_write_req_event</a> (uint16_t Connection_Handle, uint8_t Flags)</td></tr>
<tr class="memdesc:ga6a26aca245c3ed736ba0138472756737"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when an execute write request is received from the peer. This happens when the client wants to write a long attribute (i.e. an attribute with a size greater than ATT_MTU -3) or more than one attribute in a single operation. The aci_gatt_srv_exec_write_resp command must be sent to give a response to the peer.  <a href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga6a26aca245c3ed736ba0138472756737">More...</a><br /></td></tr>
<tr class="separator:ga6a26aca245c3ed736ba0138472756737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80df69ea3d38af2a53d2cfcbb1e7d4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga80df69ea3d38af2a53d2cfcbb1e7d4fb">aci_l2cap_connection_update_resp_event</a> (uint16_t Connection_Handle, uint16_t Result)</td></tr>
<tr class="memdesc:ga80df69ea3d38af2a53d2cfcbb1e7d4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the master responds to the connection update request packet with a connection update response packet.  <a href="group___l2_c_a_p__events.html#ga80df69ea3d38af2a53d2cfcbb1e7d4fb">More...</a><br /></td></tr>
<tr class="separator:ga80df69ea3d38af2a53d2cfcbb1e7d4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c4474c3a23d14d93e9499e62a47ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga40c4474c3a23d14d93e9499e62a47ba9">aci_l2cap_proc_timeout_event</a> (uint16_t Connection_Handle, uint8_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga40c4474c3a23d14d93e9499e62a47ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the master does not respond to the connection update request packet with a connection update response packet or a command reject packet within 30 seconds.  <a href="group___l2_c_a_p__events.html#ga40c4474c3a23d14d93e9499e62a47ba9">More...</a><br /></td></tr>
<tr class="separator:ga40c4474c3a23d14d93e9499e62a47ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dee0c664b50509a3ca8477f45b8d5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga2dee0c664b50509a3ca8477f45b8d5db">aci_l2cap_connection_update_req_event</a> (uint16_t Connection_Handle, uint8_t Identifier, uint16_t L2CAP_Length, uint16_t Interval_Min, uint16_t Interval_Max, uint16_t Slave_Latency, uint16_t Timeout_Multiplier)</td></tr>
<tr class="memdesc:ga2dee0c664b50509a3ca8477f45b8d5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The event is given by the L2CAP layer when a connection update request is received from the slave. The upper layer which receives this event has to respond by sending a <a class="el" href="group___l2_c_a_p___commands.html#gaa603559ff3b65676a6d85aaf762dd2f3">aci_l2cap_connection_parameter_update_resp</a> command.  <a href="group___l2_c_a_p__events.html#ga2dee0c664b50509a3ca8477f45b8d5db">More...</a><br /></td></tr>
<tr class="separator:ga2dee0c664b50509a3ca8477f45b8d5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db37862731cc4a8599dbfa9af925036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga5db37862731cc4a8599dbfa9af925036">aci_l2cap_cfc_connection_event</a> (uint16_t Connection_Handle, uint8_t Event_Type, uint16_t Result, uint8_t Identifier, uint16_t SPSM, uint16_t CID, uint16_t Remote_CID, uint16_t Peer_MTU, uint16_t Peer_MPS, uint16_t Initial_Credits)</td></tr>
<tr class="memdesc:ga5db37862731cc4a8599dbfa9af925036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event generated when a request or a response is received from the peer to create an L2CAP channel.  <a href="group___l2_c_a_p__events.html#ga5db37862731cc4a8599dbfa9af925036">More...</a><br /></td></tr>
<tr class="separator:ga5db37862731cc4a8599dbfa9af925036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacacb50049bfcf6249ea6dda720471fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#gacacb50049bfcf6249ea6dda720471fdc">aci_l2cap_disconnection_complete_event</a> (uint16_t Connection_Handle, uint16_t CID)</td></tr>
<tr class="memdesc:gacacb50049bfcf6249ea6dda720471fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event raised when an L2CAP channel using LE Credit Based Flow Control mode is terminated.  <a href="group___l2_c_a_p__events.html#gacacb50049bfcf6249ea6dda720471fdc">More...</a><br /></td></tr>
<tr class="separator:gacacb50049bfcf6249ea6dda720471fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22354b4944ee8d4509e3529b85f4704b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga22354b4944ee8d4509e3529b85f4704b">aci_l2cap_flow_control_credit_event</a> (uint16_t Connection_Handle, uint16_t CID, uint16_t TX_Credits, uint16_t TX_Credit_Balance)</td></tr>
<tr class="memdesc:ga22354b4944ee8d4509e3529b85f4704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event raised when an L2CAP_FLOW_CONTROL_CREDIT_IND is received from the peer, which means that it is capable of receiving additional K-frames (for example after it has processed one or more K-frames) in LE Credit Based Flow Control.  <a href="group___l2_c_a_p__events.html#ga22354b4944ee8d4509e3529b85f4704b">More...</a><br /></td></tr>
<tr class="separator:ga22354b4944ee8d4509e3529b85f4704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b7e90e2919ad37433982cd8f433574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga49b7e90e2919ad37433982cd8f433574">aci_l2cap_command_reject_event</a> (uint16_t Connection_Handle, uint8_t Identifier, uint16_t Reason, uint8_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga49b7e90e2919ad37433982cd8f433574"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the master rejects a L2CAP request.  <a href="group___l2_c_a_p__events.html#ga49b7e90e2919ad37433982cd8f433574">More...</a><br /></td></tr>
<tr class="separator:ga49b7e90e2919ad37433982cd8f433574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc5b61b066daa4cf0572195e7a74c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga8fc5b61b066daa4cf0572195e7a74c34">aci_l2cap_sdu_data_tx_event</a> (uint16_t Connection_Handle, uint16_t CID, uint16_t SDU_Length, void *SDU_Data_Buffer, uint16_t TX_Credit_Balance)</td></tr>
<tr class="memdesc:ga8fc5b61b066daa4cf0572195e7a74c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event raised when an SDU to be transmitted has been processed by the local L2CAP layer entity and buffer can now be freed by application.  <a href="group___l2_c_a_p__events.html#ga8fc5b61b066daa4cf0572195e7a74c34">More...</a><br /></td></tr>
<tr class="separator:ga8fc5b61b066daa4cf0572195e7a74c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd9abd62ebe052adfbab7b78f811280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p__events.html#ga3cd9abd62ebe052adfbab7b78f811280">aci_l2cap_sdu_data_rx_event</a> (uint16_t Connection_Handle, uint16_t CID, uint16_t RX_Credit_Balance, uint16_t SDU_Length)</td></tr>
<tr class="memdesc:ga3cd9abd62ebe052adfbab7b78f811280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event raised when an SDU has been received. Use <a class="el" href="group___l2_c_a_p___commands.html#gad231077d2254aec34f04f6371cddf4f2" title="Function to be used to extract an SDU from receving buffer. ">aci_l2cap_extract_sdu_data()</a> to extract SDU from buffer.  <a href="group___l2_c_a_p__events.html#ga3cd9abd62ebe052adfbab7b78f811280">More...</a><br /></td></tr>
<tr class="separator:ga3cd9abd62ebe052adfbab7b78f811280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be9dbe2c8fc3758a12ee9c5e8a95d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__events.html#ga5be9dbe2c8fc3758a12ee9c5e8a95d86">aci_hal_end_of_radio_activity_event</a> (uint8_t Last_State, uint8_t Next_State, uint32_t Next_State_SysTime)</td></tr>
<tr class="memdesc:ga5be9dbe2c8fc3758a12ee9c5e8a95d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated when the device completes a radio activity and provide information when a new radio activity will be performed. Information provided includes type of radio activity and absolute time in system ticks when a new radio activity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activities. A command <a class="el" href="group___h_a_l___commands.html#ga120ca17ceac401485f6281f2037126b0">aci_hal_set_radio_activity_mask</a> is provided to enable radio activity events of user interests, by default no events are enabled. User should take into account that enabling radio events in application with intense radio activity could lead to a fairly high rate of events generated. Application use cases includes synchronizing notification with connection interval, switching antenna at the end of advertising or performing flash erase operation while radio is idle.  <a href="group___h_a_l__events.html#ga5be9dbe2c8fc3758a12ee9c5e8a95d86">More...</a><br /></td></tr>
<tr class="separator:ga5be9dbe2c8fc3758a12ee9c5e8a95d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55212b6630bad1d35b5b21dfd24eb1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__events.html#ga55212b6630bad1d35b5b21dfd24eb1b7">aci_hal_scan_req_report_event</a> (int8_t RSSI, uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:ga55212b6630bad1d35b5b21dfd24eb1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is reported to the application after a scan request is received and a scan reponse is scheduled to be transmitted.  <a href="group___h_a_l__events.html#ga55212b6630bad1d35b5b21dfd24eb1b7">More...</a><br /></td></tr>
<tr class="separator:ga55212b6630bad1d35b5b21dfd24eb1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e611292f1bb2f1b53304bd222352f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__events.html#ga32e611292f1bb2f1b53304bd222352f3">aci_hal_fw_error_event</a> (uint8_t FW_Error_Type, uint8_t Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga32e611292f1bb2f1b53304bd222352f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is generated to report firmware error informations.  <a href="group___h_a_l__events.html#ga32e611292f1bb2f1b53304bd222352f3">More...</a><br /></td></tr>
<tr class="separator:ga32e611292f1bb2f1b53304bd222352f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18574d3efa063a077a5ac959884b4d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l__events.html#ga18574d3efa063a077a5ac959884b4d36">aci_hal_adv_scan_resp_data_update_event</a> (void *Old_Pointer, void *New_Pointer)</td></tr>
<tr class="memdesc:ga18574d3efa063a077a5ac959884b4d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is raised when the advertising or scan response data pointer provided by application becomes active or inactive.  <a href="group___h_a_l__events.html#ga18574d3efa063a077a5ac959884b4d36">More...</a><br /></td></tr>
<tr class="separator:ga18574d3efa063a077a5ac959884b4d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for Bluetooth Low Energy stack events callbacks Autogenerated files, do not edit!! </p>
<dl class="section author"><dt>Author</dt><dd>AMS - RF Application team </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01 March 2022 </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="bluenrg__lp__events_8h_source.html">bluenrg_lp_events.h</a>.</p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2022 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
