<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-BLE Stack Library APIs, events callbacks &amp; application framework: C:/GIT_vobs/bluenrglp-sdk/Middlewares/ST/Bluetooth_LE/inc/bluenrg_lp_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="STcustom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-BLE Stack Library APIs, events callbacks &amp; application framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0ef013aab68a7502f6b7c1d484d85bd6.html">Middlewares</a></li><li class="navelem"><a class="el" href="dir_1ad7b503f206431c444b3d2f6d492083.html">ST</a></li><li class="navelem"><a class="el" href="dir_da75705656b56beda367ff7728100b5b.html">Bluetooth_LE</a></li><li class="navelem"><a class="el" href="dir_37922c7fc6613c18028bb58b4708e6cf.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg_lp_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for Bluetooth Low Energy stack APIs. Autogenerated files, do not edit!!  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bluenrg__lp__gatt_8h_source.html">bluenrg_lp_gatt.h</a>&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ble__status_8h_source.html">ble_status.h</a>&quot;</code><br />
<code>#include &quot;system_util.h&quot;</code><br />
</div>
<p><a href="bluenrg__lp__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_advertising___set___parameters__t__s.html">Advertising_Set_Parameters_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_extended___scan___parameters__t__s.html">Extended_Scan_Parameters_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_extended___create___connection___parameters__t__s.html">Extended_Create_Connection_Parameters_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_list___entry__t__s.html">List_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_u_u_i_d__t__s.html">UUID_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_handle___entry__t__s.html">Handle_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a008e8bf5b0efc0138300743128635701"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_advertising___set___parameters__t__s.html">Advertising_Set_Parameters_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#a008e8bf5b0efc0138300743128635701">Advertising_Set_Parameters_t</a></td></tr>
<tr class="separator:a008e8bf5b0efc0138300743128635701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb3b811389de79a4b76f9e2064bf681"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_extended___scan___parameters__t__s.html">Extended_Scan_Parameters_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#adfb3b811389de79a4b76f9e2064bf681">Extended_Scan_Parameters_t</a></td></tr>
<tr class="separator:adfb3b811389de79a4b76f9e2064bf681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42962d78b42f3d482cf1da22b8f5c6e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_extended___create___connection___parameters__t__s.html">Extended_Create_Connection_Parameters_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#ab42962d78b42f3d482cf1da22b8f5c6e">Extended_Create_Connection_Parameters_t</a></td></tr>
<tr class="separator:ab42962d78b42f3d482cf1da22b8f5c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac381829daea9db7081e9594c3a5322ea"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a></td></tr>
<tr class="separator:ac381829daea9db7081e9594c3a5322ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6cc258fb3bbb4a398ce7b4c76cca17"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_list___entry__t__s.html">List_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#a8a6cc258fb3bbb4a398ce7b4c76cca17">List_Entry_t</a></td></tr>
<tr class="separator:a8a6cc258fb3bbb4a398ce7b4c76cca17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd9bdce9ac1181c683947604eb96e44"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_u_u_i_d__t__s.html">UUID_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a></td></tr>
<tr class="separator:a2bd9bdce9ac1181c683947604eb96e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e49c7305b7ff1d34fec3f2e4bcf42b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_handle___entry__t__s.html">Handle_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg__lp__api_8h.html#a46e49c7305b7ff1d34fec3f2e4bcf42b">Handle_Entry_t</a></td></tr>
<tr class="separator:a46e49c7305b7ff1d34fec3f2e4bcf42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaec954b9149e7996e0d09fc6a5a712e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaaec954b9149e7996e0d09fc6a5a712e7">hci_disconnect</a> (uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:gaaec954b9149e7996e0d09fc6a5a712e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___h_c_i___commands.html#gaaec954b9149e7996e0d09fc6a5a712e7">hci_disconnect</a> is used to terminate an existing connection. The Connection_Handle command parameter indicates which connection is to be disconnected. The Reason command parameter indicates the reason for ending the connection. The remote Controller will receive the Reason command parameter in the <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event. All synchronous connections on a physical link should be disconnected before the ACL connection on the same physical connection is disconnected. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.1.6) It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event, system could save important information in non volatile memory.  <a href="group___h_c_i___commands.html#gaaec954b9149e7996e0d09fc6a5a712e7">More...</a><br /></td></tr>
<tr class="separator:gaaec954b9149e7996e0d09fc6a5a712e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777968e990af76a7880dda023015e287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga777968e990af76a7880dda023015e287">hci_read_remote_version_information</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga777968e990af76a7880dda023015e287"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command will obtain the values for the version information for the remote device identified by the Connection_Handle parameter. The Connection_Handle must be a Connection_Handle for an ACL or LE connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.1.23)  <a href="group___h_c_i___commands.html#ga777968e990af76a7880dda023015e287">More...</a><br /></td></tr>
<tr class="separator:ga777968e990af76a7880dda023015e287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b89a8125281800909d9ff99fcb6e5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga6b89a8125281800909d9ff99fcb6e5e0">hci_set_event_mask</a> (uint8_t Event_Mask[8])</td></tr>
<tr class="memdesc:ga6b89a8125281800909d9ff99fcb6e5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Set_Event_Mask command is used to control which events are generated by the HCI for the Host. If the bit in the Event_Mask is set to a one, then the event associated with that bit will be enabled. For an LE Controller, the LE Meta Event bit in the Event_Mask shall enable or disable all LE events in the LE Meta Event (see Section 7.7.65). The Host has to deal with each event that occurs. The event mask allows the Host to control how much it is interrupted. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.1)  <a href="group___h_c_i___commands.html#ga6b89a8125281800909d9ff99fcb6e5e0">More...</a><br /></td></tr>
<tr class="separator:ga6b89a8125281800909d9ff99fcb6e5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf415dc665ccc3bd6b6b2ae9557830d48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaf415dc665ccc3bd6b6b2ae9557830d48">hci_read_transmit_power_level</a> (uint16_t Connection_Handle, uint8_t Type, int8_t *Transmit_Power_Level)</td></tr>
<tr class="memdesc:gaf415dc665ccc3bd6b6b2ae9557830d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the values for the Transmit_Power_Level parameter for the specified Connection_Handle. The Connection_Handle shall be a Connection_Handle for an ACL connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.35)  <a href="group___h_c_i___commands.html#gaf415dc665ccc3bd6b6b2ae9557830d48">More...</a><br /></td></tr>
<tr class="separator:gaf415dc665ccc3bd6b6b2ae9557830d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dee06662f806483c04ed2ded4eefc73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga1dee06662f806483c04ed2ded4eefc73">hci_set_event_mask_page_2</a> (uint8_t Event_Mask_Page_2[8])</td></tr>
<tr class="memdesc:ga1dee06662f806483c04ed2ded4eefc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_Set_Event_Mask_Page_2 command is used to control which events are generated by the HCI for the Host. The Event_Mask_Page_2 is a logical extension to the Event_Mask parameter of the HCI_Set_Event_Mask command. If the bit in the Event_Mask_Page_2 is set to a one, then the event associated with that bit shall be enabled. The event mask allows the Host to control how much it is interrupted. The Controller shall ignore those bits which are reserved for future use or represent events which it does not support. If the Host sets any of these bits to 1, the Controller shall act as if they were set to 0.  <a href="group___h_c_i___commands.html#ga1dee06662f806483c04ed2ded4eefc73">More...</a><br /></td></tr>
<tr class="separator:ga1dee06662f806483c04ed2ded4eefc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ad734817093c45c3cb6e2f6c79f2b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga08ad734817093c45c3cb6e2f6c79f2b2">hci_read_authenticated_payload_timeout</a> (uint16_t Connection_Handle, uint16_t *Authenticated_Payload_Timeout)</td></tr>
<tr class="memdesc:ga08ad734817093c45c3cb6e2f6c79f2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the Authenticated_Payload_Timeout parameter in the Primary Controller on the specified Connection_Handle.  <a href="group___h_c_i___commands.html#ga08ad734817093c45c3cb6e2f6c79f2b2">More...</a><br /></td></tr>
<tr class="separator:ga08ad734817093c45c3cb6e2f6c79f2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55668c675515bb98be916934c187dcbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga55668c675515bb98be916934c187dcbc">hci_write_authenticated_payload_timeout</a> (uint16_t Connection_Handle, uint16_t Authenticated_Payload_Timeout)</td></tr>
<tr class="memdesc:ga55668c675515bb98be916934c187dcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command writes the Authenticated_Payload_Timeout parameter in the Primary Controller for the specified Connection_Handle. The Authenticated_Payload_Timeout shall be equal to or greater than connInterval * (1 + connSlaveLatency). The Link Layer will use this parameter to determine when to use the LE ping sequence.  <a href="group___h_c_i___commands.html#ga55668c675515bb98be916934c187dcbc">More...</a><br /></td></tr>
<tr class="separator:ga55668c675515bb98be916934c187dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69241ad34714d9ee7114cd7f326bd139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga69241ad34714d9ee7114cd7f326bd139">hci_read_local_version_information</a> (uint8_t *HCI_Version, uint16_t *HCI_Revision, uint8_t *LMP_PAL_Version, uint16_t *Manufacturer_Name, uint16_t *LMP_PAL_Subversion)</td></tr>
<tr class="memdesc:ga69241ad34714d9ee7114cd7f326bd139"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the values for the version information for the local Controller. The HCI Version information defines the version information of the HCI layer. The LMP/PAL Version information defines the version of the LMP or PAL. The Manufacturer_Name information indicates the manufacturer of the local device. The HCI Revision and LMP/PAL Subversion are implementation dependent. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.1)  <a href="group___h_c_i___commands.html#ga69241ad34714d9ee7114cd7f326bd139">More...</a><br /></td></tr>
<tr class="separator:ga69241ad34714d9ee7114cd7f326bd139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ee61943c3a66eabf617b73a2faf93a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga04ee61943c3a66eabf617b73a2faf93a">hci_read_local_supported_commands</a> (uint8_t Supported_Commands[64])</td></tr>
<tr class="memdesc:ga04ee61943c3a66eabf617b73a2faf93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the list of HCI commands supported for the local Controller. This command shall return the Supported_Commands configuration parameter. It is implied that if a command is listed as supported, the feature underlying that command is also supported. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.2)  <a href="group___h_c_i___commands.html#ga04ee61943c3a66eabf617b73a2faf93a">More...</a><br /></td></tr>
<tr class="separator:ga04ee61943c3a66eabf617b73a2faf93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728e6ab414a1750b739b80cd6b0d6969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga728e6ab414a1750b739b80cd6b0d6969">hci_read_local_supported_features</a> (uint8_t LMP_Features[8])</td></tr>
<tr class="memdesc:ga728e6ab414a1750b739b80cd6b0d6969"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests a list of the supported features for the local Controller. This command will return a list of the LMP features. For details see Part C, Link Manager Protocol Specification on page 227. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.3)  <a href="group___h_c_i___commands.html#ga728e6ab414a1750b739b80cd6b0d6969">More...</a><br /></td></tr>
<tr class="separator:ga728e6ab414a1750b739b80cd6b0d6969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4c0e41e5144a687ba989255d00df82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga2d4c0e41e5144a687ba989255d00df82">hci_read_bd_addr</a> (uint8_t BD_ADDR[6])</td></tr>
<tr class="memdesc:ga2d4c0e41e5144a687ba989255d00df82"><td class="mdescLeft">&#160;</td><td class="mdescRight">On an LE Controller, this command shall read the Public Device Address as defined in [Vol 6] Part B, Section 1.3, Device Address. If this Controller does not have a Public Device Address, the value 0x000000000000 shall be returned. On an LE Controller, the public address shall be the same as the BD_ADDR. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.6)  <a href="group___h_c_i___commands.html#ga2d4c0e41e5144a687ba989255d00df82">More...</a><br /></td></tr>
<tr class="separator:ga2d4c0e41e5144a687ba989255d00df82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ba180d5cf53157c4f999eceeb6b796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaa2ba180d5cf53157c4f999eceeb6b796">hci_read_rssi</a> (uint16_t Connection_Handle, int8_t *RSSI)</td></tr>
<tr class="memdesc:gaa2ba180d5cf53157c4f999eceeb6b796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the Received Signal Strength Indication (RSSI) value from a Controller. For an LE transport, a Connection_Handle is used as the Handle command parameter and return parameter. The meaning of the RSSI metric is an absolute receiver signal strength value in dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric shall be set to 127. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.5.4)  <a href="group___h_c_i___commands.html#gaa2ba180d5cf53157c4f999eceeb6b796">More...</a><br /></td></tr>
<tr class="separator:gaa2ba180d5cf53157c4f999eceeb6b796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0533490da57a99b0a7f4c6eacd282ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga0533490da57a99b0a7f4c6eacd282ed3">hci_le_set_event_mask</a> (uint8_t LE_Event_Mask[8])</td></tr>
<tr class="memdesc:ga0533490da57a99b0a7f4c6eacd282ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Event_Mask command is used to control which LE events are generated by the HCI for the Host. If the bit in the LE_Event_Mask is set to a one, then the event associated with that bit will be enabled. The Host has to deal with each event that is generated by an LE Controller. The event mask allows the Host to control which events will interrupt it. For LE events to be generated, the LE Meta-Event bit in the Event_Mask shall also be set. If that bit is not set, then LE events shall not be generated, regardless of how the LE_Event_Mask is set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.1)  <a href="group___h_c_i___commands.html#ga0533490da57a99b0a7f4c6eacd282ed3">More...</a><br /></td></tr>
<tr class="separator:ga0533490da57a99b0a7f4c6eacd282ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f83f723bb317c6e783ec099d37f4c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga0f83f723bb317c6e783ec099d37f4c10">hci_le_read_buffer_size</a> (uint16_t *HC_LE_ACL_Data_Packet_Length, uint8_t *HC_Total_Num_LE_ACL_Data_Packets)</td></tr>
<tr class="memdesc:ga0f83f723bb317c6e783ec099d37f4c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Buffer_Size command is used to read the maximum size of the data portion of HCI LE ACL Data Packets sent from the Host to the Controller. The Host will segment the data transmitted to the Controller according to these values, so that the HCI Data Packets will contain data with up to this size. The LE_Read_Buffer_Size command also returns the total number of HCI LE ACL Data Packets that can be stored in the data buffers of the Controller. The LE_Read_Buffer_Size command must be issued by the Host before it sends any data to an LE Controller (see Section 4.1.1). If the Controller returns a length value of zero, the Host shall use the Read_Buffer_Size command to determine the size of the data buffers Note: Both the Read_Buffer_Size and LE_Read_Buffer_Size commands may return buffer length and number of packets parameter values that are nonzero. The HC_LE_ACL_Data_Packet_Length return parameter shall be used to determine the size of the L2CAP PDU segments contained in ACL Data Packets, which are transferred from the Host to the Controller to be broken up into packets by the Link Layer. Both the Host and the Controller shall support command and event packets, where the data portion (excluding header) contained in the packets is 255 octets in size. The HC_Total_Num_LE_ACL_Data_Packets return parameter contains the total number of HCI ACL Data Packets that can be stored in the data buffers of the Controller. The Host determines how the buffers are to be divided between different Connection Handles. Note: The HC_LE_ACL_Data_Packet_Length return parameter does not include the length of the HCI Data Packet header. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.2)  <a href="group___h_c_i___commands.html#ga0f83f723bb317c6e783ec099d37f4c10">More...</a><br /></td></tr>
<tr class="separator:ga0f83f723bb317c6e783ec099d37f4c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026e8ea5854901b01d07c5f903b8a0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga026e8ea5854901b01d07c5f903b8a0b1">hci_le_read_local_supported_features</a> (uint8_t LE_Features[8])</td></tr>
<tr class="memdesc:ga026e8ea5854901b01d07c5f903b8a0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests the list of the supported LE features for the Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.3)  <a href="group___h_c_i___commands.html#ga026e8ea5854901b01d07c5f903b8a0b1">More...</a><br /></td></tr>
<tr class="separator:ga026e8ea5854901b01d07c5f903b8a0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a2ba5dba449e423e89d85e5243c9b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga46a2ba5dba449e423e89d85e5243c9b0">hci_le_set_random_address</a> (uint8_t Random_Address[6])</td></tr>
<tr class="memdesc:ga46a2ba5dba449e423e89d85e5243c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Random_Address command is used by the Host to set the LE Random Device Address in the Controller (see [Vol 6] Part B, Section 1.3). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.4)  <a href="group___h_c_i___commands.html#ga46a2ba5dba449e423e89d85e5243c9b0">More...</a><br /></td></tr>
<tr class="separator:ga46a2ba5dba449e423e89d85e5243c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efb6498e4b6d8cc17c93dd9b16fdca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga8efb6498e4b6d8cc17c93dd9b16fdca1">hci_le_set_advertising_parameters</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Advertising_Type, uint8_t Own_Address_Type, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Advertising_Channel_Map, uint8_t Advertising_Filter_Policy)</td></tr>
<tr class="memdesc:ga8efb6498e4b6d8cc17c93dd9b16fdca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Advertising_Parameters command is used by the Host to set the advertising parameters. The Advertising_Interval_Min shall be less than or equal to the Advertising_Interval_Max. The Advertising_Interval_Min and Advertising_Interval_Max should not be the same value to enable the Controller to determine the best advertising interval given other activities. For high duty cycle directed advertising, i.e. when Advertising_Type is 0x01 (ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and Advertising_Interval_Max parameters are not used and shall be ignored. The Advertising_Type is used to determine the packet type that is used for advertising when advertising is enabled. Own_Address_Type parameter indicates the type of address being used in the advertising packets. If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter contains the peer's Identity Address and the Peer_Address_Type parameter contains the Peer's Identity Type (i.e. 0x00 or 0x01). These parameters are used to locate the corresponding local IRK in the resolving list; this IRK is used to generate the own address used in the advertisement. If directed advertising is performed, i.e. when Advertising_Type is set to 0x01 (ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then the Peer_Address_Type and Peer_Address shall be valid. If Own_Address_Type equals 0x02 or 0x03, the Controller generates the peer's Resolvable Private Address using the peer's IRK corresponding to the peer's Identity Address contained in the Peer_Address parameter and peer's Identity Address Type (i.e. 0x00 or 0x01) contained in the Peer_Address_Type parameter. The Advertising_Channel_Map is a bit field that indicates the advertising channels that shall be used when transmitting advertising packets. At least one channel bit shall be set in the Advertising_Channel_Map parameter. The Advertising_Filter_Policy parameter shall be ignored when directed advertising is enabled. The Host shall not issue this command when advertising is enabled in the Controller; if it is the Command Disallowed error code shall be used. If the advertising interval range provided by the Host (Advertising_Interval_Min, Advertising_Interval_Max) is outside the advertising interval range supported by the Controller, then the Controller shall return the Unsupported Feature or Parameter Value (0x11) error code.  <a href="group___h_c_i___commands.html#ga8efb6498e4b6d8cc17c93dd9b16fdca1">More...</a><br /></td></tr>
<tr class="separator:ga8efb6498e4b6d8cc17c93dd9b16fdca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c4e340f947f0d408391bb33346ac97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga92c4e340f947f0d408391bb33346ac97">hci_le_read_advertising_channel_tx_power</a> (int8_t *Transmit_Power_Level)</td></tr>
<tr class="memdesc:ga92c4e340f947f0d408391bb33346ac97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Advertising_Channel_Tx_Power command is used by the Host to read the transmit power level used for LE advertising channel packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.6)  <a href="group___h_c_i___commands.html#ga92c4e340f947f0d408391bb33346ac97">More...</a><br /></td></tr>
<tr class="separator:ga92c4e340f947f0d408391bb33346ac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac812f3568327595b0e0a01af329a1783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gac812f3568327595b0e0a01af329a1783">hci_le_set_advertising_enable</a> (uint8_t Advertising_Enable)</td></tr>
<tr class="memdesc:gac812f3568327595b0e0a01af329a1783"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Advertise_Enable command is used to request the Controller to start or stop advertising. The Controller manages the timing of advertisements as per the advertising parameters given in the LE_Set_Advertising_Parameters command. The Controller shall continue advertising until the Host issues an LE_Set_Advertise_Enable command with Advertising_Enable set to 0x00 (Advertising is disabled) or until a connection is created or until the Advertising is timed out due to high duty cycle Directed Advertising. In these cases, advertising is then disabled. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.9)  <a href="group___h_c_i___commands.html#gac812f3568327595b0e0a01af329a1783">More...</a><br /></td></tr>
<tr class="separator:gac812f3568327595b0e0a01af329a1783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf827cd334e2d37a4a75c73714b99bdab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaf827cd334e2d37a4a75c73714b99bdab">hci_le_set_scan_parameters</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy)</td></tr>
<tr class="memdesc:gaf827cd334e2d37a4a75c73714b99bdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Scan_Parameters command is used to set the scan parameters. The LE_Scan_Type parameter controls the type of scan to perform. The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the Controller should scan (See [Vol 6] Part B, Section 4.5.3). The LE_Scan_Window parameter shall always be set to a value smaller or equal to the value set for the LE_Scan_Interval parameter. If they are set to the same value scanning should be run continuously. The Own_Address_Type parameter determines the address used (Public or Random Device Address) when performing active scan. The Host shall not issue this command when scanning is enabled in the Controller; if it is the Command Disallowed error code shall be used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.10)  <a href="group___h_c_i___commands.html#gaf827cd334e2d37a4a75c73714b99bdab">More...</a><br /></td></tr>
<tr class="separator:gaf827cd334e2d37a4a75c73714b99bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c0aeafb85268e79c42c04ce27c5a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaa5c0aeafb85268e79c42c04ce27c5a65">hci_le_set_scan_enable</a> (uint8_t LE_Scan_Enable, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:gaa5c0aeafb85268e79c42c04ce27c5a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Scan_Enable command is used to start scanning. Scanning is used to discover advertising devices nearby. The Filter_Duplicates parameter controls whether the Link Layer shall filter duplicate advertising reports to the Host, or if the Link Layer should generate advertising reports for each packet received. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.11)  <a href="group___h_c_i___commands.html#gaa5c0aeafb85268e79c42c04ce27c5a65">More...</a><br /></td></tr>
<tr class="separator:gaa5c0aeafb85268e79c42c04ce27c5a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78779c84a0d1f711677c135b4dcafe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gab78779c84a0d1f711677c135b4dcafe9">hci_le_create_connection</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Initiator_Filter_Policy, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:gab78779c84a0d1f711677c135b4dcafe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Create_Connection command is used to create a Link Layer connection to a connectable advertiser. The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the Controller should scan. The LE_Scan_Window parameter shall be set to a value smaller or equal to the value set for the LE_Scan_Interval parameter. If both are set to the same value, scanning should run continuously. The Initiator_Filter_Policy is used to determine whether the White List is used. If the White List is not used, the Peer_Address_Type and the Peer_Address parameters specify the address type and address of the advertising device to connect to. The Link Layer shall set the address in the CONNECT_REQ packets to either the Public Device Address or the Random Device Addressed based on the Own_Address_Type parameter. The Conn_Interval_Min and Conn_Interval_Max parameters define the minimum and maximum allowed connection interval. The Conn_Interval_Min parameter shall not be greater than the Conn_Interval_Max parameter. The Conn_Latency parameter defines the maximum allowed connection latency (see [Vol 6] Part B, Section 4.5.1). The Supervision_Timeout parameter defines the link supervision timeout for the connection. The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds. (See [Vol 6] Part B, Section 4.5.2). The Minimum_CE_Length and Maximum_CE_Length parameters are informative parameters providing the Controller with the expected minimum and maximum length of the connection events. The Minimum_CE_Length parameter shall be less than or equal to the Maximum_CE_Length parameter. The Host shall not issue this command when another LE_Create_Connection is pending in the Controller; if this does occur the Controller shall return the Command Disallowed error code shall be used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.12)  <a href="group___h_c_i___commands.html#gab78779c84a0d1f711677c135b4dcafe9">More...</a><br /></td></tr>
<tr class="separator:gab78779c84a0d1f711677c135b4dcafe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2e81b045a7be0ce2eb41b5b5f7b7c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga2b2e81b045a7be0ce2eb41b5b5f7b7c2">hci_le_create_connection_cancel</a> (void)</td></tr>
<tr class="memdesc:ga2b2e81b045a7be0ce2eb41b5b5f7b7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Create_Connection_Cancel command is used to cancel the LE_Create_Connection command. This command shall only be issued after the LE_Create_Connection command has been issued, a Command Status event has been received for the LE Create Connection command and before the LE Connection Complete event. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.13)  <a href="group___h_c_i___commands.html#ga2b2e81b045a7be0ce2eb41b5b5f7b7c2">More...</a><br /></td></tr>
<tr class="separator:ga2b2e81b045a7be0ce2eb41b5b5f7b7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b286059844d2383e7b4b03a6a886d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga87b286059844d2383e7b4b03a6a886d0">hci_le_read_white_list_size</a> (uint8_t *White_List_Size)</td></tr>
<tr class="memdesc:ga87b286059844d2383e7b4b03a6a886d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_White_List_Size command is used to read the total number of white list entries that can be stored in the Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.14)  <a href="group___h_c_i___commands.html#ga87b286059844d2383e7b4b03a6a886d0">More...</a><br /></td></tr>
<tr class="separator:ga87b286059844d2383e7b4b03a6a886d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb89c4e1db387d70786fd8e95f8f0a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gadb89c4e1db387d70786fd8e95f8f0a2f">hci_le_clear_white_list</a> (void)</td></tr>
<tr class="memdesc:gadb89c4e1db387d70786fd8e95f8f0a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Clear_White_List command is used to clear the white list stored in the Controller. This command can be used at any time except when: - the advertising filter policy uses the white list and advertising is enabled. - the scanning filter policy uses the white list and scanning is enabled. - the initiator filter policy uses the white list and an LE_Create_Connection command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.15)  <a href="group___h_c_i___commands.html#gadb89c4e1db387d70786fd8e95f8f0a2f">More...</a><br /></td></tr>
<tr class="separator:gadb89c4e1db387d70786fd8e95f8f0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab010359d138490774dc0495499e52383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gab010359d138490774dc0495499e52383">hci_le_add_device_to_white_list</a> (uint8_t Address_Type, uint8_t Address[6])</td></tr>
<tr class="memdesc:gab010359d138490774dc0495499e52383"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Add_Device_To_White_List command is used to add a single device to the white list stored in the Controller. This command can be used at any time except when: - the advertising filter policy uses the white list and advertising is enabled. - the scanning filter policy uses the white list and scanning is enabled. - the initiator filter policy uses the white list and a create connection command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.16)  <a href="group___h_c_i___commands.html#gab010359d138490774dc0495499e52383">More...</a><br /></td></tr>
<tr class="separator:gab010359d138490774dc0495499e52383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a0d6443a7de4b6e9780a594eb161c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga91a0d6443a7de4b6e9780a594eb161c8">hci_le_remove_device_from_white_list</a> (uint8_t Address_Type, uint8_t Address[6])</td></tr>
<tr class="memdesc:ga91a0d6443a7de4b6e9780a594eb161c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Remove_Device_From_White_List command is used to remove a single device from the white list stored in the Controller. This command can be used at any time except when: - the advertising filter policy uses the white list and advertising is enabled. - the scanning filter policy uses the white list and scanning is enabled. - the initiator filter policy uses the white list and a create connection command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.17)  <a href="group___h_c_i___commands.html#ga91a0d6443a7de4b6e9780a594eb161c8">More...</a><br /></td></tr>
<tr class="separator:ga91a0d6443a7de4b6e9780a594eb161c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1c0e2aede814f82bab64c843710eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ga0b1c0e2aede814f82bab64c843710eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Connection_Update command is used to change the Link Layer connection parameters of a connection. This command is supported only on master side. The Conn_Interval_Min and Conn_Interval_Max parameters are used to define the minimum and maximum allowed connection interval. The Conn_Interval_Min parameter shall not be greater than the Conn_Interval_Max parameter. The Conn_Latency parameter shall define the maximum allowed connection latency. The Supervision_Timeout parameter shall define the link supervision timeout for the LE link. The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds. The Minimum_CE_Length and Maximum_CE_Length are information parameters providing the Controller with a hint about the expected minimum and maximum length of the connection events. The Minimum_CE_Length shall be less than or equal to the Maximum_CE_Length. The actual parameter values selected by the Link Layer may be different from the parameter values provided by the Host through this command. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.18)  <a href="group___h_c_i___commands.html#ga0b1c0e2aede814f82bab64c843710eb8">More...</a><br /></td></tr>
<tr class="separator:ga0b1c0e2aede814f82bab64c843710eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142fa5ba5e21623a9a52b7d9bdbda47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga142fa5ba5e21623a9a52b7d9bdbda47d">hci_le_set_host_channel_classification</a> (uint8_t LE_Channel_Map[5])</td></tr>
<tr class="memdesc:ga142fa5ba5e21623a9a52b7d9bdbda47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Host_Channel_Classification command allows the Host to specify a channel classification for the data, secondary advertising, periodic, and isochronous physical channels based on its local information. This classification persists until overwritten with a subsequent HCI_LE_Set_Host_Channel_Classification command or until the Controller is reset using the HCI_Reset command. If this command is used, the Host should send it within 10 seconds of knowing that the channel classification has changed. The interval between two successive commands sent shall be at least one second.  <a href="group___h_c_i___commands.html#ga142fa5ba5e21623a9a52b7d9bdbda47d">More...</a><br /></td></tr>
<tr class="separator:ga142fa5ba5e21623a9a52b7d9bdbda47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf667e21884f888373c93b0eb7025c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gabf667e21884f888373c93b0eb7025c58">hci_le_read_channel_map</a> (uint16_t Connection_Handle, uint8_t LE_Channel_Map[5])</td></tr>
<tr class="memdesc:gabf667e21884f888373c93b0eb7025c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Channel_Map command returns the current Channel_Map for the specified Connection_Handle. The returned value indicates the state of the Channel_Map specified by the last transmitted or received Channel_Map (in a CONNECT_REQ or LL_CHANNEL_MAP_REQ message) for the specified Connection_Handle, regardless of whether the Master has received an acknowledgement. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.20)  <a href="group___h_c_i___commands.html#gabf667e21884f888373c93b0eb7025c58">More...</a><br /></td></tr>
<tr class="separator:gabf667e21884f888373c93b0eb7025c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159dbfb800361c7340b9dca5bb5ae48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga159dbfb800361c7340b9dca5bb5ae48c">hci_le_read_remote_used_features</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga159dbfb800361c7340b9dca5bb5ae48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests a list of the used LE features from the remote device. This command shall return a list of the used LE features. For details see [Vol 6] Part B, Section 4.6. This command may be issued on both the master and slave. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.21)  <a href="group___h_c_i___commands.html#ga159dbfb800361c7340b9dca5bb5ae48c">More...</a><br /></td></tr>
<tr class="separator:ga159dbfb800361c7340b9dca5bb5ae48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37d8821ebd604515ef02ba84daf5edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gad37d8821ebd604515ef02ba84daf5edb">hci_le_encrypt</a> (uint8_t Key[16], uint8_t Plaintext_Data[16], uint8_t Encrypted_Data[16])</td></tr>
<tr class="memdesc:gad37d8821ebd604515ef02ba84daf5edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Encrypt command is used to request the Controller to encrypt the Plaintext_Data in the command using the Key given in the command and returns the Encrypted_Data to the Host. The AES-128 bit block cypher is defined in NIST Publication FIPS-197 (<a href="http://csrc.nist.gov/publications/fips/">http://csrc.nist.gov/publications/fips/</a> fips197/fips-197.pdf). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.22)  <a href="group___h_c_i___commands.html#gad37d8821ebd604515ef02ba84daf5edb">More...</a><br /></td></tr>
<tr class="separator:gad37d8821ebd604515ef02ba84daf5edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a2c7085cbe758d1f686b6bd94cc56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaf6a2c7085cbe758d1f686b6bd94cc56e">hci_le_rand</a> (uint8_t Random_Number[8])</td></tr>
<tr class="memdesc:gaf6a2c7085cbe758d1f686b6bd94cc56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Rand command is used to request the Controller to generate 8 octets of random data to be sent to the Host. The Random_Number shall be generated according to [Vol 2] Part H, Section 2 if the LE Feature (LL Encryption) is supported. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.23)  <a href="group___h_c_i___commands.html#gaf6a2c7085cbe758d1f686b6bd94cc56e">More...</a><br /></td></tr>
<tr class="separator:gaf6a2c7085cbe758d1f686b6bd94cc56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf863aa4133c1f3ed61003b890208ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gacdf863aa4133c1f3ed61003b890208ae">hci_le_start_encryption</a> (uint16_t Connection_Handle, uint8_t Random_Number[8], uint16_t Encrypted_Diversifier, uint8_t Long_Term_Key[16])</td></tr>
<tr class="memdesc:gacdf863aa4133c1f3ed61003b890208ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Start_Encryption command is used to authenticate the given encryption key associated with the remote device specified by the connection handle, and once authenticated will encrypt the connection. The parameters are as defined in [Vol 3] Part H, Section 2.4.4. If the connection is already encrypted then the Controller shall pause connection encryption before attempting to authenticate the given encryption key, and then re-encrypt the connection. While encryption is paused no user data shall be transmitted. On an authentication failure, the connection shall be automatically disconnected by the Link Layer. If this command succeeds, then the connection shall be encrypted. This command shall only be used when the local device's role is Master. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.24)  <a href="group___h_c_i___commands.html#gacdf863aa4133c1f3ed61003b890208ae">More...</a><br /></td></tr>
<tr class="separator:gacdf863aa4133c1f3ed61003b890208ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa601f722c74c4d0b50050355d75c2750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaa601f722c74c4d0b50050355d75c2750">hci_le_long_term_key_request_reply</a> (uint16_t Connection_Handle, uint8_t Long_Term_Key[16])</td></tr>
<tr class="memdesc:gaa601f722c74c4d0b50050355d75c2750"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Long_Term_Key_Request_Reply command is used to reply to an LE Long Term Key Request event from the Controller, and specifies the Long_Term_Key parameter that shall be used for this Connection_Handle. The Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.25)  <a href="group___h_c_i___commands.html#gaa601f722c74c4d0b50050355d75c2750">More...</a><br /></td></tr>
<tr class="separator:gaa601f722c74c4d0b50050355d75c2750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c71158ff405ff2bd208668b63335a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga8c71158ff405ff2bd208668b63335a8c">hci_le_long_term_key_requested_negative_reply</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga8c71158ff405ff2bd208668b63335a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Long_Term_Key_Request_Negative_Reply command is used to reply to an LE Long Term Key Request event from the Controller if the Host cannot provide a Long Term Key for this Connection_Handle. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.26)  <a href="group___h_c_i___commands.html#ga8c71158ff405ff2bd208668b63335a8c">More...</a><br /></td></tr>
<tr class="separator:ga8c71158ff405ff2bd208668b63335a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04bca74218aa29b4e8ff2338bece63be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga04bca74218aa29b4e8ff2338bece63be">hci_le_read_supported_states</a> (uint8_t LE_States[8])</td></tr>
<tr class="memdesc:ga04bca74218aa29b4e8ff2338bece63be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Supported_States command reads the states and state combinations that the link layer supports. See [Vol 6] Part B, Section 1.1.1. LE_States is an 8-octet bit field. If a bit is set to 1 then this state or state combination is supported by the Controller. Multiple bits in LE_States may be set to 1 to indicate support for multiple state and state combinations. All the Advertising type with the Initiate State combinations shall be set only if the corresponding Advertising types and Master Role combination are set. All the Scanning types and the Initiate State combinations shall be set only if the corresponding Scanning types and Master Role combination are set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.27)  <a href="group___h_c_i___commands.html#ga04bca74218aa29b4e8ff2338bece63be">More...</a><br /></td></tr>
<tr class="separator:ga04bca74218aa29b4e8ff2338bece63be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89019fa5a3a91421a23dbe59bc4a75c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga89019fa5a3a91421a23dbe59bc4a75c2">hci_le_set_data_length</a> (uint16_t Connection_Handle, uint16_t TxOctets, uint16_t TxTime)</td></tr>
<tr class="memdesc:ga89019fa5a3a91421a23dbe59bc4a75c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Data_Length command allows the Host to suggest maximum transmission packet size and maximum packet transmission time (connMaxTxOctets and connMaxTxTime - see [Vol 6] Part B, Section 4.5.10) to be used for a given connection. The Controller may use smaller or larger values based on local information.  <a href="group___h_c_i___commands.html#ga89019fa5a3a91421a23dbe59bc4a75c2">More...</a><br /></td></tr>
<tr class="separator:ga89019fa5a3a91421a23dbe59bc4a75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9534ac5c4b1cfde3b45becc6a76a0e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga9534ac5c4b1cfde3b45becc6a76a0e22">hci_le_read_suggested_default_data_length</a> (uint16_t *SuggestedMaxTxOctets, uint16_t *SuggestedMaxTxTime)</td></tr>
<tr class="memdesc:ga9534ac5c4b1cfde3b45becc6a76a0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Suggested_Default_Data_Length command allows the Host to read the Host preferred values for the Controller maximum transmitted number of payload octets and maximum packet transmission time to be used for new connections (connInitialMaxTxOctets and connInitialMaxTxTime - see ([Vol 6] Part B, Section 4.5.10).  <a href="group___h_c_i___commands.html#ga9534ac5c4b1cfde3b45becc6a76a0e22">More...</a><br /></td></tr>
<tr class="separator:ga9534ac5c4b1cfde3b45becc6a76a0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48350a35f87222088e672a39318ab0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga48350a35f87222088e672a39318ab0df">hci_le_write_suggested_default_data_length</a> (uint16_t SuggestedMaxTxOctets, uint16_t SuggestedMaxTxTime)</td></tr>
<tr class="memdesc:ga48350a35f87222088e672a39318ab0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Write_Suggested_Default_Data_Length command allows the Host to specify its preferred values for the Controller maximum transmission number of payload octets and maximum packet transmission time to be used for new connections (connInitialMaxTxOctets and connInitialMaxTxTime - see [Vol 6] Part B, Section 4.5.10). The Controller may use smaller or larger values based on local information.  <a href="group___h_c_i___commands.html#ga48350a35f87222088e672a39318ab0df">More...</a><br /></td></tr>
<tr class="separator:ga48350a35f87222088e672a39318ab0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60440db8b6953f44a34dd66a0e80c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gac60440db8b6953f44a34dd66a0e80c48">hci_le_read_local_p256_public_key</a> (void)</td></tr>
<tr class="memdesc:gac60440db8b6953f44a34dd66a0e80c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Local_P-256_Public_Key command is used to return the local P-256 public key from the Controller. The Controller shall generate a new P-256 public/private key pair upon receipt of this command. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.36)  <a href="group___h_c_i___commands.html#gac60440db8b6953f44a34dd66a0e80c48">More...</a><br /></td></tr>
<tr class="separator:gac60440db8b6953f44a34dd66a0e80c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4727c50ea1f835b5384d059c0c64237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gad4727c50ea1f835b5384d059c0c64237">hci_le_generate_dhkey</a> (uint8_t Remote_P256_Public_Key[64])</td></tr>
<tr class="memdesc:gad4727c50ea1f835b5384d059c0c64237"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Generate_DHKey command is used to initiate generation of a Diffie- Hellman key in the Controller for use over the LE transport. This command takes the remote P-256 public key as input. The Diffie- Hellman key generation uses the private key generated by LE_Read_Local_P256_Public_Key command. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.37)  <a href="group___h_c_i___commands.html#gad4727c50ea1f835b5384d059c0c64237">More...</a><br /></td></tr>
<tr class="separator:gad4727c50ea1f835b5384d059c0c64237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f453c7d9124aa1f53faa0f7e6dd478e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga8f453c7d9124aa1f53faa0f7e6dd478e">hci_le_add_device_to_resolving_list</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Peer_IRK[16], uint8_t Local_IRK[16])</td></tr>
<tr class="memdesc:ga8f453c7d9124aa1f53faa0f7e6dd478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Add_Device_To_Resolving_List command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller. This command cannot be used when address translation is enabled in the Controller and: - Advertising is enabled.  <a href="group___h_c_i___commands.html#ga8f453c7d9124aa1f53faa0f7e6dd478e">More...</a><br /></td></tr>
<tr class="separator:ga8f453c7d9124aa1f53faa0f7e6dd478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6d1b2105eb756641b31b3d1f9a7021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga7a6d1b2105eb756641b31b3d1f9a7021">hci_le_remove_device_from_resolving_list</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6])</td></tr>
<tr class="memdesc:ga7a6d1b2105eb756641b31b3d1f9a7021"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Remove_Device_From_Resolving_List command is used to remove one device from the list of address translations used to resolve Resolvable Private Addresses in the controller. This command cannot be used when address translation is enabled in the Controller and: - Advertising is enabled - Scanning is enabled - Create connection command is outstanding This command can be used at any time when address translation is disabled in the Controller. When a Controller cannot remove a device from the resolving list because it is not found, it shall respond with error code 0x02 (Unknown Connection Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.39)  <a href="group___h_c_i___commands.html#ga7a6d1b2105eb756641b31b3d1f9a7021">More...</a><br /></td></tr>
<tr class="separator:ga7a6d1b2105eb756641b31b3d1f9a7021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c483fe9c3c56736bbc5b4f22969eebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga2c483fe9c3c56736bbc5b4f22969eebc">hci_le_clear_resolving_list</a> (void)</td></tr>
<tr class="memdesc:ga2c483fe9c3c56736bbc5b4f22969eebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Clear_Resolving_List command is used to remove all devices from the list of address translations used to resolve Resolvable Private Addresses in the Controller. This command cannot be used when address translation is enabled in the Controller and: - Advertising is enabled.  <a href="group___h_c_i___commands.html#ga2c483fe9c3c56736bbc5b4f22969eebc">More...</a><br /></td></tr>
<tr class="separator:ga2c483fe9c3c56736bbc5b4f22969eebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d6a5b18bf4ff051df7cc78746a2a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gab6d6a5b18bf4ff051df7cc78746a2a8c">hci_le_read_resolving_list_size</a> (uint8_t *Resolving_List_Size)</td></tr>
<tr class="memdesc:gab6d6a5b18bf4ff051df7cc78746a2a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Resolving_List_Size command is used to read the total number of address translation entries in the resolving list that can be stored in the Controller. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.41)  <a href="group___h_c_i___commands.html#gab6d6a5b18bf4ff051df7cc78746a2a8c">More...</a><br /></td></tr>
<tr class="separator:gab6d6a5b18bf4ff051df7cc78746a2a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6824cea0d99729312d99ffd070c5f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga8d6824cea0d99729312d99ffd070c5f1">hci_le_read_peer_resolvable_address</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Peer_Resolvable_Address[6])</td></tr>
<tr class="memdesc:ga8d6824cea0d99729312d99ffd070c5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Peer_Resolvable_Address command is used to get the current peer Resolvable Private Address being used for the corresponding peer Public and Random (static) Identity Address. The peer's resolvable address being used may change after the command is called. This command can be used at any time. When a Controller cannot find a Resolvable Private Address associated with the Peer Identity Address, it shall respond with error code 0x02 (Unknown Connection Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.42)  <a href="group___h_c_i___commands.html#ga8d6824cea0d99729312d99ffd070c5f1">More...</a><br /></td></tr>
<tr class="separator:ga8d6824cea0d99729312d99ffd070c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4d7fc34b9d5cb8af642d8d3b768fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga5a4d7fc34b9d5cb8af642d8d3b768fec">hci_le_read_local_resolvable_address</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Local_Resolvable_Address[6])</td></tr>
<tr class="memdesc:ga5a4d7fc34b9d5cb8af642d8d3b768fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Local_Resolvable_Address command is used to get the current local Resolvable Private Address being used for the corresponding peer Identity Address. The local's resolvable address being used may change after the command is called. This command can be used at any time. When a Controller cannot find a Resolvable Private Address associated with the Peer Identity Address, it shall respond with error code 0x02 (Unknown Connection Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.43)  <a href="group___h_c_i___commands.html#ga5a4d7fc34b9d5cb8af642d8d3b768fec">More...</a><br /></td></tr>
<tr class="separator:ga5a4d7fc34b9d5cb8af642d8d3b768fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3317c7e672c83edee3e1186df0185ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaf3317c7e672c83edee3e1186df0185ab">hci_le_set_address_resolution_enable</a> (uint8_t Address_Resolution_Enable)</td></tr>
<tr class="memdesc:gaf3317c7e672c83edee3e1186df0185ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Address_Resolution_Enable command is used to enable resolution of Resolvable Private Addresses in the Controller. This causes the Controller to use the resolving list whenever the Controller receives a local or peer Resolvable Private Address. This command can be used at any time except when: - Advertising is enabled.  <a href="group___h_c_i___commands.html#gaf3317c7e672c83edee3e1186df0185ab">More...</a><br /></td></tr>
<tr class="separator:gaf3317c7e672c83edee3e1186df0185ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24370c220c68f04f9ed4670948042f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga24370c220c68f04f9ed4670948042f47">hci_le_set_resolvable_private_address_timeout</a> (uint16_t RPA_Timeout)</td></tr>
<tr class="memdesc:ga24370c220c68f04f9ed4670948042f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Resolvable_Private_Address_Timeout command set the length of time the controller uses a Resolvable Private Address before a new resolvable private address is generated and starts being used. This timeout applies to all addresses generated by the controller. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.45)  <a href="group___h_c_i___commands.html#ga24370c220c68f04f9ed4670948042f47">More...</a><br /></td></tr>
<tr class="separator:ga24370c220c68f04f9ed4670948042f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53307a9e85ecdcca28aad3401236512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gae53307a9e85ecdcca28aad3401236512">hci_le_read_maximum_data_length</a> (uint16_t *supportedMaxTxOctets, uint16_t *supportedMaxTxTime, uint16_t *supportedMaxRxOctets, uint16_t *supportedMaxRxTime)</td></tr>
<tr class="memdesc:gae53307a9e85ecdcca28aad3401236512"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Maximum_Data_Length command allows the Host to read the Controller maximum supported payload octets and packet duration times for transmission and reception (supportedMaxTxOctets and supportedMaxTxTime, supportedMaxRxOctets, and supportedMaxRxTime, see [Vol 6] Part B, Section 4.5.10).  <a href="group___h_c_i___commands.html#gae53307a9e85ecdcca28aad3401236512">More...</a><br /></td></tr>
<tr class="separator:gae53307a9e85ecdcca28aad3401236512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae642d5696af4b71cdb457e79fd907952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gae642d5696af4b71cdb457e79fd907952">hci_le_read_phy</a> (uint16_t Connection_Handle, uint8_t *TX_PHY, uint8_t *RX_PHY)</td></tr>
<tr class="memdesc:gae642d5696af4b71cdb457e79fd907952"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_PHY command is used to read the current transmitter PHY and receiver PHY on the connection identified by the Connection_Handle.  <a href="group___h_c_i___commands.html#gae642d5696af4b71cdb457e79fd907952">More...</a><br /></td></tr>
<tr class="separator:gae642d5696af4b71cdb457e79fd907952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23ca29ebdbf00b910c0844a1ca46d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaf23ca29ebdbf00b910c0844a1ca46d75">hci_le_set_default_phy</a> (uint8_t ALL_PHYS, uint8_t TX_PHYS, uint8_t RX_PHYS)</td></tr>
<tr class="memdesc:gaf23ca29ebdbf00b910c0844a1ca46d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Default_PHY command allows the Host to specify its preferred values for the transmitter PHY and receiver PHY to be used for all subsequent connections over the LE transport.  <a href="group___h_c_i___commands.html#gaf23ca29ebdbf00b910c0844a1ca46d75">More...</a><br /></td></tr>
<tr class="separator:gaf23ca29ebdbf00b910c0844a1ca46d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd1cf942d2b2944189b8c76c05ce2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gadbd1cf942d2b2944189b8c76c05ce2e7">hci_le_set_phy</a> (uint16_t Connection_Handle, uint8_t ALL_PHYS, uint8_t TX_PHYS, uint8_t RX_PHYS, uint16_t PHY_options)</td></tr>
<tr class="memdesc:gadbd1cf942d2b2944189b8c76c05ce2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_PHY command is used to set the PHY preferences for the connection identified by the Connection_Handle. The Controller might not be able to make the change (e.g. because the peer does not support the requested PHY) or may decide that the current PHY is preferable.  <a href="group___h_c_i___commands.html#gadbd1cf942d2b2944189b8c76c05ce2e7">More...</a><br /></td></tr>
<tr class="separator:gadbd1cf942d2b2944189b8c76c05ce2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec01ac803e373228855fef449bf3bfb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaec01ac803e373228855fef449bf3bfb4">hci_le_set_advertising_set_random_address</a> (uint8_t Advertising_Handle, uint8_t Advertising_Random_Address[6])</td></tr>
<tr class="memdesc:gaec01ac803e373228855fef449bf3bfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Advertising_Set_Random_Address command is used by the Host to set the random device address specified by the Random_Address parameter. This address is used in the Controller (see [Vol 6] Part B, Section 1.3.2) for the advertiser's address contained in the advertising PDUs for the advertising set specified by the Advertising_Handle parameter. If the Host issues this command while an advertising set using connectable advertising is enabled, the Controller shall return the error code Command Disallowed (0x0C). The Host may issue this command at any other time. If this command is used to change the address, the new random address shall take effect for advertising no later than the next successful LE Extended Set Advertising Enable Command and for periodic advertising no later than the next successful LE Periodic Advertising Enable Command.  <a href="group___h_c_i___commands.html#gaec01ac803e373228855fef449bf3bfb4">More...</a><br /></td></tr>
<tr class="separator:gaec01ac803e373228855fef449bf3bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aca75ecf87ab400e11451214e80d4ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga0aca75ecf87ab400e11451214e80d4ab">hci_le_set_extended_advertising_parameters</a> (uint8_t Advertising_Handle, uint16_t Advertising_Event_Properties, uint8_t Primary_Advertising_Interval_Min[3], uint8_t Primary_Advertising_Interval_Max[3], uint8_t Primary_Advertising_Channel_Map, uint8_t Own_Address_Type, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Advertising_Filter_Policy, int8_t Advertising_Tx_Power, uint8_t Primary_Advertising_PHY, uint8_t Secondary_Advertising_Max_Skip, uint8_t Secondary_Advertising_PHY, uint8_t Advertising_SID, uint8_t Scan_Request_Notification_Enable, int8_t *Selected_Tx_Power)</td></tr>
<tr class="memdesc:ga0aca75ecf87ab400e11451214e80d4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Extended_Advertising_Parameters command is used by the Host to set the advertising parameters. The Advertising_Handle parameter identifies the advertising set whose parameters are being configured. The Advertising_Event_Properties parameter describes the type of advertising event that is being configured and its basic properties. The type shall be one supported by the Controller.  <a href="group___h_c_i___commands.html#ga0aca75ecf87ab400e11451214e80d4ab">More...</a><br /></td></tr>
<tr class="separator:ga0aca75ecf87ab400e11451214e80d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90df4e3f7332f188c9d0dd935499cbc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga90df4e3f7332f188c9d0dd935499cbc3">hci_le_set_extended_advertising_enable</a> (uint8_t Enable, uint8_t Number_of_Sets, <a class="el" href="bluenrg__lp__api_8h.html#a008e8bf5b0efc0138300743128635701">Advertising_Set_Parameters_t</a> Advertising_Set_Parameters[])</td></tr>
<tr class="memdesc:ga90df4e3f7332f188c9d0dd935499cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Extended_Advertising_Enable command is used to request the Controller to enable or disable one or more advertising sets using the advertising sets identified by the Advertising_Handle[i] parameter. The Controller manages the timing of advertisements in accordance with the advertising parameters given in the LE_Set_Extended_Advertising_Parameters command.  <a href="group___h_c_i___commands.html#ga90df4e3f7332f188c9d0dd935499cbc3">More...</a><br /></td></tr>
<tr class="separator:ga90df4e3f7332f188c9d0dd935499cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae9869a3f56583f89fd36d710229ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga9ae9869a3f56583f89fd36d710229ab6">hci_le_read_number_of_supported_advertising_sets</a> (uint8_t *Num_Supported_Advertising_Sets)</td></tr>
<tr class="memdesc:ga9ae9869a3f56583f89fd36d710229ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Number_of_Supported_Advertising_Sets command is used to read the maximum number of advertising sets supported by the advertising Controller at the same time. Note: The number of advertising sets that can be supported is not fixed and the Controller can change it at any time because the memory used to store advertising sets can also be used for other purposes.  <a href="group___h_c_i___commands.html#ga9ae9869a3f56583f89fd36d710229ab6">More...</a><br /></td></tr>
<tr class="separator:ga9ae9869a3f56583f89fd36d710229ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c5f01bf8147e1ddee22fdef223a16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga67c5f01bf8147e1ddee22fdef223a16d">hci_le_remove_advertising_set</a> (uint8_t Advertising_Handle)</td></tr>
<tr class="memdesc:ga67c5f01bf8147e1ddee22fdef223a16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Remove_Advertising_Set command is used to remove an advertising set from the Controller. If the advertising set corresponding to the Advertising_Handle parameter does not exist, then the Controller shall return the error code Unknown Advertising Identifier (0x42). If advertising on the advertising set is enabled, then the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___h_c_i___commands.html#ga67c5f01bf8147e1ddee22fdef223a16d">More...</a><br /></td></tr>
<tr class="separator:ga67c5f01bf8147e1ddee22fdef223a16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e4413ace007813267d0f483fc2b8a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga99e4413ace007813267d0f483fc2b8a4">hci_le_clear_advertising_sets</a> (void)</td></tr>
<tr class="memdesc:ga99e4413ace007813267d0f483fc2b8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Clear_Advertising_Sets command is used to remove all existing advertising sets from the Controller. If advertising is enabled on any advertising set, then the Controller shall return the error code Command Disallowed (0x0C). Note: All advertising sets are cleared on HCI reset.  <a href="group___h_c_i___commands.html#ga99e4413ace007813267d0f483fc2b8a4">More...</a><br /></td></tr>
<tr class="separator:ga99e4413ace007813267d0f483fc2b8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a80e0eab1c661162a10df5afa109c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga5a80e0eab1c661162a10df5afa109c00">hci_le_set_periodic_advertising_parameters</a> (uint8_t Advertising_Handle, uint16_t Periodic_Advertising_Interval_Min, uint16_t Periodic_Advertising_Interval_Max, uint16_t Periodic_Advertising_Properties)</td></tr>
<tr class="memdesc:ga5a80e0eab1c661162a10df5afa109c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Periodic_Advertising_Parameters command is used by the Host to set the parameters for periodic advertising. The Advertising_Handle parameter identifies the advertising set whose periodic advertising parameters are being configured. If the corresponding advertising set does not already exist, then the Controller shall return the error code Unknown Advertising Identifier (0x42). The Periodic_Advertising_Interval_Min parameter shall be less than or equal to the Periodic_Advertising_Interval_Max parameter. The Periodic_Advertising_Interval_Min and Periodic_Advertising_Interval_Max parameters should not be the same value to enable the Controller to determine the best advertising interval given other activities. The Periodic_Advertising_Properties parameter indicates which fields should be included in the advertising packet. If the advertising set identified by the Advertising_Handle specified anonymous advertising, the Controller shall return the error code Invalid HCI Parameters (0x12). If the Host issues this command when periodic advertising is enabled for the specified advertising set, the Controller shall return the error code Command Disallowed (0x0C). If the Advertising_Handle does not identify an advertising set that is already configured for periodic advertising and the Controller is unable to support more periodic advertising at present, the Controller shall return the error code Memory Capacity Exceeded (0x07)  <a href="group___h_c_i___commands.html#ga5a80e0eab1c661162a10df5afa109c00">More...</a><br /></td></tr>
<tr class="separator:ga5a80e0eab1c661162a10df5afa109c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d49eb3003deac9de6f361e39281df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaa6d49eb3003deac9de6f361e39281df2">hci_le_set_periodic_advertising_enable</a> (uint8_t Enable, uint8_t Advertising_Handle)</td></tr>
<tr class="memdesc:gaa6d49eb3003deac9de6f361e39281df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Periodic_Advertising_Enable command is used to request the Controller to enable or disable the periodic advertising for the advertising set specified by the Advertising_Handle parameter (ordinary advertising is not affected). If the advertising set is not currently enabled (see the LE_Set_Extended_Advertising_Enable command), the periodic advertising is not started until the advertising set is enabled. Once the advertising set has been enabled, the Controller shall continue periodic advertising until the Host issues an LE_Set_Periodic_Advertising_Enable command with Enable set to 0x00 (periodic advertising is disabled). Disabling the advertising set has no effect on the periodic advertising once the advertising set has been enabled. The Controller manages the timing of advertisements in accordance with the advertising parameters given in the LE_Set_Periodic_Advertising_Parameters command. If the advertising set corresponding to the Advertising_Handle parameter does not exist, the Controller shall return the error code Unknown Advertising Identifier (0x42). If the periodic advertising data in the advertising set is not complete, the Controller shall return the error code Command Disallowed (0x0C). Note: Enabling periodic advertising when it is already enabled can cause the random address to change. Disabling periodic advertising when it is already disabled has no effect.  <a href="group___h_c_i___commands.html#gaa6d49eb3003deac9de6f361e39281df2">More...</a><br /></td></tr>
<tr class="separator:gaa6d49eb3003deac9de6f361e39281df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bb6ae85a32bf0b08afd22473acad85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gae6bb6ae85a32bf0b08afd22473acad85">hci_le_set_extended_scan_parameters</a> (uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Scanning_PHYs, <a class="el" href="bluenrg__lp__api_8h.html#adfb3b811389de79a4b76f9e2064bf681">Extended_Scan_Parameters_t</a> Extended_Scan_Parameters[])</td></tr>
<tr class="memdesc:gae6bb6ae85a32bf0b08afd22473acad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Extended_Scan_Parameters command is used to set the extended scan parameters to be used on the advertising channels. The Scanning_PHYs parameter indicates the PHY(s) on which the advertising packets should be received on the primary advertising channel. The Host may enable one or more scanning PHYs. The Scan_Type[i], Scan_Interval[i], and Scan_Window[i] parameters array elements are ordered in the same order as the set bits in the Scanning_PHY parameter, starting from bit 0. The number of array elements is determined by the number of bits set in the Scanning_PHY parameter. The Scan_Type[i] parameter specifies the type of scan to perform. The Scan_Interval[i] and Scan_Window[i] parameters are recommendations from the Host on how long (Scan_Window[i]) and how frequently (Scan_Interval[i]) the Controller should scan (see [Vol 6] Part B, Section 4.5.3); however the frequency and length of the scan is implementation specific. If the requested scan cannot be supported by the implementation, the Controller shall return the error code Invalid HCI Command Parameters (0x12). The Own_Address_Type parameter indicates the type of address being used in the scan request packets. If the Host issues this command when scanning is enabled in the Controller, the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___h_c_i___commands.html#gae6bb6ae85a32bf0b08afd22473acad85">More...</a><br /></td></tr>
<tr class="separator:gae6bb6ae85a32bf0b08afd22473acad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff8fbe553e947f1ed705e796a7ab84b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga0ff8fbe553e947f1ed705e796a7ab84b">hci_le_set_extended_scan_enable</a> (uint8_t Enable, uint8_t Filter_Duplicates, uint16_t Duration, uint16_t Period)</td></tr>
<tr class="memdesc:ga0ff8fbe553e947f1ed705e796a7ab84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Extended_Scan_Enable command is used to enable or disable scanning. The Enable parameter determines whether scanning is enabled or disabled. If it is disabled, the remaining parameters are ignored. The Filter_Duplicates parameter controls whether the Link Layer should filter out duplicate advertising reports (filtering duplicates enabled) to the Host or if the Link Layer should generate advertising reports for each packet received (filtering duplicates disabled). See [Vol 6] Part B, Section 4.4.3.5. If the Filter_Duplicates parameter is set to 0x00, all advertisements received from advertisers shall be sent to the Host in advertising report events. If the Filter_Duplicates parameter is set to 0x01, duplicate advertisements should not be sent to the Host in advertising report events until scanning is disabled. If the Filter_Duplicates parameter is set to 0x02, duplicate advertisements in a single scan period should not be sent to the Host in advertising report events; this setting shall only be used if Period is non-zero. If Filter_Duplicates is set to 0x2 and Period to zero, the Controller shall return the Invalid error code HCI Command Parameters (0x12). If the Duration parameter is zero or both the Duration parameter and Period parameter are non-zero, the Controller shall continue scanning until scanning is disabled by the Host issuing an LE_Set_Extended_Scan_Enable command with the Enable parameter set to 0x00 (Scanning is disabled). The Period parameter is ignored when the Duration parameter is zero. If the Duration parameter is non-zero and the Period parameter is zero, the Controller shall continue scanning until the duration specified in the Duration parameter has expired. If both the Duration and Period parameters are non-zero and the Duration parameter is greater than or equal to the Period parameter, the Controller shall return the error code Invalid HCI Command Parameters (0x12). When the Duration and Period parameters are non-zero, the Controller shall scan for the duration of the Duration parameter within a scan period specified by the Period parameter. After the scan period has expired, a new scan period shall begin and scanning shall begin again for the duration specified. The scan periods continue until the Host disables scanning. If the LE_Set_Extended_Scan_Enable command is sent while scanning is enabled, the timers used for duration and period are reset to the new parameter values and a new scan period is started. Any change to the Filter_Duplicates setting or the random address shall take effect. Note: Disabling scanning when it is disabled has no effect. Note: The duration of a scan period refers to the time spent scanning on both the primary and secondary advertising channels. However, expiry of the duration does not prevent the Link Layer from scanning for and receiving auxiliary packets of received advertisements. If the scanning parameters' Own_Address_Type parameter is set to 0x01 or 0x03 and the random address for the device has not been initialized, the Controller shall return the error code Invalid HCI Command Parameters (0x12).  <a href="group___h_c_i___commands.html#ga0ff8fbe553e947f1ed705e796a7ab84b">More...</a><br /></td></tr>
<tr class="separator:ga0ff8fbe553e947f1ed705e796a7ab84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fd1f738985d7dfc8a094e8465eac09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga44fd1f738985d7dfc8a094e8465eac09">hci_le_extended_create_connection</a> (uint8_t Initiating_Filter_Policy, uint8_t Own_Address_Type, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Initiating_PHYs, <a class="el" href="bluenrg__lp__api_8h.html#ab42962d78b42f3d482cf1da22b8f5c6e">Extended_Create_Connection_Parameters_t</a> Extended_Create_Connection_Parameters[])</td></tr>
<tr class="memdesc:ga44fd1f738985d7dfc8a094e8465eac09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Extended_Create_Connection command is used to create a Link Layer connection to a connectable advertiser. LE_Extended_Create_Connection command can be used in place of LE_Create_Connection command.  <a href="group___h_c_i___commands.html#ga44fd1f738985d7dfc8a094e8465eac09">More...</a><br /></td></tr>
<tr class="separator:ga44fd1f738985d7dfc8a094e8465eac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab263377ee3fdb92f62d5a42618395dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gab263377ee3fdb92f62d5a42618395dfb">hci_le_periodic_advertising_create_sync</a> (uint8_t Options, uint8_t Advertising_SID, uint8_t Advertising_Address_Type, uint8_t Advertiser_Address[6], uint16_t Skip, uint16_t Sync_Timeout, uint8_t Sync_CTE_Type)</td></tr>
<tr class="memdesc:gab263377ee3fdb92f62d5a42618395dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Periodic_Advertising_Create_Sync command is used to synchronize with periodic advertising from an advertiser and begin receiving periodic advertising packets. This command may be issued whether or not scanning is enabled and scanning may be enabled and disabled (see the LE Set Extended Scan Enable Command) while this command is pending. However, synchronization can only occur when scanning is enabled. While scanning is disabled, no attempt to synchronize will take place. The Filter_Policy parameter is used to determine whether the Periodic Advertiser List is used. If the Periodic Advertiser List is not used, the Advertising_SID, Advertiser Address_Type, and Advertiser Address parameters specify the periodic advertising device to listen to; otherwise they are ignored. The Advertising_SID parameter, if used, specifies the value that must match the Advertising SID subfield in the ADI field of the received advertisement for it to be used to synchronize. The Skip parameter specifies the number of consecutive periodic advertising packets that the receiver may skip after successfully receiving a periodic advertising packet. The Sync_Timeout parameter specifies the maximum permitted time between successful receives. If this time is exceeded, synchronization is lost. The Unused parameter is reserved for future use. Irrespective of the value of the Skip parameter, the Controller should stop skipping packets before the Sync_Timeout would be exceeded. If the Host issues this command when another LE_Periodic_Advertising_Create_Sync command is pending (see page 1380), the Controller shall return the error code Command Disallowed (0x0C). If the Host issues this command for a periodic advertising set from an advertiser that the Controller is already synchronized to, the Controller shall return the error code Connection Already Exists (0x0B).  <a href="group___h_c_i___commands.html#gab263377ee3fdb92f62d5a42618395dfb">More...</a><br /></td></tr>
<tr class="separator:gab263377ee3fdb92f62d5a42618395dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e778a6322e631ae852b3dc6a84ed6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga5e778a6322e631ae852b3dc6a84ed6f5">hci_le_periodic_advertising_create_sync_cancel</a> (void)</td></tr>
<tr class="memdesc:ga5e778a6322e631ae852b3dc6a84ed6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Periodic_Advertising_Create_Sync_Cancel command is used to cancel the LE_Periodic_Advertising_Create_Sync command while it is pending. If the Host issues this command while no LE_Periodic_Advertising_Create_Sync command is pending, the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___h_c_i___commands.html#ga5e778a6322e631ae852b3dc6a84ed6f5">More...</a><br /></td></tr>
<tr class="separator:ga5e778a6322e631ae852b3dc6a84ed6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d4ea8e2cb79893a5de7d3e5adb16de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga37d4ea8e2cb79893a5de7d3e5adb16de">hci_le_periodic_advertising_terminate_sync</a> (uint16_t Sync_Handle)</td></tr>
<tr class="memdesc:ga37d4ea8e2cb79893a5de7d3e5adb16de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Periodic_Advertising_Terminate_Sync command is used to stop reception of the periodic advertising identified by the Sync_Handle parameter. If the Host issues this command when another LE_Periodic_Advertising_Create_Sync command is pending (see below), the Controller shall return the error code Command Disallowed (0x0C). If the periodic advertising corresponding to the Sync_Handle parameter does not exist, then the Controller shall return the error code Unknown Advertising Identifier (0x42).  <a href="group___h_c_i___commands.html#ga37d4ea8e2cb79893a5de7d3e5adb16de">More...</a><br /></td></tr>
<tr class="separator:ga37d4ea8e2cb79893a5de7d3e5adb16de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8857fcc5679db318175654736d43f51b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga8857fcc5679db318175654736d43f51b">hci_le_add_device_to_periodic_advertiser_list</a> (uint8_t Advertiser_Address_Type, uint8_t Advertiser_Address[6], uint8_t Advertising_SID)</td></tr>
<tr class="memdesc:ga8857fcc5679db318175654736d43f51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Add_Device_To_Periodic_Advertiser_List command is used to add a single device to the Periodic Advertiser list stored in the Controller. Any additions to the Periodic Advertiser list take effect immediately. If the device is already on the list, the Controller shall return the error code Invalid HCI Command Parameters (0x12). If the Host issues this command when an LE_Periodic_Advertising_Create_Sync command is pending, the Controller shall return the error code Command Disallowed (0x0C). When a Controller cannot add a device to the Periodic Advertiser list because the list is full, the Controller shall return the error code Memory Capacity Exceeded (0x07).  <a href="group___h_c_i___commands.html#ga8857fcc5679db318175654736d43f51b">More...</a><br /></td></tr>
<tr class="separator:ga8857fcc5679db318175654736d43f51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3a3884ad16ec127ffa8eff13c0aecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga1c3a3884ad16ec127ffa8eff13c0aecd">hci_le_remove_device_from_periodic_advertising_list</a> (uint8_t Advertiser_Address_Type, uint8_t Advertiser_Address[6], uint8_t Advertising_SID)</td></tr>
<tr class="memdesc:ga1c3a3884ad16ec127ffa8eff13c0aecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Remove_Device_From_Periodic_Advertiser_List command is used to remove one device from the list of Periodic Advertisers stored in the Controller. Removals from the Periodic Advertisers List take effect immediately. If the Host issues this command when an LE_Periodic_Advertising_Create_Sync command is pending, the Controller shall return the error code Command Disallowed (0x0C). When a Controller cannot remove a device from the Periodic Advertiser list because it is not found, the Controller shall return the error code Unknown Advertising Identifier (0x42).  <a href="group___h_c_i___commands.html#ga1c3a3884ad16ec127ffa8eff13c0aecd">More...</a><br /></td></tr>
<tr class="separator:ga1c3a3884ad16ec127ffa8eff13c0aecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5171a2b5a45db3c98186c5d762d05eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga5171a2b5a45db3c98186c5d762d05eff">hci_le_clear_periodic_advertiser_list</a> (void)</td></tr>
<tr class="memdesc:ga5171a2b5a45db3c98186c5d762d05eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Clear_Periodic_Advertiser_List command is used to remove all devices from the list of Periodic Advertisers in the Controller. If this command is used when an LE_Periodic_Advertising_Create_Sync command is pending, the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___h_c_i___commands.html#ga5171a2b5a45db3c98186c5d762d05eff">More...</a><br /></td></tr>
<tr class="separator:ga5171a2b5a45db3c98186c5d762d05eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f69f2c8c24dade1fa1c3abc36936b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaf9f69f2c8c24dade1fa1c3abc36936b4">hci_le_read_periodic_advertiser_list_size</a> (uint8_t *Periodic_Advertiser_List_Size)</td></tr>
<tr class="memdesc:gaf9f69f2c8c24dade1fa1c3abc36936b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Periodic_Advertiser_List_Size command is used to read the total number of Periodic Advertiser list entries that can be stored in the Controller. Note: The number of entries that can be stored is not fixed and the Controller can change it at any time (e.g., because the memory used to store the list can also be used for other purposes).  <a href="group___h_c_i___commands.html#gaf9f69f2c8c24dade1fa1c3abc36936b4">More...</a><br /></td></tr>
<tr class="separator:gaf9f69f2c8c24dade1fa1c3abc36936b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6d247dcd93a2354ad6d1e6b1a32a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga4b6d247dcd93a2354ad6d1e6b1a32a09">hci_le_read_transmit_power</a> (int8_t *Min_Tx_Power, int8_t *Max_Tx_Power)</td></tr>
<tr class="memdesc:ga4b6d247dcd93a2354ad6d1e6b1a32a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Read_Transmit_Power command is used to read the minimum and maximum transmit powers supported by the Controller.  <a href="group___h_c_i___commands.html#ga4b6d247dcd93a2354ad6d1e6b1a32a09">More...</a><br /></td></tr>
<tr class="separator:ga4b6d247dcd93a2354ad6d1e6b1a32a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b5b56b769c875211d3df966cfeb1a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga20b5b56b769c875211d3df966cfeb1a2">hci_le_read_rf_path_compensation</a> (int16_t *RF_TX_Path_Compensation_Value, int16_t *RF_RX_Path_Compensation_Value)</td></tr>
<tr class="memdesc:ga20b5b56b769c875211d3df966cfeb1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Read_RF_Path_Compensation command is used to read the RF Path Compensation Values parameter used in the Tx Power Level and RSSI calculation.  <a href="group___h_c_i___commands.html#ga20b5b56b769c875211d3df966cfeb1a2">More...</a><br /></td></tr>
<tr class="separator:ga20b5b56b769c875211d3df966cfeb1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a5befc737797a8a18ea2e27774e1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga46a5befc737797a8a18ea2e27774e1dc">hci_le_write_rf_path_compensation</a> (int16_t RF_TX_Path_Compensation_Value, int16_t RF_RX_Path_Compensation_Value)</td></tr>
<tr class="memdesc:ga46a5befc737797a8a18ea2e27774e1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Write_RF_Path_Compensation command is used to indicate the RF path gain or loss between the RF transceiver and the antenna contributed by intermediate components. A positive value means a net RF path gain and a negative value means a net RF path loss. The RF Tx Path Compensation Value parameter shall be used by the Controller to calculate radiative Tx Power Level used in HCI commands, HCI events, Advertising physical channel PDUs, and Link Layer Control PDUs using the following equation: Radiative Tx Power Level = Tx Power Level at RF transceiver output + RF Tx Path Compensation Value. For example, if the Tx Power Level is +4 (dBm) at RF transceiver output and the RF Path Compensation Value is -1.5 (dB), the radiative Tx Power Level is +4+(-1.5) = 2.5 (dBm). The RF Rx Path Compensation Value parameter shall be used by the Controller to calculate the RSSI value reported to the Host.  <a href="group___h_c_i___commands.html#ga46a5befc737797a8a18ea2e27774e1dc">More...</a><br /></td></tr>
<tr class="separator:ga46a5befc737797a8a18ea2e27774e1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9205d36954e747e0cbec275ead4ac424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga9205d36954e747e0cbec275ead4ac424">hci_le_set_privacy_mode</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Privacy_Mode)</td></tr>
<tr class="memdesc:ga9205d36954e747e0cbec275ead4ac424"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Privacy_Mode command is used to allow the Host to specify the privacy mode to be used for a given entry on the resolving list. The effect of this setting is specified in [Vol 6] Part B, Section 4.7. When an entry on the resolving list is removed, the mode associated with that entry shall also be removed. This command cannot be used when address translation is enabled in the Controller and: Advertising is enabled Scanning is enabled Create connection command is outstanding This command can be used at any time when address translation is disabled in the Controller. If the device is not on the resolving list, the Controller shall return the error code Unknown Connection Identifier (0x02).  <a href="group___h_c_i___commands.html#ga9205d36954e747e0cbec275ead4ac424">More...</a><br /></td></tr>
<tr class="separator:ga9205d36954e747e0cbec275ead4ac424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76b84f62d38bb75867945b89087ff6ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga76b84f62d38bb75867945b89087ff6ef">hci_le_set_connectionless_cte_transmit_parameters</a> (uint8_t Advertising_Handle, uint8_t CTE_Length, uint8_t CTE_Type, uint8_t CTE_Count, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[])</td></tr>
<tr class="memdesc:ga76b84f62d38bb75867945b89087ff6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command is used to set the type, length, and antenna switching pattern for the transmission of Constant Tone Extensions in any periodic advertising on the advertising set identified by the Advertising_Handle parameter. The CTE_Count parameter specifies how many packets with a Constant Tone Extension are to be transmitted in each periodic advertising event. If the number of packets that would otherwise be transmitted is less than this, the Controller shall transmit sufficient AUX_CHAIN_IND PDUs with no AdvData to make up the number. However, if a change in circumstances since this command was issued means that the Controller can no longer schedule all of these packets, it should transmit as many as possible. If the Host issues this command when Constant Tone Extensions have been enabled in the advertising set, the Controller shall return the error code Command Disallowed (0x0C). The Switching_Pattern_Length and Antenna_IDs[i] parameters are only used when transmitting an AoD Constant Tone Extension and shall be ignored if CTE_Type specifies an AoA Constant Tone Extension. If the CTE_Length parameter is greater than the maximum length of Constant Tone Extension supported, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the Host requests a type of Constant Tone Extension that the Controller does not support, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the Controller is unable to schedule CTE_Count packets in each event, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the advertising set corresponding to the Advertising_Handle parameter does not exist, the Controller shall return the error code Unknown Advertising Identifier (0x42). If Switching_Pattern_Length is greater than the maximum length of switching pattern supported by the Controller (see Section 7.8.87), the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna.  <a href="group___h_c_i___commands.html#ga76b84f62d38bb75867945b89087ff6ef">More...</a><br /></td></tr>
<tr class="separator:ga76b84f62d38bb75867945b89087ff6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3725be03e76429ba1165b8e4f5953590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga3725be03e76429ba1165b8e4f5953590">hci_le_set_connectionless_cte_transmit_enable</a> (uint8_t Advertising_Handle, uint8_t CTE_Enable)</td></tr>
<tr class="memdesc:ga3725be03e76429ba1165b8e4f5953590"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Connectionless_CTE_Transmit_Enable command is used to request that the Controller enables or disables the use of Constant Tone Extensions in any periodic advertising on the advertising set identified by Advertising_Handle. In order to start sending periodic advertisements containing a Constant Tone Extension, the Host must also enable periodic advertising using the HCI_LE_Set_Periodic_Advertising_Enable command (see Section 7.8.63). Note: Periodic advertising can only be enabled when advertising is enabled on the same advertising set, but can continue after advertising has been disabled. If the Host issues this command before it has issued the HCI_LE_Set_Periodic_Advertising_Parameters command (see Section 7.8.61) for the advertising set, the Controller shall return the error code Command Disallowed (0x0C). Once enabled, the Controller shall continue advertising with Constant Tone Extensions until either one of the following occurs: - The Host issues an HCI_LE_Set_Connectionless_CTE_Transmit_Enable command with CTE_Enable set to 0x00 (disabling Constant Tone Extensions but allowing periodic advertising to continue). - The Host issues an HCI_LE_Set_Periodic_Advertising_Enable command (see Section 7.8.63) with Enable set to 0x00 (disabling periodic advertising). If periodic advertising is re-enabled then it shall continue to contain Constant Tone Extensions. If the Host issues this command before it has issued the HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command for the advertising set, the Controller shall return the error code Command Disallowed (0x0C). If the periodic advertising is on a PHY that does not allow Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___h_c_i___commands.html#ga3725be03e76429ba1165b8e4f5953590">More...</a><br /></td></tr>
<tr class="separator:ga3725be03e76429ba1165b8e4f5953590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada03f6a2a225652bce2ca8b6ea6349c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gada03f6a2a225652bce2ca8b6ea6349c0">hci_le_set_connectionless_iq_sampling_enable</a> (uint16_t Sync_Handle, uint8_t Sampling_Enable, uint8_t Slot_Durations, uint8_t Max_Sampled_CTEs, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[])</td></tr>
<tr class="memdesc:gada03f6a2a225652bce2ca8b6ea6349c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Connectionless_IQ_Sampling_Enable command is used to request that the Controller enables or disables capturing IQ samples from the Constant Tone Extension of periodic advertising packets in the periodic advertising train identified by the Sync_Handle parameter. If that periodic advertising train does not exist, then the Controller shall return the error code Unknown Advertising Identifier (0x42). The Max_Sampled_CTEs parameter specifies the maximum number of Constant Tone Extensions in each periodic advertising event that the Controller should collect and report IQ samples from. The Controller should sample all Constant Tone Extensions up to this number. If the Sampling_Enable parameter is set to 0x01 (sampling is enabled), the Controller starts attempting to capture IQ samples from the periodic advertisements. Once sampling has been enabled, the Controller shall continue taking IQ samples until the Host issues an HCI_LE_Set_Connectionless_IQ_Enable command with Sampling_Enable set to 0x00 (sampling is disabled) or synchronization with the periodic advertising train is lost. If Sampling_Enable is set to 0x00, Slot_Durations, Max_Sampled_CTEs, Switching_Pattern_Length, and Antenna_IDs shall be ignored. The command is also used to set the antenna switching pattern and switching and sampling slot durations to be used while receiving the Constant Tone Extension. If Slot_Durations is set to 0x01 and the Controller does not support 1 microsecond switching and sampling, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). The Slot_Durations, Switching_Pattern_Length, and Antenna_IDs parameters are only used when receiving an AoA Constant Tone Extension and do not affect the reception of an AoD Constant Tone Extension. If Switching_Pattern_Length is greater than the maximum length of switching pattern supported by the Controller, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna. If Sampling_Enable is set to 0x01 and the periodic advertising is on a PHY that does not allow Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___h_c_i___commands.html#gada03f6a2a225652bce2ca8b6ea6349c0">More...</a><br /></td></tr>
<tr class="separator:gada03f6a2a225652bce2ca8b6ea6349c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf8fddfca5bdc4b2f10c7740facfd35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gadbf8fddfca5bdc4b2f10c7740facfd35">hci_le_set_connection_cte_receive_parameters</a> (uint16_t Connection_Handle, uint8_t Sampling_Enable, uint8_t Slot_Durations, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[])</td></tr>
<tr class="memdesc:gadbf8fddfca5bdc4b2f10c7740facfd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Connection_CTE_Receive_Parameters command is used to enable or disable sampling received Constant Tone Extension fields on the connection identified by the Connection_Handle parameter and to set the antenna switching pattern and switching and sampling slot durations to be used. If the Sampling_Enable parameter is set to 0x01, the Controller shall sample Constant Tone Extensions on the specified connection and report the samples to the Host. If it is set to 0x00, the Controller shall cease sampling on the specified connection; the remaining parameters shall be ignored. If Slot_Durations is set to 0x01 and the Controller does not support 1 microsecond switching and sampling, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). The Slot_Durations, Switching_Pattern_Length, and Antenna_IDs parameters are only used when receiving an AoA Constant Tone Extension and do not affect the reception of an AoD Constant Tone Extension. If Switching_Pattern_Length is greater than the maximum length of switching pattern supported by the Controller, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna.  <a href="group___h_c_i___commands.html#gadbf8fddfca5bdc4b2f10c7740facfd35">More...</a><br /></td></tr>
<tr class="separator:gadbf8fddfca5bdc4b2f10c7740facfd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fffc9271c2b41b4511f23f20667a424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga2fffc9271c2b41b4511f23f20667a424">hci_le_set_connection_cte_transmit_parameters</a> (uint16_t Connection_Handle, uint8_t CTE_Type, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[])</td></tr>
<tr class="memdesc:ga2fffc9271c2b41b4511f23f20667a424"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Connection_CTE_Transmit_Parameters command is used to set the antenna switching pattern and permitted Constant Tone Extension types used for transmitting Constant Tone Extensions requested by the peer device on the connection identified by the Connection_Handle parameter. If the Host issues this command when Constant Tone Extension responses have been enabled on the connection, the Controller shall return the error code Command Disallowed (0x0C). If the CTE_Types parameter has a bit set for a type of Constant Tone Extension that the Controller does not support, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). The Switching_Pattern_Length and Antenna_IDs[i] parameters are only used when transmitting an AoD Constant Tone Extension and shall be ignored when CTE_Types does not have a bit set for an AoD Constant Tone Extension; they do not affect the transmission of an AoA Constant Tone Extension. If Switching_Pattern_Length is greater than the maximum length of switching pattern supported by the Controller, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna.  <a href="group___h_c_i___commands.html#ga2fffc9271c2b41b4511f23f20667a424">More...</a><br /></td></tr>
<tr class="separator:ga2fffc9271c2b41b4511f23f20667a424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8d91b28840f3fbed1d4b066875e256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga9e8d91b28840f3fbed1d4b066875e256">hci_le_connection_cte_request_enable</a> (uint16_t Connection_Handle, uint8_t Enable, uint16_t CTE_Request_Interval, uint8_t Requested_CTE_Length, uint8_t Requested_CTE_Type)</td></tr>
<tr class="memdesc:ga9e8d91b28840f3fbed1d4b066875e256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Connection_CTE_Request_Enable command is used to request the Controller to start or stop initiating the Constant Tone Extension Request procedure (see [Vol 6] Part B, Section 5.1.12) on a connection identified by the Connection_Handle parameter. If the Host issues this command when the Controller is aware (e.g. through a previous feature exchange) that the peer device's Link Layer does not support the Connection CTE Response feature, the Controller shall return the error code Unsupported Remote Feature / Unsupported LMP Feature (0x1A). If the Host issues this command when the Controller is aware that the peer device's Link Layer does not support the requested CTE type, the Controller should return the error code Unsupported Remote Feature / Unsupported LMP Feature (0x1A). If Enable is set to 0x00, the remaining parameters shall be ignored. The CTE_Request_Interval parameter defines whether the Constant Tone Extension Request procedure is initiated only once or periodically. In the case of periodic operation, the procedure is initiated every CTE_Request_Interval. However, the Controller may delay initiating the procedure beyond the requested interval (e.g., in order to prioritize other activities). The Requested_CTE_Length parameter indicates the minimum length of the Constant Tone Extension and the Requested_CTE_Type parameter indicates the type of Constant Tone Extension that the Controller shall request from the remote device. A request is active on a connection from when the Host issues a successful command with Enable set to 0x01 until the single procedure has been performed, the period specified by CTE_Request_Interval has ended, or a command with Enable set to 0x00 has succeeded, whichever happens first. If the Host issues this command with Enable set to 0x01 while a request is active for the specified connection, the Controller shall return the error code Command Disallowed (0x0C). Note: The failed command will not affect the behavior of the Link Layer in respect of the currently-active request. If the Host issues this command before issuing the HCI_LE_Set_Connection_CTE_Receive_Parameters command at least once on the connection, the Controller shall return the error code Command Disallowed (0x0C). If the Host issues this command when the receiver PHY for the connection is not a PHY that allows Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C). If the Host sets CTE_Request_Interval to a non-zero value less than or equal to connSlaveLatency, the Controller shall return the error code Command Disallowed (0x0C). If Enable is set to 0x01 and the receiver PHY for the connection changes to a PHY that does not allow Constant Tone Extensions, then the Controller shall automatically disable Constant Tone Extension requests as if the Host had issued this command with Enable set to 0x00. Note: If the PHY changes back to a PHY that allows Constant Tone Extensions, then the Controller will not automatically re-enable Constant Tone Extension requests.  <a href="group___h_c_i___commands.html#ga9e8d91b28840f3fbed1d4b066875e256">More...</a><br /></td></tr>
<tr class="separator:ga9e8d91b28840f3fbed1d4b066875e256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f21ab83dfe9e2ea73a4d2129ade7614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga3f21ab83dfe9e2ea73a4d2129ade7614">hci_le_connection_cte_response_enable</a> (uint16_t Connection_Handle, uint8_t Enable)</td></tr>
<tr class="memdesc:ga3f21ab83dfe9e2ea73a4d2129ade7614"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Connection_CTE_Response_Enable command is used to request the Controller to respond to LL_CTE_REQ PDUs with LL_CTE_RSP PDUs on the specified connection. If the Host issues this command before issuing the HCI_LE_Set_Connection_CTE_Transmit_Parameters command at least once on the connection, the Controller shall return the error code Command Disallowed (0x0C). If the Host issues this command when the transmitter PHY for the connection is not a PHY that allows Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C). If the transmitter PHY for the connection changes to a PHY that does not allow Constant Tone Extensions, then the Controller shall automatically disable Constant Tone Extension responses.  <a href="group___h_c_i___commands.html#ga3f21ab83dfe9e2ea73a4d2129ade7614">More...</a><br /></td></tr>
<tr class="separator:ga3f21ab83dfe9e2ea73a4d2129ade7614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690b9a18c88cc976eae099803da1dadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga690b9a18c88cc976eae099803da1dadd">hci_le_read_antenna_information</a> (uint8_t *Supported_Switching_Sampling_Rates, uint8_t *Num_Antennae, uint8_t *Max_Switching_Pattern_Length, uint8_t *Max_CTE_Length)</td></tr>
<tr class="memdesc:ga690b9a18c88cc976eae099803da1dadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Read_Antenna_Information command allows the Host to read the switching rates, the sampling rates, the number of antennae, and the maximum length of a transmitted Constant Tone Extension supported by the Controller.  <a href="group___h_c_i___commands.html#ga690b9a18c88cc976eae099803da1dadd">More...</a><br /></td></tr>
<tr class="separator:ga690b9a18c88cc976eae099803da1dadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7235a664f73c046fcb521eb5f3af4551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga7235a664f73c046fcb521eb5f3af4551">hci_le_set_periodic_advertising_receive_enable</a> (uint16_t Sync_Handle, uint8_t Enable)</td></tr>
<tr class="memdesc:ga7235a664f73c046fcb521eb5f3af4551"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Periodic_Advertising_Receive_Enable command will enable or disable reports for the periodic advertising train identified by the Sync_Handle parameter. The Enable parameter determines whether reporting is enabled or disabled. If the value is the same as the current state, the command has no effect. If the periodic advertising train corresponding to the Sync_Handle parameter does not exist, the Controller shall return the error code Unknown Advertising Identifier (0x42).  <a href="group___h_c_i___commands.html#ga7235a664f73c046fcb521eb5f3af4551">More...</a><br /></td></tr>
<tr class="separator:ga7235a664f73c046fcb521eb5f3af4551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc9b30141f28403413452602ba1420c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga5fc9b30141f28403413452602ba1420c">hci_le_periodic_advertising_sync_transfer</a> (uint16_t Connection_Handle, uint16_t Service_Data, uint16_t Sync_Handle)</td></tr>
<tr class="memdesc:ga5fc9b30141f28403413452602ba1420c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Periodic_Advertising_Sync_Transfer command is used to instruct the Controller to send synchronization information about the periodic advertising train identified by the Sync_Handle parameter to a connected device. The Service_Data parameter is a value provided by the Host for use by the Host of the peer device. It is not used by the Controller. The connected device is identified by the Connection_Handle parameter. If the periodic advertising train corresponding to the Sync_Handle parameter does not exist, the Controller shall return the error code Unknown Advertising Identifier (0x42). If the Connection_Handle parameter does not identify a current connection, the Controller shall return the error code Unknown Connection Identifier (0x02). If the remote device has not indicated support for the Periodic Advertising Sync Transfer - Recipient feature, the Controller shall return the error code Unsupported Remote Feature / Unsupported LMP Feature (0x1A). Note: This command may complete before the periodic advertising synchronization information is sent. No indication is given as to how the recipient handled the information.  <a href="group___h_c_i___commands.html#ga5fc9b30141f28403413452602ba1420c">More...</a><br /></td></tr>
<tr class="separator:ga5fc9b30141f28403413452602ba1420c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e82daec659f72d668fe98125af053bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga4e82daec659f72d668fe98125af053bc">hci_le_periodic_advertising_set_info_transfer</a> (uint16_t Connection_Handle, uint16_t Service_Data, uint8_t Advertising_Handle)</td></tr>
<tr class="memdesc:ga4e82daec659f72d668fe98125af053bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Periodic_Advertising_Set_Info_Transfer command is used to instruct the Controller to send synchronization information about the periodic advertising in an advertising set to a connected device. The Advertising_Handle parameter identifies the advertising set. If the parameters in the advertising set have changed since the periodic advertising was first enabled, the current parameters - not the original ones - are sent. The Service_Data parameter is a value provided by the Host to identify the periodic advertising train to the peer device. It is not used by the Controller. The connected device is identified by the Connection_Handle parameter. If the advertising set corresponding to the Advertising_Handle parameter does not exist, the Controller shall return the error code Unknown Advertising Identifier (0x42). If periodic advertising is not currently in progress for the advertising set, the Controller shall return the error code Command Disallowed (0x0C). If the Connection_Handle parameter does not identify a current connection, the Controller shall return the error code Unknown Connection Identifier (0x02). If the remote device has not indicated support for the Periodic Advertising Sync Transfer - Recipient feature, the Controller shall return the error code Unsupported Remote Feature / Unsupported LMP Feature (0x1A). Note: This command may complete before the periodic advertising synchronization information is sent. No indication is given as to how the recipient handled the information.  <a href="group___h_c_i___commands.html#ga4e82daec659f72d668fe98125af053bc">More...</a><br /></td></tr>
<tr class="separator:ga4e82daec659f72d668fe98125af053bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d310cadfff0e3889f1a0d5cc812f629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga9d310cadfff0e3889f1a0d5cc812f629">hci_le_set_periodic_advertising_sync_transfer_parameters</a> (uint16_t Connection_Handle, uint8_t Mode, uint16_t Skip, uint16_t Sync_Timeout, uint8_t CTE_Type)</td></tr>
<tr class="memdesc:ga9d310cadfff0e3889f1a0d5cc812f629"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command is used to specify how the Controller will process periodic advertising synchronization information received from the device identified by the Connection_Handle parameter (the "transfer mode"). The Mode parameter specifies the action to be taken when periodic advertising synchronization information is received. If Mode is 0x00, the Controller will ignore the information. Otherwise it will notify the Host and synchronize to the periodic advertising. Mode also specifies whether periodic advertising reports are initially enabled or disabled. The Skip parameter specifies the number of consecutive periodic advertising packets that the receiver may skip after successfully receiving a periodic advertising packet. The Sync_Timeout parameter specifies the maximum permitted time between successful receives. If this time is exceeded, synchronization is lost. Irrespective of the value of the Skip parameter, the Controller should stop skipping packets before the Sync_Timeout would be exceeded. The CTE_Type parameter specifies whether to only synchronize to periodic advertising with certain types of Constant Tone Extension. If the periodic advertiser changes the type of the Constant Tone Extension after the Controller has synchronized with the periodic advertising, it shall remain synchronized. Note: A value of 0 (i.e. all bits clear) indicates that the presence or absence of a Constant Tone Extension is irrelevant. This command does not affect any processing of any periodic advertising synchronization information already received from the peer device, whether or not the Controller has yet synchronized to the periodic advertising train it describes. The parameter values provided by this command override those provided via the HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters command (Section 7.8.92) or any preferences previously set using the HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command on the same connection. If the Connection_Handle parameter does not identify a current connection, the Controller shall return the error code Unknown Connection Identifier (0x02).  <a href="group___h_c_i___commands.html#ga9d310cadfff0e3889f1a0d5cc812f629">More...</a><br /></td></tr>
<tr class="separator:ga9d310cadfff0e3889f1a0d5cc812f629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa551c7946dc61787efada88b98ed525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gafa551c7946dc61787efada88b98ed525">hci_le_set_default_periodic_advertising_sync_transfer_parameters</a> (uint8_t Mode, uint16_t Skip, uint16_t Sync_Timeout, uint8_t CTE_Type)</td></tr>
<tr class="memdesc:gafa551c7946dc61787efada88b98ed525"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters command is used to specify the initial value for the mode, skip, timeout, and Constant Tone Extension type (set by the HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command; see Section 7.8.91) to be used for all subsequent connections over the LE transport. The Mode parameter specifies the initial action to be taken. If Mode is 0x00, the Controller will ignore the information. Otherwise it will notify the Host and synchronize to the periodic advertising. Mode also specifies whether periodic advertising reports are initially enabled or disabled. The Skip parameter specifies the number of consecutive periodic advertising packets that the receiver may skip after successfully receiving a periodic advertising packet. The Sync_Timeout parameter specifies the maximum permitted time between successful receives. If this time is exceeded, synchronization is lost. The CTE_Type parameter specifies whether to only synchronize to periodic advertising with certain types of Constant Tone Extension. If the periodic advertiser changes the type of the Constant Tone Extension after the Controller has synchronized with the periodic advertising, it shall remain synchronized. Note: A value of 0 (i.e. all bits clear) indicates that the presence or absence of a Constant Tone Extension is irrelevant. This command does not affect any existing connection.  <a href="group___h_c_i___commands.html#gafa551c7946dc61787efada88b98ed525">More...</a><br /></td></tr>
<tr class="separator:gafa551c7946dc61787efada88b98ed525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a4e460e36bbbb41ef44fd296a27086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga15a4e460e36bbbb41ef44fd296a27086">hci_le_enhanced_read_transmit_power_level</a> (uint16_t Connection_Handle, uint8_t PHY, int8_t *Current_Transmit_Power_Level, int8_t *Max_Transmit_Power_Level)</td></tr>
<tr class="memdesc:ga15a4e460e36bbbb41ef44fd296a27086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current and maximum transmit power levels of the local Controller on the ACL connection identified by the Connection_Handle parameter and the PHY indicated by the PHY parameter.  <a href="group___h_c_i___commands.html#ga15a4e460e36bbbb41ef44fd296a27086">More...</a><br /></td></tr>
<tr class="separator:ga15a4e460e36bbbb41ef44fd296a27086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de9ea1d14804c972bb2011c4a797cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga8de9ea1d14804c972bb2011c4a797cc4">hci_le_read_remote_transmit_power_level</a> (uint16_t Connection_Handle, uint8_t PHY)</td></tr>
<tr class="memdesc:ga8de9ea1d14804c972bb2011c4a797cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the transmit power level used by the remote Controller on the ACL connection that is identified by the Connection_Handle parameter and the PHY indicated by the PHY parameter. Initiate a Power Control Request procedure to obtain the remote transmit power level if no prior value is available or used.  <a href="group___h_c_i___commands.html#ga8de9ea1d14804c972bb2011c4a797cc4">More...</a><br /></td></tr>
<tr class="separator:ga8de9ea1d14804c972bb2011c4a797cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d310ddc155fef963897c1d83a13229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gad1d310ddc155fef963897c1d83a13229">hci_le_set_path_loss_reporting_parameters</a> (uint16_t Connection_Handle, uint8_t High_Threshold, uint8_t High_Hysteresis, uint8_t Low_Threshold, uint8_t Low_Hysteresis, uint16_t Min_Time_Spent)</td></tr>
<tr class="memdesc:gad1d310ddc155fef963897c1d83a13229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path loss threshold reporting parameters for the ACL connection identified by the Connection_Handle parameter.  <a href="group___h_c_i___commands.html#gad1d310ddc155fef963897c1d83a13229">More...</a><br /></td></tr>
<tr class="separator:gad1d310ddc155fef963897c1d83a13229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea63e4869cd1163caf03f848f801c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga3ea63e4869cd1163caf03f848f801c2d">hci_le_set_path_loss_reporting_enable</a> (uint16_t Connection_Handle, uint8_t Enable)</td></tr>
<tr class="memdesc:ga3ea63e4869cd1163caf03f848f801c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable path loss reporting for the ACL connection identified by the Connection_Handle parameter. Initiate a new Power Control Request procedure to obtain the remote transmit power level if no prior value is available or used and no prior Power Control Request procedure has been initiated. Path loss reporting is disabled when the connection is first created.  <a href="group___h_c_i___commands.html#ga3ea63e4869cd1163caf03f848f801c2d">More...</a><br /></td></tr>
<tr class="separator:ga3ea63e4869cd1163caf03f848f801c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9b15e31e8f03ee4e79e807aa7883fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#gaad9b15e31e8f03ee4e79e807aa7883fe">hci_le_set_transmit_power_reporting_enable</a> (uint16_t Connection_Handle, uint8_t Local_Enable, uint8_t Remote_Enable)</td></tr>
<tr class="memdesc:gaad9b15e31e8f03ee4e79e807aa7883fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the reporting of transmit power level changes in the local and remote Controllers for the ACL connection identified by the Connection_Handle parameter. Initiate a new Power Control Request procedure to obtain the remote transmit power level if Remote_Enable is 0x01, and no prior value is available or used, and no prior Power Control Request procedure has been initiated.  <a href="group___h_c_i___commands.html#gaad9b15e31e8f03ee4e79e807aa7883fe">More...</a><br /></td></tr>
<tr class="separator:gaad9b15e31e8f03ee4e79e807aa7883fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2678c233b7fa0a077cb14b943b7bb4da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___commands.html#ga2678c233b7fa0a077cb14b943b7bb4da">hci_tx_acl_data</a> (uint16_t Connection_Handle, uint8_t PB_Flag, uint8_t BC_Flag, uint16_t Data_Length, uint8_t *PDU_Data)</td></tr>
<tr class="memdesc:ga2678c233b7fa0a077cb14b943b7bb4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">API used to send HCI ACL Data Packets to exchange data between the Host and Controller.  <a href="group___h_c_i___commands.html#ga2678c233b7fa0a077cb14b943b7bb4da">More...</a><br /></td></tr>
<tr class="separator:ga2678c233b7fa0a077cb14b943b7bb4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef44bd31c986a61336642b7ed9850b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#gaaef44bd31c986a61336642b7ed9850b8">hci_le_receiver_test</a> (uint8_t RX_Frequency)</td></tr>
<tr class="memdesc:gaaef44bd31c986a61336642b7ed9850b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT receives test reference packets at a fixed interval. The tester generates the test reference packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.28)  <a href="group___h_c_i___test___commands.html#gaaef44bd31c986a61336642b7ed9850b8">More...</a><br /></td></tr>
<tr class="separator:gaaef44bd31c986a61336642b7ed9850b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0dac0026aad398b4c508e1b7a0f5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#gaef0dac0026aad398b4c508e1b7a0f5a2">hci_le_transmitter_test</a> (uint8_t TX_Frequency, uint8_t Length_Of_Test_Data, uint8_t Packet_Payload)</td></tr>
<tr class="memdesc:gaef0dac0026aad398b4c508e1b7a0f5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at maximum power. An LE Controller supporting the LE_Transmitter_Test command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller may support other values of Packet_Payload. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.29)  <a href="group___h_c_i___test___commands.html#gaef0dac0026aad398b4c508e1b7a0f5a2">More...</a><br /></td></tr>
<tr class="separator:gaef0dac0026aad398b4c508e1b7a0f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0091c01b705edc41999aac607769b76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#ga0091c01b705edc41999aac607769b76e">hci_le_test_end</a> (uint16_t *Number_Of_Packets)</td></tr>
<tr class="memdesc:ga0091c01b705edc41999aac607769b76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to stop any test which is in progress. The Number_Of_Packets for a transmitter test shall be reported as 0x0000. The Number_Of_Packets is an unsigned number and contains the number of received packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.30)  <a href="group___h_c_i___test___commands.html#ga0091c01b705edc41999aac607769b76e">More...</a><br /></td></tr>
<tr class="separator:ga0091c01b705edc41999aac607769b76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277ca97f02be61730e03237d292804e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#ga277ca97f02be61730e03237d292804e2">hci_le_enhanced_receiver_test</a> (uint8_t RX_Channel, uint8_t PHY, uint8_t Modulation_index)</td></tr>
<tr class="memdesc:ga277ca97f02be61730e03237d292804e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT receives test reference packets at a fixed interval. The tester generates the test reference packets.  <a href="group___h_c_i___test___commands.html#ga277ca97f02be61730e03237d292804e2">More...</a><br /></td></tr>
<tr class="separator:ga277ca97f02be61730e03237d292804e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56fbbbbc3474d507f637e0b5a24ad984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#ga56fbbbbc3474d507f637e0b5a24ad984">hci_le_enhanced_transmitter_test</a> (uint8_t TX_Channel, uint8_t Length_Of_Test_Data, uint8_t Packet_Payload, uint8_t PHY)</td></tr>
<tr class="memdesc:ga56fbbbbc3474d507f637e0b5a24ad984"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at maximum power. An LE Controller supporting the LE_Enhanced Transmitter_Test command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller supporting the LE Coded PHY shall also support Packet_Payload value 0x04. An LE Controller may support other values of Packet_Payload.  <a href="group___h_c_i___test___commands.html#ga56fbbbbc3474d507f637e0b5a24ad984">More...</a><br /></td></tr>
<tr class="separator:ga56fbbbbc3474d507f637e0b5a24ad984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd834f5cd2013d52b83d174f63eef90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#ga3fd834f5cd2013d52b83d174f63eef90">hci_le_receiver_test_v3</a> (uint8_t RX_Channel, uint8_t PHY, uint8_t Modulation_Index, uint8_t Expected_CTE_Length, uint8_t Expected_CTE_Type, uint8_t Slot_Durations, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[])</td></tr>
<tr class="memdesc:ga3fd834f5cd2013d52b83d174f63eef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT receives test reference packets at a fixed interval. The tester generates the test reference packets. The RX_Channel and PHY parameters specify the RF channel and PHY to be used by the receiver. If the Host sets the PHY parameter to a PHY that the Controller does not support, including a value that is reserved for future use, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). The Modulation_Index parameter specifies whether or not the Controller should assume the receiver has a stable modulation index. The Expected_CTE_Length and Expected_CTE_Type parameters specify the expected length and type of the Constant Tone Extensions in received test reference packets. When receiving on a PHY that allows Constant Tone Extensions, if the Constant Tone Extension in a received test reference packet does not match both of these, the DUT shall discard that packet. If Expected_CTE_Length is not zero and PHY specifies a PHY that does not allow Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C). If the Slot_Durations parameter is set to 0x01 and the Controller does not support 1 microsecond switching and sampling, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). Slot_Durations, Switching_Pattern_Length, and Antenna_IDs[i] are only used when expecting an AoA Constant Tone Extension and shall be ignored when expecting an AoD Constant Tone Extension. If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna.  <a href="group___h_c_i___test___commands.html#ga3fd834f5cd2013d52b83d174f63eef90">More...</a><br /></td></tr>
<tr class="separator:ga3fd834f5cd2013d52b83d174f63eef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a2b9220f1949b4b5d0b3d19d994143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#ga44a2b9220f1949b4b5d0b3d19d994143">hci_le_transmitter_test_v3</a> (uint8_t TX_Channel, uint8_t Test_Data_Length, uint8_t Packet_Payload, uint8_t PHY, uint8_t CTE_Length, uint8_t CTE_Type, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[])</td></tr>
<tr class="memdesc:ga44a2b9220f1949b4b5d0b3d19d994143"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at the power level indicated by the Transmit_Power_Level parameter. The TX_Channel and PHY parameters specify the RF channel and PHY to be used by the transmitter. If the Host sets the PHY parameter to a PHY that the Controller does not support, including a value that is reserved for future use, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). The Test_Data_Length and Packet_Payload parameters specify the length and contents of the Payload of the test reference packets. An LE Controller supporting the HCI_LE_Transmitter_Test command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller supporting the LE Coded PHY shall also support Packet_Payload value 0x04. An LE Controller may support other values of Packet_Payload. The CTE_Length and CTE_Type parameters specify the length and type of the Constant Tone Extension in the test reference packets. If the CTE_Type parameter is set to 0x01 and the Controller does not support 1 microsecond switching, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If CTE_Length is not zero and PHY specifies a PHY that does not allow Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C). The Switching_Pattern_Length and Antenna_IDs[i] parameters specify the antenna switching pattern. They are only used when transmitting an AoD Constant Tone Extension and shall be ignored when transmitting an AoA Constant Tone Extension. If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna. The Transmit_Power_Level parameter specifies the transmit power level to be used by the transmitter. If the parameter is set to a value other than 0x7E or 0x7F, then the Controller shall make the requested change or shall make the nearest change that it is capable of doing.  <a href="group___h_c_i___test___commands.html#ga44a2b9220f1949b4b5d0b3d19d994143">More...</a><br /></td></tr>
<tr class="separator:ga44a2b9220f1949b4b5d0b3d19d994143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c52f583ebd967699f652dca335254ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___test___commands.html#ga9c52f583ebd967699f652dca335254ac">hci_le_transmitter_test_v4</a> (uint8_t TX_Channel, uint8_t Test_Data_Length, uint8_t Packet_Payload, uint8_t PHY, uint8_t CTE_Length, uint8_t CTE_Type, uint8_t Switching_Pattern_Length, uint8_t Antenna_IDs[], int8_t Transmit_Power_Level)</td></tr>
<tr class="memdesc:ga9c52f583ebd967699f652dca335254ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at the power level indicated by the Transmit_Power_Level parameter. The TX_Channel and PHY parameters specify the RF channel and PHY to be used by the transmitter. If the Host sets the PHY parameter to a PHY that the Controller does not support, including a value that is reserved for future use, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). The Test_Data_Length and Packet_Payload parameters specify the length and contents of the Payload of the test reference packets. An LE Controller supporting the HCI_LE_Transmitter_Test command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller supporting the LE Coded PHY shall also support Packet_Payload value 0x04. An LE Controller may support other values of Packet_Payload. The CTE_Length and CTE_Type parameters specify the length and type of the Constant Tone Extension in the test reference packets. If the CTE_Type parameter is set to 0x01 and the Controller does not support 1 microsecond switching, the Controller shall return the error code Unsupported Feature or Parameter Value (0x11). If CTE_Length is not zero and PHY specifies a PHY that does not allow Constant Tone Extensions, the Controller shall return the error code Command Disallowed (0x0C). The Switching_Pattern_Length and Antenna_IDs[i] parameters specify the antenna switching pattern. They are only used when transmitting an AoD Constant Tone Extension and shall be ignored when transmitting an AoA Constant Tone Extension. If the Controller determines that any of the Antenna_IDs[i] values do not identify an antenna in the device's antenna array, it shall return the error code Unsupported Feature or Parameter Value (0x11). Note: Some Controllers may be unable to determine which values do or do not identify an antenna. The Transmit_Power_Level parameter specifies the transmit power level to be used by the transmitter. If the parameter is set to a value other than 0x7E or 0x7F, then the Controller shall make the requested change or shall make the nearest change that it is capable of doing.  <a href="group___h_c_i___test___commands.html#ga9c52f583ebd967699f652dca335254ac">More...</a><br /></td></tr>
<tr class="separator:ga9c52f583ebd967699f652dca335254ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3b1087da93be369db1b1297ee2cb97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga7b3b1087da93be369db1b1297ee2cb97">aci_hal_get_fw_build_number</a> (uint16_t *Build_Number)</td></tr>
<tr class="memdesc:ga7b3b1087da93be369db1b1297ee2cb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the build number associated with the firmware version currently running.  <a href="group___h_a_l___commands.html#ga7b3b1087da93be369db1b1297ee2cb97">More...</a><br /></td></tr>
<tr class="separator:ga7b3b1087da93be369db1b1297ee2cb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa694cc1ba16fb65a85c50acfb0f9d028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gaa694cc1ba16fb65a85c50acfb0f9d028">aci_hal_write_config_data</a> (uint8_t Offset, uint8_t Length, uint8_t Value[])</td></tr>
<tr class="memdesc:gaa694cc1ba16fb65a85c50acfb0f9d028"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command writes a value to a low level configure data structure. It is useful to setup directly some low level parameters for the system in the runtime.NOTE: This command shall not be called if a command different than Stack Init, HCI_RESET, ACI_HAL_WRITE_CONFIG_DATA or ACI_HAL_READ_CONFIG_DATA has already been called.  <a href="group___h_a_l___commands.html#gaa694cc1ba16fb65a85c50acfb0f9d028">More...</a><br /></td></tr>
<tr class="separator:gaa694cc1ba16fb65a85c50acfb0f9d028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525ce45a611421ae48dd43c8e32f0b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga525ce45a611421ae48dd43c8e32f0b67">aci_hal_read_config_data</a> (uint8_t Offset, uint8_t *Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga525ce45a611421ae48dd43c8e32f0b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests the value in the low level configure data structure. The number of read bytes changes for different Offset.  <a href="group___h_a_l___commands.html#ga525ce45a611421ae48dd43c8e32f0b67">More...</a><br /></td></tr>
<tr class="separator:ga525ce45a611421ae48dd43c8e32f0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8ce6409d339fcfdad69607cf4f25d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga4d8ce6409d339fcfdad69607cf4f25d8">aci_hal_set_tx_power_level</a> (uint8_t En_High_Power, uint8_t PA_Level)</td></tr>
<tr class="memdesc:ga4d8ce6409d339fcfdad69607cf4f25d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the TX power level of the device for all the radio activities, unless explicitly defined by other commands. The combination of En_High_Power and PA_Level parameters determines the output power level (dBm). When the system starts up or reboots, the default TX power level will be used, which is En_High_Power = 0 and PA_Level = 31. After this command is given, the new output power will be used only for new Link Layer state machines, i.e. for new Bluetooth activities, i.e. new advertising sets, new connections, new scanning procedures. For current activities the output power will not change. The only exception is for AUX_SCAN_REQ and AUX_CONNECT_REQ PDUs, for which the new output power will immediately take effect also for the current scanning procedure.  <a href="group___h_a_l___commands.html#ga4d8ce6409d339fcfdad69607cf4f25d8">More...</a><br /></td></tr>
<tr class="separator:ga4d8ce6409d339fcfdad69607cf4f25d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e145d90c77f62a854d65321d99dfb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga9e145d90c77f62a854d65321d99dfb5a">aci_hal_le_tx_test_packet_number</a> (uint32_t *Number_Of_Packets)</td></tr>
<tr class="memdesc:ga9e145d90c77f62a854d65321d99dfb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the number of packets sent in Direct Test Mode. When the Direct TX test is started, a 32-bit counter is used to count how many packets have been transmitted. This command can be used to check how many packets have been sent during the Direct TX test. The counter starts from 0 and counts upwards. The counter can wrap and start from 0 again. The counter is not cleared until the next Direct TX test starts.  <a href="group___h_a_l___commands.html#ga9e145d90c77f62a854d65321d99dfb5a">More...</a><br /></td></tr>
<tr class="separator:ga9e145d90c77f62a854d65321d99dfb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace555eb4b9f225d874f946aa920de1f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gace555eb4b9f225d874f946aa920de1f5">aci_hal_tone_start</a> (uint8_t RF_Channel, uint8_t Offset)</td></tr>
<tr class="memdesc:gace555eb4b9f225d874f946aa920de1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command starts a carrier frequency, i.e. a tone, on a specific channel. The frequency sine wave at the specific channel may be used for debugging purpose only. The channel ID is a parameter from 0x00 to 0x27 for the 40 BLE channels, e.g. 0x00 for 2.402 GHz, 0x01 for 2.404 GHz etc. This command should not be used when normal Bluetooth activities are ongoing. The tone should be stopped by <a class="el" href="group___h_a_l___commands.html#ga77e0497ce0ec8bbb0d9e5495ff6c7027">aci_hal_tone_stop</a> command.  <a href="group___h_a_l___commands.html#gace555eb4b9f225d874f946aa920de1f5">More...</a><br /></td></tr>
<tr class="separator:gace555eb4b9f225d874f946aa920de1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e0497ce0ec8bbb0d9e5495ff6c7027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga77e0497ce0ec8bbb0d9e5495ff6c7027">aci_hal_tone_stop</a> (void)</td></tr>
<tr class="memdesc:ga77e0497ce0ec8bbb0d9e5495ff6c7027"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to stop the previously started <a class="el" href="group___h_a_l___commands.html#gace555eb4b9f225d874f946aa920de1f5">aci_hal_tone_start</a> command.  <a href="group___h_a_l___commands.html#ga77e0497ce0ec8bbb0d9e5495ff6c7027">More...</a><br /></td></tr>
<tr class="separator:ga77e0497ce0ec8bbb0d9e5495ff6c7027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed15c252a5203a862f47071fd92af426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gaed15c252a5203a862f47071fd92af426">aci_hal_get_link_status</a> (uint8_t Bank_index, uint8_t Link_Status[8], uint16_t Link_Connection_Handle[16/2])</td></tr>
<tr class="memdesc:gaed15c252a5203a862f47071fd92af426"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the status of the Bluetooth low energy links managed by the device.  <a href="group___h_a_l___commands.html#gaed15c252a5203a862f47071fd92af426">More...</a><br /></td></tr>
<tr class="separator:gaed15c252a5203a862f47071fd92af426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120ca17ceac401485f6281f2037126b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga120ca17ceac401485f6281f2037126b0">aci_hal_set_radio_activity_mask</a> (uint16_t Radio_Activity_Mask)</td></tr>
<tr class="memdesc:ga120ca17ceac401485f6281f2037126b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command set the bitmask associated to <a class="el" href="group___h_a_l__events.html#ga5be9dbe2c8fc3758a12ee9c5e8a95d86">aci_hal_end_of_radio_activity_event</a>. Only the radio activities enabled in the mask will be reported to application by <a class="el" href="group___h_a_l__events.html#ga5be9dbe2c8fc3758a12ee9c5e8a95d86">aci_hal_end_of_radio_activity_event</a>.  <a href="group___h_a_l___commands.html#ga120ca17ceac401485f6281f2037126b0">More...</a><br /></td></tr>
<tr class="separator:ga120ca17ceac401485f6281f2037126b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b21a27d40d972697c5b63a0f54f8829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga4b21a27d40d972697c5b63a0f54f8829">aci_hal_set_event_mask</a> (uint32_t Event_Mask)</td></tr>
<tr class="separator:ga4b21a27d40d972697c5b63a0f54f8829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c07730fef22ac5d4bae20d82136e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga37c07730fef22ac5d4bae20d82136e0b">aci_hal_set_le_power_control</a> (uint8_t Enable, uint8_t PHY, int8_t RSSI_Target, uint8_t RSSI_Hysteresis, int8_t Initial_TX_Power, uint8_t RSSI_Filtering_Coefficient)</td></tr>
<tr class="memdesc:ga37c07730fef22ac5d4bae20d82136e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to enable or disable the LE Power Control feature and procedure for a given PHY on the later established connections. It also provides the parameters that let the Controller initiate the LE Power Control procedure. In particular, the procedure will be initiated when the current (average) RSSI (say Curr_Avg_RSSI) gets: * Less than (RSSI_Target - RSSI_Hysteresis) and the Controller will request the peer to increase its TX power level for the given PHY by (RSSI_Target - Curr_Avg_RSSI). * Greater than (RSSI_Target + RSSI_Hysteresis) and the Controller will request the peer to decrease its TX power level for the given PHY by (Curr_Avg_RSSI - RSSI_Target). The Controller will start transmitting on the connections for which the power control is enabled and for the given PHY using the Initial_Tx_Power value. It will change its TX power based on the requests or feedbacks from the peer: * If the peer initiates an LE Power Control procedure and requests to increase or decrease the TX power of a given delta, the TX power will be increased or reduced by the requested delta within the acceptable limits. * If the peer reports that it can accept a TX power reduction of a given delta, the TX power will be reduced by the reported delta within the acceptable limits. If this command is not issued, the Controller will use the parameter default values.  <a href="group___h_a_l___commands.html#ga37c07730fef22ac5d4bae20d82136e0b">More...</a><br /></td></tr>
<tr class="separator:ga37c07730fef22ac5d4bae20d82136e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666ca78158f0a80f0b87dfefc2a2dab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga666ca78158f0a80f0b87dfefc2a2dab9">aci_hal_write_radio_reg</a> (uint32_t Start_Address, uint8_t Num_Bytes, uint8_t Data[])</td></tr>
<tr class="separator:ga666ca78158f0a80f0b87dfefc2a2dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aec481d39857c253bbd275c2f164f35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga8aec481d39857c253bbd275c2f164f35">aci_hal_read_radio_reg</a> (uint32_t Start_Address, uint8_t Num_Bytes, uint8_t *Data_Length, uint8_t Data[])</td></tr>
<tr class="separator:ga8aec481d39857c253bbd275c2f164f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf421b3bfad78c683ed1e28ae28b972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gabaf421b3bfad78c683ed1e28ae28b972">aci_hal_get_evt_fifo_max_level</a> (uint16_t *ISR0_FIFO_Max_Level, uint16_t *ISR1_FIFO_Max_Level, uint16_t *User_FIFO_Max_Level)</td></tr>
<tr class="memdesc:gabaf421b3bfad78c683ed1e28ae28b972"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to get the maximum used size of the stack's internal FIFO queues: isr1_fifo, isr2_fifo and user_fifo. These values can be used to chose the maximum correct size for the queues, which can be set through the <a class="el" href="bluenrg__lp__stack_8h.html#a11812007ec5cb7d6887e3038d3b58fe0" title="The BLE Stack initialization routine. ">BLE_STACK_Init()</a> function. If one of these queues reaches the maximum size, an hci_hardware_error_event is raised, with error code 0x03.  <a href="group___h_a_l___commands.html#gabaf421b3bfad78c683ed1e28ae28b972">More...</a><br /></td></tr>
<tr class="separator:gabaf421b3bfad78c683ed1e28ae28b972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8bb02371eb7dc24cca16e256a97b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gadb8bb02371eb7dc24cca16e256a97b62">ll_set_legacy_advertising_data_ptr</a> (uint8_t Data_Length, uint8_t *Data)</td></tr>
<tr class="memdesc:gadb8bb02371eb7dc24cca16e256a97b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data pointer for legacy advertising data.  <a href="group___h_a_l___commands.html#gadb8bb02371eb7dc24cca16e256a97b62">More...</a><br /></td></tr>
<tr class="separator:gadb8bb02371eb7dc24cca16e256a97b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf38e24bbc4aca372dea841d952f79c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gacf38e24bbc4aca372dea841d952f79c8">ll_set_legacy_scan_reponse_data_ptr</a> (uint8_t Data_Length, uint8_t *Data)</td></tr>
<tr class="memdesc:gacf38e24bbc4aca372dea841d952f79c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data pointer for legacy scan response data.  <a href="group___h_a_l___commands.html#gacf38e24bbc4aca372dea841d952f79c8">More...</a><br /></td></tr>
<tr class="separator:gacf38e24bbc4aca372dea841d952f79c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36aa689381c71f1ed70dc2ec7563a794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga36aa689381c71f1ed70dc2ec7563a794">ll_set_advertising_data_ptr</a> (uint16_t Advertising_Handle, uint8_t Operation, uint16_t Advertising_Data_Length, uint8_t Advertising_Data[])</td></tr>
<tr class="memdesc:ga36aa689381c71f1ed70dc2ec7563a794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data pointer for extended advertising data.  <a href="group___h_a_l___commands.html#ga36aa689381c71f1ed70dc2ec7563a794">More...</a><br /></td></tr>
<tr class="separator:ga36aa689381c71f1ed70dc2ec7563a794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da4fa285ba49a3e748e4a39d688fc38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga0da4fa285ba49a3e748e4a39d688fc38">ll_set_scan_reponse_data_ptr</a> (uint16_t Advertising_Handle, uint16_t Scan_Response_Data_Length, uint8_t Scan_Response_Data[])</td></tr>
<tr class="memdesc:ga0da4fa285ba49a3e748e4a39d688fc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data pointer for extended scan response data.  <a href="group___h_a_l___commands.html#ga0da4fa285ba49a3e748e4a39d688fc38">More...</a><br /></td></tr>
<tr class="separator:ga0da4fa285ba49a3e748e4a39d688fc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2f5db020d2bc56a98c75d72a85b063f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#gab2f5db020d2bc56a98c75d72a85b063f">ll_get_advertising_info</a> (uint16_t Advertising_Handle, BOOL *Adv_Enabled, BOOL *Periodic_Adv_Configured, BOOL *Periodic_Adv_Enabled, uint16_t *Advertising_Event_Properties)</td></tr>
<tr class="memdesc:gab2f5db020d2bc56a98c75d72a85b063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves info about an existing advertising set.  <a href="group___h_a_l___commands.html#gab2f5db020d2bc56a98c75d72a85b063f">More...</a><br /></td></tr>
<tr class="separator:gab2f5db020d2bc56a98c75d72a85b063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91bacaacc5ff98387a2f9d8ec09a133d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga91bacaacc5ff98387a2f9d8ec09a133d">ll_set_periodic_advertising_data_ptr</a> (uint16_t Advertising_Handle, uint16_t Advertising_Data_Length, uint8_t Advertising_Data[])</td></tr>
<tr class="memdesc:ga91bacaacc5ff98387a2f9d8ec09a133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data pointer for periodic extended advertising data.  <a href="group___h_a_l___commands.html#ga91bacaacc5ff98387a2f9d8ec09a133d">More...</a><br /></td></tr>
<tr class="separator:ga91bacaacc5ff98387a2f9d8ec09a133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc65795b5505545d2b7c9d4d7cd69d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___commands.html#ga3cc65795b5505545d2b7c9d4d7cd69d4">aci_hal_get_anchor_point</a> (uint16_t Connection_Handle, uint16_t *Event_Counter, uint32_t *Anchor_Point)</td></tr>
<tr class="memdesc:ga3cc65795b5505545d2b7c9d4d7cd69d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the value of the last anchor point for the given connection.  <a href="group___h_a_l___commands.html#ga3cc65795b5505545d2b7c9d4d7cd69d4">More...</a><br /></td></tr>
<tr class="separator:ga3cc65795b5505545d2b7c9d4d7cd69d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e39b68644bdc0149ea9270427715cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaf7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> (uint8_t IO_Capability)</td></tr>
<tr class="memdesc:gaf7e39b68644bdc0149ea9270427715cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IO capabilities of the device. This command cannot be sent during a pairing procedure.  <a href="group___g_a_p___commands.html#gaf7e39b68644bdc0149ea9270427715cd">More...</a><br /></td></tr>
<tr class="separator:gaf7e39b68644bdc0149ea9270427715cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93db72dc4b21ebd8ad8462e85714286a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga93db72dc4b21ebd8ad8462e85714286a">aci_gap_set_authentication_requirement</a> (uint8_t Bonding_Mode, uint8_t MITM_Mode, uint8_t SC_Support, uint8_t KeyPress_Notification_Support, uint8_t Min_Encryption_Key_Size, uint8_t Max_Encryption_Key_Size, uint8_t Use_Fixed_Pin, uint32_t Fixed_Pin)</td></tr>
<tr class="memdesc:ga93db72dc4b21ebd8ad8462e85714286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authentication requirements for the device. If the command is given during pairing, the command returns BLE_STATUS_NOT_ALLOWED.  <a href="group___g_a_p___commands.html#ga93db72dc4b21ebd8ad8462e85714286a">More...</a><br /></td></tr>
<tr class="separator:ga93db72dc4b21ebd8ad8462e85714286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5acbb617b13a0880a76d8f063153e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> (uint16_t Connection_Handle, uint32_t Pass_Key)</td></tr>
<tr class="memdesc:gab5acbb617b13a0880a76d8f063153e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command should be send by the host in response to <a class="el" href="group___a_c_i___g_a_p__events.html#ga4820d33fd0fa8fec40c725b78b02c913">aci_gap_pass_key_req_event</a> event. The command parameter contains the pass key which will be used during the pairing process.  <a href="group___g_a_p___commands.html#gab5acbb617b13a0880a76d8f063153e6f">More...</a><br /></td></tr>
<tr class="separator:gab5acbb617b13a0880a76d8f063153e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fbdf6ff1531cfd0ef106e7c068f8ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gab9fbdf6ff1531cfd0ef106e7c068f8ca">aci_gap_init</a> (uint8_t Role, uint8_t Privacy_Type, uint8_t Device_Name_Char_Len, uint8_t Identity_Address_Type, uint16_t *Service_Handle, uint16_t *Dev_Name_Char_Handle, uint16_t *Appearance_Char_Handle)</td></tr>
<tr class="memdesc:gab9fbdf6ff1531cfd0ef106e7c068f8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the GAP layer. Register the GAP service with the GATT. Depending on the role, presence of standard GAP characteristics will be checked (Device Name, Appearance, Peripheral Preferred Connection Parameters). WARNING: A section of the Flash memory is used by this procedure. When this section is empty, data are written inside. This normally happens once during the lifetime of the device, when the command is executed for the first time (unless the section is erased). Do not power off the device while this function is writing into Flash memory.  <a href="group___g_a_p___commands.html#gab9fbdf6ff1531cfd0ef106e7c068f8ca">More...</a><br /></td></tr>
<tr class="separator:gab9fbdf6ff1531cfd0ef106e7c068f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga80162feee4f10fbfce5099ba0a7a61ba">aci_gap_slave_security_req</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a slave security request to the master. This command has to be issued to notify the master of the security requirements of the slave. The master may encrypt the link, initiate the pairing procedure, or reject the request.  <a href="group___g_a_p___commands.html#ga80162feee4f10fbfce5099ba0a7a61ba">More...</a><br /></td></tr>
<tr class="separator:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cec916e46fb9e000b119f70d645f5fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga1cec916e46fb9e000b119f70d645f5fa">aci_gap_get_security_level</a> (uint16_t Connection_Handle, uint8_t *Security_Mode, uint8_t *Security_Level)</td></tr>
<tr class="memdesc:ga1cec916e46fb9e000b119f70d645f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to get the current security settings of the device.  <a href="group___g_a_p___commands.html#ga1cec916e46fb9e000b119f70d645f5fa">More...</a><br /></td></tr>
<tr class="separator:ga1cec916e46fb9e000b119f70d645f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d12352d4290eab988acdc90e3da93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gad4d12352d4290eab988acdc90e3da93c">aci_gap_set_event_mask</a> (uint16_t GAP_Evt_Mask)</td></tr>
<tr class="memdesc:gad4d12352d4290eab988acdc90e3da93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It allows masking events from the GAP. The default configuration is all the events masked.  <a href="group___g_a_p___commands.html#gad4d12352d4290eab988acdc90e3da93c">More...</a><br /></td></tr>
<tr class="separator:gad4d12352d4290eab988acdc90e3da93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> (uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command the controller to terminate the connection. A <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event will be generated when the link is disconnected. It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event, system could save important information in non volatile memory.  <a href="group___g_a_p___commands.html#ga7c1b1aca7489a846f3aaa25cdb9db180">More...</a><br /></td></tr>
<tr class="separator:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1909183f16d7de9676a54bab51838569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga1909183f16d7de9676a54bab51838569">aci_gap_clear_security_db</a> (void)</td></tr>
<tr class="memdesc:ga1909183f16d7de9676a54bab51838569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the security database. All the devices in the security database will be removed. ATTENTION: It is strongly recommended not to give this command during intense radio activity (e.g. during advertising or connection with short intervals, i.e. less than 30 ms, or during scanning), since it will trigger an erase of a Flash sector. After this command, all devices previously recorded in the bonding table and connected when command has been submitted will remain connected, preserving authentication and encryption of the link.  <a href="group___g_a_p___commands.html#ga1909183f16d7de9676a54bab51838569">More...</a><br /></td></tr>
<tr class="separator:ga1909183f16d7de9676a54bab51838569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga76f91fc19683eb9f6ed8d217648b0c82">aci_gap_allow_rebond</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the security manager to complete the pairing procedure and re- bond with the master. This command should be given by the application when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re- bonding to happen successfully. If this command is not given on receiving the event, the bonding procedure will timeout.  <a href="group___g_a_p___commands.html#ga76f91fc19683eb9f6ed8d217648b0c82">More...</a><br /></td></tr>
<tr class="separator:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9221c71a4a2b2e418f0968eaa43017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaeb9221c71a4a2b2e418f0968eaa43017">aci_gap_create_connection</a> (uint8_t Initiating_PHY, uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:gaeb9221c71a4a2b2e418f0968eaa43017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a direct connection to a device.  <a href="group___g_a_p___commands.html#gaeb9221c71a4a2b2e418f0968eaa43017">More...</a><br /></td></tr>
<tr class="separator:gaeb9221c71a4a2b2e418f0968eaa43017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2ec6c3f9d58ece3aaf562c540c2482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga8e2ec6c3f9d58ece3aaf562c540c2482">aci_gap_terminate_proc</a> (uint8_t Procedure_Code)</td></tr>
<tr class="memdesc:ga8e2ec6c3f9d58ece3aaf562c540c2482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the specified GAP procedure. An <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is generated when the procedure has been completed, with the procedure code set to the corresponding procedure.  <a href="group___g_a_p___commands.html#ga8e2ec6c3f9d58ece3aaf562c540c2482">More...</a><br /></td></tr>
<tr class="separator:ga8e2ec6c3f9d58ece3aaf562c540c2482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261529d70c766ecd28e9b1464ffb9cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga261529d70c766ecd28e9b1464ffb9cce">aci_gap_start_connection_update</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ga261529d70c766ecd28e9b1464ffb9cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the connection update procedure (only when role is Master). A <a class="el" href="group___h_c_i___commands.html#ga0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> is called. On completion of the procedure, an <a class="el" href="group___h_c_i___l_e__meta__events.html#ga40b3b0abeb955daefb6b3a860d11e0e9">hci_le_connection_update_complete_event</a> event is returned to the upper layer.  <a href="group___g_a_p___commands.html#ga261529d70c766ecd28e9b1464ffb9cce">More...</a><br /></td></tr>
<tr class="separator:ga261529d70c766ecd28e9b1464ffb9cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52ca818096a284d69d24d3d214f418d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaf52ca818096a284d69d24d3d214f418d">aci_gap_send_pairing_req</a> (uint16_t Connection_Handle, uint8_t Force_Rebond)</td></tr>
<tr class="memdesc:gaf52ca818096a284d69d24d3d214f418d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the SM pairing request to start a pairing process. The authentication requirements and IO capabilities should be set before issuing this command using the <a class="el" href="group___g_a_p___commands.html#gaf7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> and <a class="el" href="group___g_a_p___commands.html#ga93db72dc4b21ebd8ad8462e85714286a">aci_gap_set_authentication_requirement</a> commands. A <a class="el" href="group___a_c_i___g_a_p__events.html#gadc74352ad6c26c693df1390109c55923">aci_gap_pairing_complete_event</a> event is returned after the pairing process is completed.  <a href="group___g_a_p___commands.html#gaf52ca818096a284d69d24d3d214f418d">More...</a><br /></td></tr>
<tr class="separator:gaf52ca818096a284d69d24d3d214f418d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3d4c1303999072f00bbd0440968165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga4c3d4c1303999072f00bbd0440968165">aci_gap_resolve_private_addr</a> (uint8_t Address[6], uint8_t Actual_Address[6])</td></tr>
<tr class="memdesc:ga4c3d4c1303999072f00bbd0440968165"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command tries to resolve the address provided with the IRKs present in its database. If the address is resolved successfully with any one of the IRKs present in the database, it returns success and also the corresponding public/static random address stored with the IRK in the database.  <a href="group___g_a_p___commands.html#ga4c3d4c1303999072f00bbd0440968165">More...</a><br /></td></tr>
<tr class="separator:ga4c3d4c1303999072f00bbd0440968165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634e04d62df75154f84c422f9a0db3cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga634e04d62df75154f84c422f9a0db3cf">aci_gap_get_bonded_devices</a> (uint8_t Offset, uint8_t Max_Num_Of_Addresses, uint8_t *Num_of_Addresses, <a class="el" href="bluenrg__lp__api_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a> Bonded_Device_Entry[])</td></tr>
<tr class="memdesc:ga634e04d62df75154f84c422f9a0db3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the identity addresses of the bonded devices.  <a href="group___g_a_p___commands.html#ga634e04d62df75154f84c422f9a0db3cf">More...</a><br /></td></tr>
<tr class="separator:ga634e04d62df75154f84c422f9a0db3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gadf2d88d5dcb1f6dd4f154e29840c96b1">aci_gap_is_device_bonded</a> (uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command finds whether the device, whose address is specified in the command, is bonded. If the device is using a resolvable private address and it has been bonded, then the command will return BLE_STATUS_SUCCESS.  <a href="group___g_a_p___commands.html#gadf2d88d5dcb1f6dd4f154e29840c96b1">More...</a><br /></td></tr>
<tr class="separator:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> (uint16_t Connection_Handle, uint8_t Confirm_Yes_No)</td></tr>
<tr class="memdesc:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command allows the User to validate/confirm or not the Numeric Comparison value showed through the ACI_GAP_Numeric_Comparison_Value_Event.  <a href="group___g_a_p___commands.html#ga53ae1db71ecec2ba7f9dd2992185d935">More...</a><br /></td></tr>
<tr class="separator:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e97953f93b91e6a94efe65088733ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga22e97953f93b91e6a94efe65088733ed">aci_gap_passkey_input</a> (uint16_t Connection_Handle, uint8_t Input_Type)</td></tr>
<tr class="memdesc:ga22e97953f93b91e6a94efe65088733ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command permits to signal to the Stack the input type detected during Passkey input.  <a href="group___g_a_p___commands.html#ga22e97953f93b91e6a94efe65088733ed">More...</a><br /></td></tr>
<tr class="separator:ga22e97953f93b91e6a94efe65088733ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6d91556b0bc974ff8668befbae3424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga6c6d91556b0bc974ff8668befbae3424">aci_gap_get_oob_data</a> (uint8_t OOB_Data_Type, uint8_t *Address_Type, uint8_t Address[6], uint8_t *OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:ga6c6d91556b0bc974ff8668befbae3424"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager to require the local OOB data (hence without user interaction) to be sent via OOB to the remote peer candidate device. The requested OOB data are returned in response to the incoming command. The OOB data are not generated on the fly, but they are already available in the Stack.  <a href="group___g_a_p___commands.html#ga6c6d91556b0bc974ff8668befbae3424">More...</a><br /></td></tr>
<tr class="separator:ga6c6d91556b0bc974ff8668befbae3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga0894787f7dd5af1e4f1a7ae1d3844f77">aci_gap_set_oob_data</a> (uint8_t Device_Type, uint8_t Address_Type, uint8_t Address[6], uint8_t OOB_Data_Type, uint8_t OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent (by the User) to input the OOB data arrived via OOB communication. It may be sent to set either the OOB Authentication data of the Local device, or the data received via OOB by the Remote peer candidate device. It can be used with OOB_Data_Len set to 0 to generate OOB authentication data for Secure Connections. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager when receiving the OOB data (hence without user interaction). Since the BLE stack v 2.x implementation supports just one entry for the Remote peer candidate list containing the OOB data, at every command invocation the data existing in that entry are overwritten.  <a href="group___g_a_p___commands.html#ga0894787f7dd5af1e4f1a7ae1d3844f77">More...</a><br /></td></tr>
<tr class="separator:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e986dc4f7bc786707d4102acc3826ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga5e986dc4f7bc786707d4102acc3826ab">aci_gap_remove_bonded_device</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6])</td></tr>
<tr class="memdesc:ga5e986dc4f7bc786707d4102acc3826ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to remove a specified device from the bonding table. ATTENTION: the device removed from the Bonding Table will preserve its connection and authentication, until explicit disconnection is requested by the user.  <a href="group___g_a_p___commands.html#ga5e986dc4f7bc786707d4102acc3826ab">More...</a><br /></td></tr>
<tr class="separator:ga5e986dc4f7bc786707d4102acc3826ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99c92001725ba3b2c435feee340756a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gad99c92001725ba3b2c435feee340756a">aci_gap_set_advertising_configuration</a> (uint8_t Advertising_Handle, uint8_t Discoverable_Mode, uint16_t Advertising_Event_Properties, uint32_t Primary_Advertising_Interval_Min, uint32_t Primary_Advertising_Interval_Max, uint8_t Primary_Advertising_Channel_Map, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Advertising_Filter_Policy, int8_t Advertising_Tx_Power, uint8_t Primary_Advertising_PHY, uint8_t Secondary_Advertising_Max_Skip, uint8_t Secondary_Advertising_PHY, uint8_t Advertising_SID, uint8_t Scan_Request_Notification_Enable)</td></tr>
<tr class="memdesc:gad99c92001725ba3b2c435feee340756a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This commands configures the advertising parameters for the legacy advertising or for a given extended advertising set.  <a href="group___g_a_p___commands.html#gad99c92001725ba3b2c435feee340756a">More...</a><br /></td></tr>
<tr class="separator:gad99c92001725ba3b2c435feee340756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ba195a9bec784def2d98f0469d76ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga61ba195a9bec784def2d98f0469d76ae">aci_gap_set_advertising_enable</a> (uint8_t Enable, uint8_t Number_of_Sets, <a class="el" href="bluenrg__lp__api_8h.html#a008e8bf5b0efc0138300743128635701">Advertising_Set_Parameters_t</a> Advertising_Set_Parameters[])</td></tr>
<tr class="memdesc:ga61ba195a9bec784def2d98f0469d76ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Extended_Advertising_Enable command is used to request the Controller to enable or disable one or more advertising sets using the advertising sets identified by the Advertising_Handle[i] parameter. The Controller manages the timing of advertisements in accordance with the advertising parameters given in the LE_Set_Extended_Advertising_Parameters command. Only Enable parameter is used if extended advertising feature is disabled through modular configuration (CONTROLLER_EXT_ADV_SCAN_ENABLED=0).  <a href="group___g_a_p___commands.html#ga61ba195a9bec784def2d98f0469d76ae">More...</a><br /></td></tr>
<tr class="separator:ga61ba195a9bec784def2d98f0469d76ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec55458d3bdfba5ffae6144c904e945d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaec55458d3bdfba5ffae6144c904e945d">aci_gap_set_scan_configuration</a> (uint8_t Filter_Duplicates, uint8_t Scanning_Filter_Policy, uint8_t Scanning_PHY, uint8_t Scan_Type, uint16_t Scan_Interval, uint16_t Scan_Window)</td></tr>
<tr class="memdesc:gaec55458d3bdfba5ffae6144c904e945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_SET_SCAN_CONFIGURATION function configures the scan parameters for a given PHY. To configure more than one PHY, this function must be called more times.  <a href="group___g_a_p___commands.html#gaec55458d3bdfba5ffae6144c904e945d">More...</a><br /></td></tr>
<tr class="separator:gaec55458d3bdfba5ffae6144c904e945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461391be847b0d4fa9a63b01a85f863a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga461391be847b0d4fa9a63b01a85f863a">aci_gap_set_connection_configuration</a> (uint8_t Initiating_PHY, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ga461391be847b0d4fa9a63b01a85f863a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the connection parameters. To configure more than one PHY, this function must be called more times.  <a href="group___g_a_p___commands.html#ga461391be847b0d4fa9a63b01a85f863a">More...</a><br /></td></tr>
<tr class="separator:ga461391be847b0d4fa9a63b01a85f863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94a53c0e6abaf24bca2b573c83be253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaa94a53c0e6abaf24bca2b573c83be253">aci_gap_start_procedure</a> (uint8_t Procedure_Code, uint8_t PHYs, uint16_t Duration, uint16_t Period)</td></tr>
<tr class="memdesc:gaa94a53c0e6abaf24bca2b573c83be253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a GAP procedure according to the procedure code.  <a href="group___g_a_p___commands.html#gaa94a53c0e6abaf24bca2b573c83be253">More...</a><br /></td></tr>
<tr class="separator:gaa94a53c0e6abaf24bca2b573c83be253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e0bd270bd21a404cc952c2ab7e067d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga72e0bd270bd21a404cc952c2ab7e067d">aci_gap_discover_name</a> (uint8_t PHYs, uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:ga72e0bd270bd21a404cc952c2ab7e067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a direct connection to a device and read the name characteristic.  <a href="group___g_a_p___commands.html#ga72e0bd270bd21a404cc952c2ab7e067d">More...</a><br /></td></tr>
<tr class="separator:ga72e0bd270bd21a404cc952c2ab7e067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68530e68fa618d8ce96d2c2c006a29f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga68530e68fa618d8ce96d2c2c006a29f2">aci_gap_add_devices_to_white_and_resolving_list</a> (uint8_t Lists, uint8_t Clear_Lists, uint8_t Num_of_List_Entries, <a class="el" href="bluenrg__lp__api_8h.html#a8a6cc258fb3bbb4a398ce7b4c76cca17">List_Entry_t</a> List_Entry[])</td></tr>
<tr class="memdesc:ga68530e68fa618d8ce96d2c2c006a29f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add specific device addresses to the white and/or resolving list.  <a href="group___g_a_p___commands.html#ga68530e68fa618d8ce96d2c2c006a29f2">More...</a><br /></td></tr>
<tr class="separator:ga68530e68fa618d8ce96d2c2c006a29f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be583574e0ae167112277503b71f925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga4be583574e0ae167112277503b71f925">aci_gap_configure_white_and_resolving_list</a> (uint8_t Lists)</td></tr>
<tr class="memdesc:ga4be583574e0ae167112277503b71f925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the specified lists and add all bonded devices.  <a href="group___g_a_p___commands.html#ga4be583574e0ae167112277503b71f925">More...</a><br /></td></tr>
<tr class="separator:ga4be583574e0ae167112277503b71f925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac63f87d4d477f7c58d701fa184a1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaaac63f87d4d477f7c58d701fa184a1e8">aci_gap_set_periodic_advertising_configuration</a> (uint8_t Advertising_Handle, uint16_t Periodic_Advertising_Interval_Min, uint16_t Periodic_Advertising_Interval_Max, uint16_t Periodic_Advertising_Properties)</td></tr>
<tr class="memdesc:gaaac63f87d4d477f7c58d701fa184a1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Set_Periodic_Advertising_Configuration command is used by the Host to set the parameters for periodic advertising. See <a class="el" href="group___h_c_i___commands.html#ga5a80e0eab1c661162a10df5afa109c00" title="The LE_Set_Periodic_Advertising_Parameters command is used by the Host to set the parameters for peri...">hci_le_set_periodic_advertising_parameters()</a>.  <a href="group___g_a_p___commands.html#gaaac63f87d4d477f7c58d701fa184a1e8">More...</a><br /></td></tr>
<tr class="separator:gaaac63f87d4d477f7c58d701fa184a1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238408c58eeacca58748c8da0d210b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga238408c58eeacca58748c8da0d210b26">aci_gap_set_periodic_advertising_enable</a> (uint8_t Enable, uint8_t Advertising_Handle)</td></tr>
<tr class="memdesc:ga238408c58eeacca58748c8da0d210b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Set_Periodic_Advertising_Enable command is used to request the Controller to enable or disable the periodic advertising for the advertising set specified by the Advertising_Handle parameter (ordinary advertising is not affected). See <a class="el" href="group___h_c_i___commands.html#gaa6d49eb3003deac9de6f361e39281df2" title="The LE_Set_Periodic_Advertising_Enable command is used to request the Controller to enable or disable...">hci_le_set_periodic_advertising_enable()</a>.  <a href="group___g_a_p___commands.html#ga238408c58eeacca58748c8da0d210b26">More...</a><br /></td></tr>
<tr class="separator:ga238408c58eeacca58748c8da0d210b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c155356e81009bde728be19f603f9a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga1c155356e81009bde728be19f603f9a7">aci_gap_periodic_advertising_create_sync</a> (uint8_t Options, uint8_t Advertising_SID, uint8_t Advertising_Address_Type, uint8_t Advertiser_Address[6], uint16_t Skip, uint16_t Sync_Timeout, uint8_t Sync_CTE_Type)</td></tr>
<tr class="memdesc:ga1c155356e81009bde728be19f603f9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Periodic_Advertising_Create_Sync command is used to synchronize with periodic advertising from an advertiser and begin receiving periodic advertising packets. See <a class="el" href="group___h_c_i___commands.html#gab263377ee3fdb92f62d5a42618395dfb" title="The LE_Periodic_Advertising_Create_Sync command is used to synchronize with periodic advertising from...">hci_le_periodic_advertising_create_sync()</a>.  <a href="group___g_a_p___commands.html#ga1c155356e81009bde728be19f603f9a7">More...</a><br /></td></tr>
<tr class="separator:ga1c155356e81009bde728be19f603f9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6fb460936dbecb8947d838269fb7583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaa6fb460936dbecb8947d838269fb7583">aci_gap_periodic_advertising_create_sync_cancel</a> (void)</td></tr>
<tr class="memdesc:gaa6fb460936dbecb8947d838269fb7583"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Periodic_Advertising_Create_Sync_Cancel command is used to cancel the GAP_Periodic_Advertising_Create_Sync command while it is pending. See <a class="el" href="group___h_c_i___commands.html#ga5e778a6322e631ae852b3dc6a84ed6f5" title="The LE_Periodic_Advertising_Create_Sync_Cancel command is used to cancel the LE_Periodic_Advertising_...">hci_le_periodic_advertising_create_sync_cancel()</a>.  <a href="group___g_a_p___commands.html#gaa6fb460936dbecb8947d838269fb7583">More...</a><br /></td></tr>
<tr class="separator:gaa6fb460936dbecb8947d838269fb7583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ca64d5f0f21052ede333b69e2b1dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga98ca64d5f0f21052ede333b69e2b1dd9">aci_gap_remove_advertising_set</a> (uint8_t Advertising_Handle)</td></tr>
<tr class="memdesc:ga98ca64d5f0f21052ede333b69e2b1dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Remove_Advertising_Set command is used to remove an advertising set from the Controller. If the advertising set corresponding to the Advertising_Handle parameter does not exist, then the Controller shall return the error code Unknown Advertising Identifier (0x42). If advertising on the advertising set is enabled, then the Controller shall return the error code Command Disallowed (0x0C).  <a href="group___g_a_p___commands.html#ga98ca64d5f0f21052ede333b69e2b1dd9">More...</a><br /></td></tr>
<tr class="separator:ga98ca64d5f0f21052ede333b69e2b1dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f2cd393ff0cade3466e46fba7126d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga91f2cd393ff0cade3466e46fba7126d4">aci_gap_clear_advertising_sets</a> (void)</td></tr>
<tr class="memdesc:ga91f2cd393ff0cade3466e46fba7126d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Clear_Advertising_Sets command is used to remove all existing advertising sets from the Controller. If advertising is enabled on any advertising set, then the Controller shall return the error code Command Disallowed (0x0C). Note: All advertising sets are cleared on HCI reset.  <a href="group___g_a_p___commands.html#ga91f2cd393ff0cade3466e46fba7126d4">More...</a><br /></td></tr>
<tr class="separator:ga91f2cd393ff0cade3466e46fba7126d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa429708d1e661d02db76c487c6bfe130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaa429708d1e661d02db76c487c6bfe130">aci_gap_periodic_advertising_terminate_sync</a> (uint16_t Sync_Handle)</td></tr>
<tr class="memdesc:gaa429708d1e661d02db76c487c6bfe130"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Periodic_Advertising_Terminate_Sync command is used to stop reception of the periodic advertising identified by the Sync_Handle parameter. See <a class="el" href="group___h_c_i___commands.html#ga37d4ea8e2cb79893a5de7d3e5adb16de" title="The LE_Periodic_Advertising_Terminate_Sync command is used to stop reception of the periodic advertis...">hci_le_periodic_advertising_terminate_sync()</a>.  <a href="group___g_a_p___commands.html#gaa429708d1e661d02db76c487c6bfe130">More...</a><br /></td></tr>
<tr class="separator:gaa429708d1e661d02db76c487c6bfe130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084fe6c8209aadeb161cdd366f5e5446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga084fe6c8209aadeb161cdd366f5e5446">aci_gap_add_device_to_periodic_advertiser_list</a> (uint8_t Advertiser_Address_Type, uint8_t Advertiser_Address[6], uint8_t Advertising_SID)</td></tr>
<tr class="memdesc:ga084fe6c8209aadeb161cdd366f5e5446"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Add_Device_To_Periodic_Advertiser_List command is used to add a single device to the Periodic Advertiser list stored in the Controller. See <a class="el" href="group___h_c_i___commands.html#ga8857fcc5679db318175654736d43f51b" title="The LE_Add_Device_To_Periodic_Advertiser_List command is used to add a single device to the Periodic ...">hci_le_add_device_to_periodic_advertiser_list()</a>.  <a href="group___g_a_p___commands.html#ga084fe6c8209aadeb161cdd366f5e5446">More...</a><br /></td></tr>
<tr class="separator:ga084fe6c8209aadeb161cdd366f5e5446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b00cb7bc7ead4217811c25ba82bb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga06b00cb7bc7ead4217811c25ba82bb0c">aci_gap_remove_device_from_periodic_advertising_list</a> (uint8_t Advertiser_Address_Type, uint8_t Advertiser_Address[6], uint8_t Advertising_SID)</td></tr>
<tr class="memdesc:ga06b00cb7bc7ead4217811c25ba82bb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Remove_Device_From_Periodic_Advertiser_List command is used to remove one device from the list of Periodic Advertisers stored in the Controller. See <a class="el" href="group___h_c_i___commands.html#ga1c3a3884ad16ec127ffa8eff13c0aecd" title="The LE_Remove_Device_From_Periodic_Advertiser_List command is used to remove one device from the list...">hci_le_remove_device_from_periodic_advertising_list()</a>.  <a href="group___g_a_p___commands.html#ga06b00cb7bc7ead4217811c25ba82bb0c">More...</a><br /></td></tr>
<tr class="separator:ga06b00cb7bc7ead4217811c25ba82bb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5bdb3c5003b56a551b8c78f16b4bf77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaf5bdb3c5003b56a551b8c78f16b4bf77">aci_gap_clear_periodic_advertiser_list</a> (void)</td></tr>
<tr class="memdesc:gaf5bdb3c5003b56a551b8c78f16b4bf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Clear_Periodic_Advertiser_List command is used to remove all devices from the list of Periodic Advertisers in the Controller. See <a class="el" href="group___h_c_i___commands.html#ga5171a2b5a45db3c98186c5d762d05eff" title="The LE_Clear_Periodic_Advertiser_List command is used to remove all devices from the list of Periodic...">hci_le_clear_periodic_advertiser_list()</a>.  <a href="group___g_a_p___commands.html#gaf5bdb3c5003b56a551b8c78f16b4bf77">More...</a><br /></td></tr>
<tr class="separator:gaf5bdb3c5003b56a551b8c78f16b4bf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf64880dcfa24e5b8a796f3c97018f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gadf64880dcfa24e5b8a796f3c97018f01">aci_gap_read_periodic_advertiser_list_size</a> (uint8_t *Periodic_Advertiser_List_Size)</td></tr>
<tr class="memdesc:gadf64880dcfa24e5b8a796f3c97018f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Read_Periodic_Advertiser_List_Size command is used to read the total number of Periodic Advertiser list entries that can be stored in the Controller. Note: The number of entries that can be stored is not fixed and the Controller can change it at any time (e.g., because the memory used to store the list can also be used for other purposes).  <a href="group___g_a_p___commands.html#gadf64880dcfa24e5b8a796f3c97018f01">More...</a><br /></td></tr>
<tr class="separator:gadf64880dcfa24e5b8a796f3c97018f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a8f2edad6c23ed461543e8ea869370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gae7a8f2edad6c23ed461543e8ea869370">aci_gap_set_periodic_advertising_receive_enable</a> (uint16_t Sync_Handle, uint8_t Enable)</td></tr>
<tr class="memdesc:gae7a8f2edad6c23ed461543e8ea869370"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_Set_Periodic_Advertising_Receive_Enable command will enable or disable reports for the periodic advertising train identified by the Sync_Handle parameter. See <a class="el" href="group___h_c_i___commands.html#ga7235a664f73c046fcb521eb5f3af4551" title="The HCI_LE_Set_Periodic_Advertising_Receive_Enable command will enable or disable reports for the per...">hci_le_set_periodic_advertising_receive_enable()</a>.  <a href="group___g_a_p___commands.html#gae7a8f2edad6c23ed461543e8ea869370">More...</a><br /></td></tr>
<tr class="separator:gae7a8f2edad6c23ed461543e8ea869370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2ef71cfdbd3b6d52e1112ddd247637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#ga2c2ef71cfdbd3b6d52e1112ddd247637">aci_gap_periodic_advertising_sync_transfer</a> (uint16_t Connection_Handle, uint16_t Service_Data, uint16_t Sync_Handle)</td></tr>
<tr class="memdesc:ga2c2ef71cfdbd3b6d52e1112ddd247637"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_Periodic_Advertising_Sync_Transfer command is used to instruct the Controller to send synchronization information about the periodic advertising train identified by the Sync_Handle parameter to a connected device. See <a class="el" href="group___h_c_i___commands.html#ga5fc9b30141f28403413452602ba1420c" title="The HCI_LE_Periodic_Advertising_Sync_Transfer command is used to instruct the Controller to send sync...">hci_le_periodic_advertising_sync_transfer()</a>.  <a href="group___g_a_p___commands.html#ga2c2ef71cfdbd3b6d52e1112ddd247637">More...</a><br /></td></tr>
<tr class="separator:ga2c2ef71cfdbd3b6d52e1112ddd247637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57ae6aa12d6b44e6daa9239707e5454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gad57ae6aa12d6b44e6daa9239707e5454">aci_gap_periodic_advertising_set_info_transfer</a> (uint16_t Connection_Handle, uint16_t Service_Data, uint8_t Advertising_Handle)</td></tr>
<tr class="memdesc:gad57ae6aa12d6b44e6daa9239707e5454"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_Periodic_Advertising_Set_Info_Transfer command is used to instruct the Controller to send synchronization information about the periodic advertising in an advertising set to a connected device. See <a class="el" href="group___h_c_i___commands.html#ga4e82daec659f72d668fe98125af053bc" title="The HCI_LE_Periodic_Advertising_Set_Info_Transfer command is used to instruct the Controller to send ...">hci_le_periodic_advertising_set_info_transfer()</a>  <a href="group___g_a_p___commands.html#gad57ae6aa12d6b44e6daa9239707e5454">More...</a><br /></td></tr>
<tr class="separator:gad57ae6aa12d6b44e6daa9239707e5454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e298a8805ef3ba612f7cde357d4ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gad6e298a8805ef3ba612f7cde357d4ee9">aci_gap_set_periodic_advertising_sync_transfer_parameters</a> (uint16_t Connection_Handle, uint8_t Mode, uint16_t Skip, uint16_t Sync_Timeout, uint8_t CTE_Type)</td></tr>
<tr class="memdesc:gad6e298a8805ef3ba612f7cde357d4ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_Set_Periodic_Advertising_Sync_Transfer_Parameters command is used to specify how the Controller will process periodic advertising synchronization information received from the device identified by the Connection_Handle parameter (the "transfer mode"). See <a class="el" href="group___h_c_i___commands.html#ga9d310cadfff0e3889f1a0d5cc812f629" title="The HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command is used to specify how the Contr...">hci_le_set_periodic_advertising_sync_transfer_parameters()</a>.  <a href="group___g_a_p___commands.html#gad6e298a8805ef3ba612f7cde357d4ee9">More...</a><br /></td></tr>
<tr class="separator:gad6e298a8805ef3ba612f7cde357d4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc5099b21c7b0bacb1d054d6d431ad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaabc5099b21c7b0bacb1d054d6d431ad6">aci_gap_set_default_periodic_advertising_sync_transfer_parameters</a> (uint8_t Mode, uint16_t Skip, uint16_t Sync_Timeout, uint8_t CTE_Type)</td></tr>
<tr class="memdesc:gaabc5099b21c7b0bacb1d054d6d431ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters command is used to specify the initial value for the mode, skip, timeout, and Constant Tone Extension type to be used for all subsequent connections over the LE transport. See <a class="el" href="group___h_c_i___commands.html#gafa551c7946dc61787efada88b98ed525" title="The HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters command is used to specify the i...">hci_le_set_default_periodic_advertising_sync_transfer_parameters()</a>.  <a href="group___g_a_p___commands.html#gaabc5099b21c7b0bacb1d054d6d431ad6">More...</a><br /></td></tr>
<tr class="separator:gaabc5099b21c7b0bacb1d054d6d431ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab050f09d9b53a0c169f4e4ae9245fbcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gab050f09d9b53a0c169f4e4ae9245fbcf">aci_gap_set_periodic_advertising_data</a> (uint8_t Advertising_Handle, uint16_t Advertising_Data_Length, uint8_t Advertising_Data[])</td></tr>
<tr class="memdesc:gab050f09d9b53a0c169f4e4ae9245fbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GAP_Set_Periodic_Advertising_Data command is used to set the data used in periodic advertising PDUs. See hci_le_set_periodic_advertising_data().  <a href="group___g_a_p___commands.html#gab050f09d9b53a0c169f4e4ae9245fbcf">More...</a><br /></td></tr>
<tr class="separator:gab050f09d9b53a0c169f4e4ae9245fbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab263f969700663e2c2d3dafc8754759a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gab263f969700663e2c2d3dafc8754759a">aci_gap_set_advertising_data</a> (uint8_t Advertising_Handle, uint8_t Operation, uint16_t Advertising_Data_Length, uint8_t Advertising_Data[])</td></tr>
<tr class="memdesc:gab263f969700663e2c2d3dafc8754759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_SET_ADVERTISING_DATA function is used to set the data in advertising PDUs. If the device is in Limited Discoverable Mode, Flags data type in advertising data must have the flags set as described: - The LE Limited Discoverable Mode flag set to one. - The 'BR/EDR Not Supported' flag set to one. - All other flags set to zero. If the device is in General Discoverable Mode, Flags data type in advertising data must have the flags set as described: - The LE General Discoverable Mode flag set to one. - The 'BR/EDR Not Supported' flag set to one. - All other flags set to zero. If the device is in one of the other modes, Flags data type in advertising data must have the flags set as described: - The 'BR/EDR Not Supported' flag set to one. - All other flags set to zero. If a device is sending non connectable events, Flags data type may be omitted, otherwise it must be present.  <a href="group___g_a_p___commands.html#gab263f969700663e2c2d3dafc8754759a">More...</a><br /></td></tr>
<tr class="separator:gab263f969700663e2c2d3dafc8754759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38bef44bef793908ee18959478a4c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___commands.html#gaf38bef44bef793908ee18959478a4c61">aci_gap_set_scan_response_data</a> (uint8_t Advertising_Handle, uint16_t Scan_Response_Data_Length, uint8_t Scan_Response_Data[])</td></tr>
<tr class="memdesc:gaf38bef44bef793908ee18959478a4c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACI_GAP_SET_SCAN_RESPONSE_DATA function configures the scan response data as requested by the application.  <a href="group___g_a_p___commands.html#gaf38bef44bef793908ee18959478a4c61">More...</a><br /></td></tr>
<tr class="separator:gaf38bef44bef793908ee18959478a4c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae244abb4c197f3f157ec34c15bea37da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gae244abb4c197f3f157ec34c15bea37da">aci_gatt_srv_init</a> (void)</td></tr>
<tr class="memdesc:gae244abb4c197f3f157ec34c15bea37da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the GATT service to the database.  <a href="group___g_a_t_t___commands.html#gae244abb4c197f3f157ec34c15bea37da">More...</a><br /></td></tr>
<tr class="separator:gae244abb4c197f3f157ec34c15bea37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49669bba524f15e49a6c08234a7ee0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga49669bba524f15e49a6c08234a7ee0ca">aci_gatt_set_event_mask</a> (uint32_t GATT_Evt_Mask)</td></tr>
<tr class="memdesc:ga49669bba524f15e49a6c08234a7ee0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masks events from the GATT. The default configuration is all the events unmasked (enabled).  <a href="group___g_a_t_t___commands.html#ga49669bba524f15e49a6c08234a7ee0ca">More...</a><br /></td></tr>
<tr class="separator:ga49669bba524f15e49a6c08234a7ee0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3089d94aa7df2578d0f5e6f4a136be3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga3089d94aa7df2578d0f5e6f4a136be3e">aci_gatt_clt_exchange_config</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga3089d94aa7df2578d0f5e6f4a136be3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an ATT MTU exchange procedure. When the ATT MTU exchange procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga5fff3f7c776e7b6e51a4c85a08e48a8a">aci_att_exchange_mtu_resp_event</a> event is generated. A <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is also generated to indicate the end of the procedure.  <a href="group___g_a_t_t___commands.html#ga3089d94aa7df2578d0f5e6f4a136be3e">More...</a><br /></td></tr>
<tr class="separator:ga3089d94aa7df2578d0f5e6f4a136be3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3186c448e51a65c6a9d6ffc952cf6520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga3186c448e51a65c6a9d6ffc952cf6520">aci_gatt_clt_prepare_write_req</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset, uint16_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga3186c448e51a65c6a9d6ffc952cf6520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a Prepare Write Request. The Prepare Write Request is used to request the server to prepare to write the value of an attribute. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga176b6a28ae1df4ee4c02cb1967631e7d">aci_att_clt_prepare_write_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a>.  <a href="group___g_a_t_t___commands.html#ga3186c448e51a65c6a9d6ffc952cf6520">More...</a><br /></td></tr>
<tr class="separator:ga3186c448e51a65c6a9d6ffc952cf6520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e57d532d0e6e85d4ce957656e77b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga87e57d532d0e6e85d4ce957656e77b2b">aci_gatt_clt_execute_write_req</a> (uint16_t Connection_Handle, uint8_t Execute)</td></tr>
<tr class="memdesc:ga87e57d532d0e6e85d4ce957656e77b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an Execute Write Request. The Execute Write Request is used to request the server to write or cancel the write of all the prepared values currently held in the prepare queue from this client. The result of the procedure is given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac4842d0a68f0e0a0b39644b6480178ad">aci_att_clt_exec_write_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event.  <a href="group___g_a_t_t___commands.html#ga87e57d532d0e6e85d4ce957656e77b2b">More...</a><br /></td></tr>
<tr class="separator:ga87e57d532d0e6e85d4ce957656e77b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffc0888eae26d9903a951948bd3e356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga4ffc0888eae26d9903a951948bd3e356">aci_gatt_clt_disc_all_primary_services</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga4ffc0888eae26d9903a951948bd3e356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the GATT client procedure to discover all primary services on the server. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga8d1992b789d5b80a6f7886824be711fa">aci_att_clt_read_by_group_type_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#ga4ffc0888eae26d9903a951948bd3e356">More...</a><br /></td></tr>
<tr class="separator:ga4ffc0888eae26d9903a951948bd3e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee3b3b581fdbe2a8d42882cbdc4d71e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga1ee3b3b581fdbe2a8d42882cbdc4d71e">aci_gatt_clt_disc_primary_service_by_uuid</a> (uint16_t Connection_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg__lp__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:ga1ee3b3b581fdbe2a8d42882cbdc4d71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to discover the primary services of the specified UUID on the server. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac5d1614a3401a8edc568250f3ff6565f">aci_att_clt_find_by_type_value_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event.  <a href="group___g_a_t_t___commands.html#ga1ee3b3b581fdbe2a8d42882cbdc4d71e">More...</a><br /></td></tr>
<tr class="separator:ga1ee3b3b581fdbe2a8d42882cbdc4d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0778922d442a455145eb13e3ead915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaef0778922d442a455145eb13e3ead915">aci_gatt_clt_find_included_services</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:gaef0778922d442a455145eb13e3ead915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to find all included services. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga24f264438529afea1a9225c99efa3b1b">aci_att_clt_read_by_type_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event.  <a href="group___g_a_t_t___commands.html#gaef0778922d442a455145eb13e3ead915">More...</a><br /></td></tr>
<tr class="separator:gaef0778922d442a455145eb13e3ead915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407ce9dbeab2e3e430ca4f4c9a40270b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga407ce9dbeab2e3e430ca4f4c9a40270b">aci_gatt_clt_disc_all_char_of_service</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:ga407ce9dbeab2e3e430ca4f4c9a40270b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to discover all the characteristics of a given service. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga24f264438529afea1a9225c99efa3b1b">aci_att_clt_read_by_type_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#ga407ce9dbeab2e3e430ca4f4c9a40270b">More...</a><br /></td></tr>
<tr class="separator:ga407ce9dbeab2e3e430ca4f4c9a40270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d2f3024b012c825b6dfa29470403d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga60d2f3024b012c825b6dfa29470403d2">aci_gatt_clt_disc_char_by_uuid</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg__lp__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:ga60d2f3024b012c825b6dfa29470403d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to discover all the characteristics specified by a UUID. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1ff2973006ce64d8f39be581e63ab46c">aci_gatt_clt_disc_read_char_by_uuid_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#ga60d2f3024b012c825b6dfa29470403d2">More...</a><br /></td></tr>
<tr class="separator:ga60d2f3024b012c825b6dfa29470403d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532b91236639d7dd20cf7c076a1ec78d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga532b91236639d7dd20cf7c076a1ec78d">aci_gatt_clt_disc_all_char_desc</a> (uint16_t Connection_Handle, uint16_t Char_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:ga532b91236639d7dd20cf7c076a1ec78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to discover all characteristic descriptors on the server. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gadc5d56dc87aa93183124d75d5d4a3c20">aci_att_clt_find_info_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#ga532b91236639d7dd20cf7c076a1ec78d">More...</a><br /></td></tr>
<tr class="separator:ga532b91236639d7dd20cf7c076a1ec78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbfac57913e68df14fa7b717513fead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gacfbfac57913e68df14fa7b717513fead">aci_gatt_clt_read</a> (uint16_t Connection_Handle, uint16_t Attr_Handle)</td></tr>
<tr class="memdesc:gacfbfac57913e68df14fa7b717513fead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to read an attribute value. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packet is given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga6ecb59e8280e8f66bb60af6700dff2bb">aci_att_clt_read_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#gacfbfac57913e68df14fa7b717513fead">More...</a><br /></td></tr>
<tr class="separator:gacfbfac57913e68df14fa7b717513fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d6b5f26ddf7ca86cfa3de36b124eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gad5d6b5f26ddf7ca86cfa3de36b124eb1">aci_gatt_clt_read_using_char_uuid</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg__lp__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:gad5d6b5f26ddf7ca86cfa3de36b124eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to read all the characteristics specified by the UUID. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1ff2973006ce64d8f39be581e63ab46c">aci_gatt_clt_disc_read_char_by_uuid_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#gad5d6b5f26ddf7ca86cfa3de36b124eb1">More...</a><br /></td></tr>
<tr class="separator:gad5d6b5f26ddf7ca86cfa3de36b124eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2408fa0ea8eda1b7cd30cf062aa7af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gad2408fa0ea8eda1b7cd30cf062aa7af9">aci_gatt_clt_read_long</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset)</td></tr>
<tr class="memdesc:gad2408fa0ea8eda1b7cd30cf062aa7af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to read a long attribute value. the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gae2d734cccb86cd3c9727e3a90688d209">aci_att_clt_read_blob_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#gad2408fa0ea8eda1b7cd30cf062aa7af9">More...</a><br /></td></tr>
<tr class="separator:gad2408fa0ea8eda1b7cd30cf062aa7af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8606d6c3071c496a7d9dffa81d189eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga8606d6c3071c496a7d9dffa81d189eb3">aci_gatt_clt_read_multiple_char_value</a> (uint16_t Connection_Handle, uint8_t Number_of_Handles, <a class="el" href="bluenrg__lp__api_8h.html#a46e49c7305b7ff1d34fec3f2e4bcf42b">Handle_Entry_t</a> Handle_Entry[])</td></tr>
<tr class="memdesc:ga8606d6c3071c496a7d9dffa81d189eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a procedure to read multiple characteristic values from a server. This sub-procedure is used to read multiple Characteristic Values from a server when the client knows the Characteristic Value Handles. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa2e70f2c6fef95652d8a7429826361be">aci_att_clt_read_multiple_resp_event</a> event.  <a href="group___g_a_t_t___commands.html#ga8606d6c3071c496a7d9dffa81d189eb3">More...</a><br /></td></tr>
<tr class="separator:ga8606d6c3071c496a7d9dffa81d189eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de8070c2b6a198d3a5632e426112658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga1de8070c2b6a198d3a5632e426112658">aci_gatt_clt_write_without_resp</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga1de8070c2b6a198d3a5632e426112658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to write a characteristic value without waiting for any response from the server. No events are generated after this command is executed. Writing attributes using this function is not considered reliable by the standard: packets may be discarded by the peer if too many write commands are received.  <a href="group___g_a_t_t___commands.html#ga1de8070c2b6a198d3a5632e426112658">More...</a><br /></td></tr>
<tr class="separator:ga1de8070c2b6a198d3a5632e426112658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a0f3657070562a3a807b6b95815f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga48a0f3657070562a3a807b6b95815f96">aci_gatt_clt_signed_write_without_resp</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga48a0f3657070562a3a807b6b95815f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a signed write without response from the server. The procedure is used to write a characteristic value with an authentication signature without waiting for any response from the server. It cannot be used when the link is encrypted.  <a href="group___g_a_t_t___commands.html#ga48a0f3657070562a3a807b6b95815f96">More...</a><br /></td></tr>
<tr class="separator:ga48a0f3657070562a3a807b6b95815f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96a0fd2820ad820031f0f5aa7533cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaa96a0fd2820ad820031f0f5aa7533cdc">aci_gatt_clt_confirm_indication</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gaa96a0fd2820ad820031f0f5aa7533cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow application to confirm indication. This command has to be sent when the application receives the event <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaf03c176eaba41fdd852c3acad3acbcd1">aci_gatt_clt_indication_event</a>.  <a href="group___g_a_t_t___commands.html#gaa96a0fd2820ad820031f0f5aa7533cdc">More...</a><br /></td></tr>
<tr class="separator:gaa96a0fd2820ad820031f0f5aa7533cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433e7f799689018ff6e5c5a5c307ef72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga433e7f799689018ff6e5c5a5c307ef72">aci_gatt_srv_notify</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Flags, uint16_t Val_Length, uint8_t Val[])</td></tr>
<tr class="memdesc:ga433e7f799689018ff6e5c5a5c307ef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an indication or notification for the provided attribute handle. The Flags parameter indicate what kind of message will be sent: -) 0x00 Send a notification -) 0x02 Send an indication.  <a href="group___g_a_t_t___commands.html#ga433e7f799689018ff6e5c5a5c307ef72">More...</a><br /></td></tr>
<tr class="separator:ga433e7f799689018ff6e5c5a5c307ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c850d81a3f2292ebb0842ae64f90e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaa0c850d81a3f2292ebb0842ae64f90e2">aci_gatt_srv_write_multiple_instance_handle_value</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Value_Length, uint8_t Value[])</td></tr>
<tr class="memdesc:gaa0c850d81a3f2292ebb0842ae64f90e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an attribute value for that kind of attributes that have different values for each connection, i.e. the Client Characteristic Configuration Descriptors. WARNING: use of this function can affect interoperability. Do not use the function unless you are aware of what you are doing.  <a href="group___g_a_t_t___commands.html#gaa0c850d81a3f2292ebb0842ae64f90e2">More...</a><br /></td></tr>
<tr class="separator:gaa0c850d81a3f2292ebb0842ae64f90e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7f3f5591df2dc7b59d09ac774e027b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaa7f3f5591df2dc7b59d09ac774e027b5">aci_gatt_srv_add_service</a> (<a class="el" href="group___g_a_t_t.html#gad759c97f4e1b6ebe954a8d38f00a3d57">ble_gatt_srv_def_t</a> *Service_p)</td></tr>
<tr class="memdesc:gaa7f3f5591df2dc7b59d09ac774e027b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a service to the GATT database. When a service is created, the host may reserve a range of handles for this service.  <a href="group___g_a_t_t___commands.html#gaa7f3f5591df2dc7b59d09ac774e027b5">More...</a><br /></td></tr>
<tr class="separator:gaa7f3f5591df2dc7b59d09ac774e027b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fc4e5b5e969811eef77997071bc43a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga86fc4e5b5e969811eef77997071bc43a">aci_gatt_srv_include_service</a> (uint16_t Service_Handle, uint16_t Included_Service_Handle)</td></tr>
<tr class="memdesc:ga86fc4e5b5e969811eef77997071bc43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Includes a service given by Included_Service_Handle to another service given by Service_Handle. Attribute server creates an Include definition attribute and returns the handle of this attribute.  <a href="group___g_a_t_t___commands.html#ga86fc4e5b5e969811eef77997071bc43a">More...</a><br /></td></tr>
<tr class="separator:ga86fc4e5b5e969811eef77997071bc43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0e16bf91628528ea6c28373ce9dec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaff0e16bf91628528ea6c28373ce9dec5">aci_gatt_srv_add_char</a> (<a class="el" href="group___g_a_t_t.html#gaffa9ff5f08aa2ae05cc208d5a0529086">ble_gatt_chr_def_t</a> *Char_p, uint16_t Service_Handle)</td></tr>
<tr class="memdesc:gaff0e16bf91628528ea6c28373ce9dec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a characteristic to a service.  <a href="group___g_a_t_t___commands.html#gaff0e16bf91628528ea6c28373ce9dec5">More...</a><br /></td></tr>
<tr class="separator:gaff0e16bf91628528ea6c28373ce9dec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1dd0e039f84a46174f200340254032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gada1dd0e039f84a46174f200340254032">aci_gatt_srv_add_char_desc</a> (<a class="el" href="group___g_a_t_t.html#ga9979527e6b624178ac0fa13c37441ef6">ble_gatt_descr_def_t</a> *Descr_p, uint16_t Char_Handle)</td></tr>
<tr class="memdesc:gada1dd0e039f84a46174f200340254032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a characteristic descriptor to a characteristic.  <a href="group___g_a_t_t___commands.html#gada1dd0e039f84a46174f200340254032">More...</a><br /></td></tr>
<tr class="separator:gada1dd0e039f84a46174f200340254032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42d0ee4835042e81e0f4f42ccb8ef8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaf42d0ee4835042e81e0f4f42ccb8ef8d">aci_gatt_srv_rm_service</a> (uint16_t Serv_Handle)</td></tr>
<tr class="memdesc:gaf42d0ee4835042e81e0f4f42ccb8ef8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified service from the GATT server database.  <a href="group___g_a_t_t___commands.html#gaf42d0ee4835042e81e0f4f42ccb8ef8d">More...</a><br /></td></tr>
<tr class="separator:gaf42d0ee4835042e81e0f4f42ccb8ef8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a7b56e7f7facafb57789e2365dc058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaf9a7b56e7f7facafb57789e2365dc058">aci_gatt_srv_rm_include_service</a> (uint16_t Include_Handle)</td></tr>
<tr class="memdesc:gaf9a7b56e7f7facafb57789e2365dc058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the include definition from the service.  <a href="group___g_a_t_t___commands.html#gaf9a7b56e7f7facafb57789e2365dc058">More...</a><br /></td></tr>
<tr class="separator:gaf9a7b56e7f7facafb57789e2365dc058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf6e75f5c43a9c1e4ecfd8ad5468e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga0cf6e75f5c43a9c1e4ecfd8ad5468e76">aci_gatt_srv_rm_char</a> (uint16_t Char_Handle)</td></tr>
<tr class="memdesc:ga0cf6e75f5c43a9c1e4ecfd8ad5468e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified characteristic from the service.  <a href="group___g_a_t_t___commands.html#ga0cf6e75f5c43a9c1e4ecfd8ad5468e76">More...</a><br /></td></tr>
<tr class="separator:ga0cf6e75f5c43a9c1e4ecfd8ad5468e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7a9c50af1de9c1d9ffae1a170ce8da"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga5b7a9c50af1de9c1d9ffae1a170ce8da">aci_gatt_srv_get_service_handle</a> (<a class="el" href="group___g_a_t_t.html#gad759c97f4e1b6ebe954a8d38f00a3d57">ble_gatt_srv_def_t</a> *Serv_p)</td></tr>
<tr class="memdesc:ga5b7a9c50af1de9c1d9ffae1a170ce8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieve the Attribute Handle assigned to the Service registered using the provided definition structure.  <a href="group___g_a_t_t___commands.html#ga5b7a9c50af1de9c1d9ffae1a170ce8da">More...</a><br /></td></tr>
<tr class="separator:ga5b7a9c50af1de9c1d9ffae1a170ce8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46358b5c48d69e473515ed8afbf4eb83"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga46358b5c48d69e473515ed8afbf4eb83">aci_gatt_srv_get_include_service_handle</a> (uint16_t Serv_Attr_Handle, <a class="el" href="group___g_a_t_t.html#gad759c97f4e1b6ebe954a8d38f00a3d57">ble_gatt_srv_def_t</a> *Included_Srv_p)</td></tr>
<tr class="memdesc:ga46358b5c48d69e473515ed8afbf4eb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieve the Attribute Handle assigned to the Include Service.  <a href="group___g_a_t_t___commands.html#ga46358b5c48d69e473515ed8afbf4eb83">More...</a><br /></td></tr>
<tr class="separator:ga46358b5c48d69e473515ed8afbf4eb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf59d0d7bcd09e8d12d95eda1d9ebefc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gacf59d0d7bcd09e8d12d95eda1d9ebefc">aci_gatt_srv_get_char_decl_handle</a> (<a class="el" href="group___g_a_t_t.html#gaffa9ff5f08aa2ae05cc208d5a0529086">ble_gatt_chr_def_t</a> *Char_p)</td></tr>
<tr class="memdesc:gacf59d0d7bcd09e8d12d95eda1d9ebefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieve the Attribute Handle assigned to the Characteristic registered using the provided definition structure.  <a href="group___g_a_t_t___commands.html#gacf59d0d7bcd09e8d12d95eda1d9ebefc">More...</a><br /></td></tr>
<tr class="separator:gacf59d0d7bcd09e8d12d95eda1d9ebefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed5021193f819c5aebaba98f5650e29"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga5ed5021193f819c5aebaba98f5650e29">aci_gatt_srv_get_descriptor_handle</a> (<a class="el" href="group___g_a_t_t.html#ga9979527e6b624178ac0fa13c37441ef6">ble_gatt_descr_def_t</a> *Descr_p)</td></tr>
<tr class="memdesc:ga5ed5021193f819c5aebaba98f5650e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieve the Attribute Handle assigned to the Characteristic Descriptor registered using the provided definition structure.  <a href="group___g_a_t_t___commands.html#ga5ed5021193f819c5aebaba98f5650e29">More...</a><br /></td></tr>
<tr class="separator:ga5ed5021193f819c5aebaba98f5650e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8df1c043fc1d662909470d6cf5f4e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gaab8df1c043fc1d662909470d6cf5f4e0">aci_gatt_srv_read_handle_value</a> (uint16_t Attr_Handle, uint16_t *Length, uint8_t **Value)</td></tr>
<tr class="memdesc:gaab8df1c043fc1d662909470d6cf5f4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the value of the attribute handle specified from the local GATT database.  <a href="group___g_a_t_t___commands.html#gaab8df1c043fc1d662909470d6cf5f4e0">More...</a><br /></td></tr>
<tr class="separator:gaab8df1c043fc1d662909470d6cf5f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga486a547dde23d36d6f316da221ebd8cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga486a547dde23d36d6f316da221ebd8cc">aci_gatt_srv_resp</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Error_Code, uint16_t Val_Length, uint8_t Val[])</td></tr>
<tr class="memdesc:ga486a547dde23d36d6f316da221ebd8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to be given in response to aci_gatt_srv_read_event, aci_gatt_srv_write_event, aci_att_srv_prepare_write_req_event or aci_att_srv_exec_write_req_event. It ends the ATT transaction initiated by the remote client.  <a href="group___g_a_t_t___commands.html#ga486a547dde23d36d6f316da221ebd8cc">More...</a><br /></td></tr>
<tr class="separator:ga486a547dde23d36d6f316da221ebd8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7122669f4be81332418cb029dd9e50a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga7122669f4be81332418cb029dd9e50a4">aci_gatt_clt_write</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga7122669f4be81332418cb029dd9e50a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to write an attribute (characteristic value or descriptor). When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. Note: the buffer containing the value to be written must be kept valid until the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> is received.  <a href="group___g_a_t_t___commands.html#ga7122669f4be81332418cb029dd9e50a4">More...</a><br /></td></tr>
<tr class="separator:ga7122669f4be81332418cb029dd9e50a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade442f01d53b88046d5eb888929422a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#gade442f01d53b88046d5eb888929422a1">aci_gatt_clt_write_long</a> (uint16_t Connection_Handle, <a class="el" href="structble__gatt__clt__write__ops__t.html">ble_gatt_clt_write_ops_t</a> *Write_Ops_p)</td></tr>
<tr class="memdesc:gade442f01d53b88046d5eb888929422a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This procedure is used to write an Attribute Value to a Server when the Client knows the Attribute Handle but the length of the Value is longer than what can be sent in a single Write Request Attribute Protocol message. During the procedure, aci_att_clt_prepare_write_resp_event and aci_att_clt_exec_write_resp_event are raised. Note: The memory pointed by Write_Ops_p parameter and the buffer containing the value to be written must be kept valid while the procedure is running. They can be released (or their content can be changed) when the aci_gatt_clt_proc_complete_event is emitted indicating that the procedure is completed, or an error was received.  <a href="group___g_a_t_t___commands.html#gade442f01d53b88046d5eb888929422a1">More...</a><br /></td></tr>
<tr class="separator:gade442f01d53b88046d5eb888929422a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65682fdf657dcf230f29a7c3ecea1a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga65682fdf657dcf230f29a7c3ecea1a16">aci_gatt_clt_write_char_reliable</a> (uint16_t Connection_Handle, uint8_t Num_Attrs, <a class="el" href="structble__gatt__clt__write__ops__t.html">ble_gatt_clt_write_ops_t</a> *Write_Ops_p)</td></tr>
<tr class="memdesc:ga65682fdf657dcf230f29a7c3ecea1a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the procedure to write a characteristic reliably (a check is made on the written values). When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga693f6d7f01c932eedf33caa475cc997a">aci_gatt_clt_proc_complete_event</a> event is generated. During the procedure, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga176b6a28ae1df4ee4c02cb1967631e7d">aci_att_clt_prepare_write_resp_event</a> and <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac4842d0a68f0e0a0b39644b6480178ad">aci_att_clt_exec_write_resp_event</a> events are raised. Note: The memory pointed by Write_Ops_p parameter and the buffer containing the value to be written must be kept valid while the procedure is running. They can be released (or their content can be changed) when the aci_gatt_clt_proc_complete_event is emitted indicating that the procedure is completed, or an error was received.  <a href="group___g_a_t_t___commands.html#ga65682fdf657dcf230f29a7c3ecea1a16">More...</a><br /></td></tr>
<tr class="separator:ga65682fdf657dcf230f29a7c3ecea1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e3874702d311cce63f2ea7c6c8c9d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___commands.html#ga2e3874702d311cce63f2ea7c6c8c9d67">aci_gatt_srv_read_multiple_instance_handle_value</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t *Value_Length, uint8_t **Value)</td></tr>
<tr class="memdesc:ga2e3874702d311cce63f2ea7c6c8c9d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value for that kind of attributes that have different values for each connection, i.e. the Client Characteristic Configuration Descriptors.  <a href="group___g_a_t_t___commands.html#ga2e3874702d311cce63f2ea7c6c8c9d67">More...</a><br /></td></tr>
<tr class="separator:ga2e3874702d311cce63f2ea7c6c8c9d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf732199ecbd953e06943ca0aae99805f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#gaf732199ecbd953e06943ca0aae99805f">aci_l2cap_connection_parameter_update_req</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Slave_latency, uint16_t Timeout_Multiplier)</td></tr>
<tr class="memdesc:gaf732199ecbd953e06943ca0aae99805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an L2CAP connection parameter update request from the slave to the master. An <a class="el" href="group___l2_c_a_p__events.html#ga80df69ea3d38af2a53d2cfcbb1e7d4fb">aci_l2cap_connection_update_resp_event</a> event will be raised when the master will respond to the request (accepts or rejects).  <a href="group___l2_c_a_p___commands.html#gaf732199ecbd953e06943ca0aae99805f">More...</a><br /></td></tr>
<tr class="separator:gaf732199ecbd953e06943ca0aae99805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa603559ff3b65676a6d85aaf762dd2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#gaa603559ff3b65676a6d85aaf762dd2f3">aci_l2cap_connection_parameter_update_resp</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Slave_latency, uint16_t Timeout_Multiplier, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length, uint8_t Identifier, uint8_t Accept)</td></tr>
<tr class="memdesc:gaa603559ff3b65676a6d85aaf762dd2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept or reject a connection update. This command should be sent in response to a <a class="el" href="group___l2_c_a_p__events.html#ga2dee0c664b50509a3ca8477f45b8d5db">aci_l2cap_connection_update_req_event</a> event from the controller. The accept parameter has to be set if the connection parameters given in the event are acceptable.  <a href="group___l2_c_a_p___commands.html#gaa603559ff3b65676a6d85aaf762dd2f3">More...</a><br /></td></tr>
<tr class="separator:gaa603559ff3b65676a6d85aaf762dd2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98bbe3027ba294d9ee96c46bbabe920e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#ga98bbe3027ba294d9ee96c46bbabe920e">aci_l2cap_send_flow_control_credits</a> (uint16_t Connection_Handle, uint16_t CID, uint16_t RX_Credits, uint8_t CFC_Policy, uint16_t *RX_Credit_Balance)</td></tr>
<tr class="memdesc:ga98bbe3027ba294d9ee96c46bbabe920e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to be issued when the device is capable of receiving additional K-frames in LE Credit Based Flow Control mode.  <a href="group___l2_c_a_p___commands.html#ga98bbe3027ba294d9ee96c46bbabe920e">More...</a><br /></td></tr>
<tr class="separator:ga98bbe3027ba294d9ee96c46bbabe920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae719ad8fc72d1e6a2f21d08d4253cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#ga1ae719ad8fc72d1e6a2f21d08d4253cd">aci_l2cap_disconnect</a> (uint16_t Connection_Handle, uint16_t CID)</td></tr>
<tr class="memdesc:ga1ae719ad8fc72d1e6a2f21d08d4253cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to terminate an L2CAP channel.  <a href="group___l2_c_a_p___commands.html#ga1ae719ad8fc72d1e6a2f21d08d4253cd">More...</a><br /></td></tr>
<tr class="separator:ga1ae719ad8fc72d1e6a2f21d08d4253cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf159c3643589935779a81200e9c635cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#gaf159c3643589935779a81200e9c635cc">aci_l2cap_cfc_connection_req</a> (uint16_t Connection_Handle, uint16_t SPSM, uint16_t CID, uint16_t MTU, uint16_t MPS, uint8_t CFC_Policy, uint16_t RX_SDU_Buffer_Size, void *RX_SDU_Buffer)</td></tr>
<tr class="memdesc:gaf159c3643589935779a81200e9c635cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and configure an L2CAP channel between two devices using LE Credit Based Flow Control mode.  <a href="group___l2_c_a_p___commands.html#gaf159c3643589935779a81200e9c635cc">More...</a><br /></td></tr>
<tr class="separator:gaf159c3643589935779a81200e9c635cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7d6c8b2ac086df25b016e7e35cf7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#ga6c7d6c8b2ac086df25b016e7e35cf7bf">aci_l2cap_cfc_connection_resp</a> (uint16_t Connection_Handle, uint8_t Identifier, uint16_t CID, uint16_t MTU, uint16_t MPS, uint16_t Result, uint8_t CFC_Policy, uint16_t RX_SDU_Buffer_Size, void *RX_SDU_Buffer)</td></tr>
<tr class="memdesc:ga6c7d6c8b2ac086df25b016e7e35cf7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command to be sent to respond to a request to open an L2CAP channel using LE Credit based Flow Control (the request is notified through aci_l2cap_cfc_channel_connection_event()).  <a href="group___l2_c_a_p___commands.html#ga6c7d6c8b2ac086df25b016e7e35cf7bf">More...</a><br /></td></tr>
<tr class="separator:ga6c7d6c8b2ac086df25b016e7e35cf7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad231077d2254aec34f04f6371cddf4f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#gad231077d2254aec34f04f6371cddf4f2">aci_l2cap_extract_sdu_data</a> (uint16_t Connection_Handle, uint16_t CID, uint16_t SDU_Data_Buffer_Size, void *SDU_Data_Buffer, uint16_t *SDU_Length)</td></tr>
<tr class="memdesc:gad231077d2254aec34f04f6371cddf4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be used to extract an SDU from receving buffer.  <a href="group___l2_c_a_p___commands.html#gad231077d2254aec34f04f6371cddf4f2">More...</a><br /></td></tr>
<tr class="separator:gad231077d2254aec34f04f6371cddf4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9533655f06868911f8487380de7baf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___commands.html#gad9533655f06868911f8487380de7baf9">aci_l2cap_transmit_sdu_data</a> (uint16_t Connection_Handle, uint16_t CID, uint16_t SDU_Length, uint8_t SDU_Data[])</td></tr>
<tr class="memdesc:gad9533655f06868911f8487380de7baf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to send an SDU using an L2CAP channel in LE Credit Based Flow Control mode. An aci_l2cap_sdu_data_tx_event is raised when the SDU has been processed and buffer can be freed or reused by application.  <a href="group___l2_c_a_p___commands.html#gad9533655f06868911f8487380de7baf9">More...</a><br /></td></tr>
<tr class="separator:gad9533655f06868911f8487380de7baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for Bluetooth Low Energy stack APIs. Autogenerated files, do not edit!! </p>
<dl class="section author"><dt>Author</dt><dd>AMS - RF Application team </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02 March 2022 </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="bluenrg__lp__api_8h_source.html">bluenrg_lp_api.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a008e8bf5b0efc0138300743128635701"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_advertising___set___parameters__t__s.html">Advertising_Set_Parameters_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#a008e8bf5b0efc0138300743128635701">Advertising_Set_Parameters_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Advertising_Set_Parameters_t </p>

</div>
</div>
<a class="anchor" id="ac381829daea9db7081e9594c3a5322ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Bonded_Device_Entry_t </p>

</div>
</div>
<a class="anchor" id="ab42962d78b42f3d482cf1da22b8f5c6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_extended___create___connection___parameters__t__s.html">Extended_Create_Connection_Parameters_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#ab42962d78b42f3d482cf1da22b8f5c6e">Extended_Create_Connection_Parameters_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Extended_Create_Connection_Parameters_t </p>

</div>
</div>
<a class="anchor" id="adfb3b811389de79a4b76f9e2064bf681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_extended___scan___parameters__t__s.html">Extended_Scan_Parameters_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#adfb3b811389de79a4b76f9e2064bf681">Extended_Scan_Parameters_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Extended_Scan_Parameters_t </p>

</div>
</div>
<a class="anchor" id="a46e49c7305b7ff1d34fec3f2e4bcf42b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_handle___entry__t__s.html">Handle_Entry_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#a46e49c7305b7ff1d34fec3f2e4bcf42b">Handle_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Handle_Entry_t </p>

</div>
</div>
<a class="anchor" id="a8a6cc258fb3bbb4a398ce7b4c76cca17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_list___entry__t__s.html">List_Entry_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#a8a6cc258fb3bbb4a398ce7b4c76cca17">List_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct List_Entry_t </p>

</div>
</div>
<a class="anchor" id="a2bd9bdce9ac1181c683947604eb96e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_u_u_i_d__t__s.html">UUID_t_s</a>  <a class="el" href="bluenrg__lp__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C union UUID_t </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2022 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
